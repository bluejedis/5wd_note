# above  

## 【考纲内容】  

（一）指令格式的基本概念（二）指令格式（三）寻址方式（四）数据的对齐和大/小端存放方式（五）CISC和RISC的基本概念（六）高级语言程序与机器级代码之间的对应编译器、汇编器与链接器的基本概念：选择结构语句的机器级表示循环结构语句的机器级表示：过程（函数）调用对应的机器级表示  

## 【复习提示】  

- 指令系统的重要性：
  - 是表征计算机性能的重要因素。

- 需要掌握的内容：
  - 各种寻址方式的特点及有效地址的计算。
  - 三种偏移寻址的计算：相对寻址、基址寻址和变址寻址。
  - CISC与RISC的特点与区别。

- 2022年大纲新增内容：
  - 机器级表示。
  - 能够读懂机器级代码。

- 考试题型：
  - 可能出选择题。
  - 可能结合其他章节出有关指令的综合题。

- 指令相关知识点的重要性：
  - 指令格式、机器指令和指令寻址方式与CPU指令执行过程紧密相关。
  - 需要引起重视。


在学习本章时，请读者思考以下问题  

1）什么是指令？什么是指令系统？为什么要引入指令系统？2）一般来说，指令分为哪些部分？每部分有什么用处？3）对于一个指令系统来说，寻址方式多和少有什么影响？请读者在本章的学习过程中寻找答案，本章末尾会给出参考答案。  

# 指令系统  

## 指令集体系结构  

>pro：指令集体系结构（ISA）规定的内容（2022）  

### 基本概念
- 机器指令（简称指令）是指示计算机执行某种操作的命令
- 一台计算机的所有指令的集合构成该机的指令系统，也称指令集
- 指令系统是指令集体系结构（ISA）中最核心的部分
- ISA完整定义了软件和硬件之间的接口，是机器语言或汇编语言程序员所应熟悉的

### ISA规定内容
> Instruction Set Architecture，指令集体系结构
#### 指令相关规定 
- 指令格式
- 指令寻址方式
- 操作类型
- 每种操作对应的操作数的相应规定

#### 操作数相关规定
- 操作数的类型
- 操作数寻址方式
- 存放方式（大端/小端）

#### 硬件资源规定
- 程序可访问的寄存器
  - 编号
  - 个数
  - 位数
- 存储空间
  - 大小
  - 编址方式

#### 执行控制规定
- 指令执行过程的控制方式
  - 程序计数器
  - 条件码定义

### ISA与程序开发
#### ISA与机器级程序
- <span style="color: green;">规定</span>了机器级程序的格式
- 机器语言或汇编语言程序员必须对机器的ISA非常熟悉

#### 高级语言编程
- 大多数程序员使用高级语言（如C/C++/Java）编写程序
  - 开发效率更高
  - 不易出错
- 局限性：
  - 抽象层太高
  - 隐藏机器级程序细节
  - 难以利用机器结构相关优化

#### ISA知识的重要性
- 程序员对ISA和底层硬件实现细节有充分了解
- 有助于编制高性能程序
## 指令的基本格式

### 基本概念
- 一条指令就是机器语言的一个语句，它是一组有意义的二进制代码
- 一条指令通常包括两部分：
  - 操作码字段
  - 地址码字段

#### 操作码与地址码
- 操作码：
  - 指出该指令应执行什么操作以及具有何种功能
  - 是识别指令、了解指令功能及区分操作数地址内容等的关键信息
  - 例如：
    - 指出是算术加运算还是算术减运算
    - 是程序转移还是返回操作
- 地址码：
  - 给出被操作的信息（指令或数据）的地址
  - 包括：
    - 参加运算的一个或多个操作数的地址
    - 运算结果的保存地址
    - 程序的转移地址
    - 被调用子程序的入口地址等

#### 指令字长
- 定义：一条指令所包含的二进制代码的位数
- 决定因素：
  - 操作码的长度
  - 地址码的长度
  - 地址码的个数
- 与机器字长的关系：
  - 可以等于机器字长
  - 可以大于或小于机器字长
- 分类：
  - 单字长指令：指令长度等于机器字长
  - 半字长指令：指令长度等于半个机器字长
  - 双字长指令：指令长度等于两个机器字长

>attention: 
指令长度的不同会导致取指令时间开销的不同，单字长指令只需访存1次就能将指令完整取出；而双字长指令则需访存2次才能完整取出，耗费2个存取周期。

#### 指令字结构
- 定长指令字结构：
  - 所有指令的长度都相等
  - 特点：执行速度快，控制简单
- 变长指令字结构：
  - 各种指令的长度随指令功能而异
- 注意：因为主存一般是按字节编址的，所以指令字长通常为字节的整数倍

>pro：根据指令格式及相关编码条件组合成机器代码（2015）

### 指令格式分类

#### 零地址指令
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6e7552f06b4d8317fc022359d2dcccb811aec4c3314eb4cd1ac1ec714e795bd3.jpg)
- 只给出操作码OP，没有显式地址
- 两种可能：
  - 不需要操作数的指令
    - 如空操作指令、停机指令、关中断指令等
  - 零地址的运算类指令（用在堆栈计算机中）
    - 参与运算的两个操作数从栈顶和次栈顶弹出
    - 送到运算器进行运算
    - 运算结果压入堆栈

#### 一地址指令
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f73beb07fd477d00ecf244bb03d345248115ffa6dad3968d55fb69658646a4ca.jpg)
- 两种常见形态：
  - 只有目的操作数的单操作数指令：
    - 按A₁地址读取操作数
    - 进行OP操作后，结果存回原地址
    - 指令含义：OP(A₁)→A₁
    - 如：加1、减1、求反、求补、移位等
  - 隐含约定目的地址的双操作数指令：
    - 按指令地址A₁读取源操作数
    - ACC（累加器）提供另一个操作数
    - 运算结果存放在ACC中
    - 指令含义：(ACC)OP(A₁)→ACC

>pro：地址位数与寻址范围的关系（2010、2021）

##### 一地址指令的寻址范围
- 若指令字长为32位：
  - 操作码占8位
  - 1个地址码字段占24位
  - 操作数的直接寻址范围为2²⁴=16M
- 访存次数：
  - 若地址码字段均为主存地址
  - 需要3次访存：
    - 取指令1次
    - 取操作数1次
    - 存结果1次

#### 二地址指令
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/808143d9dc4a64a19f32b18f99d45ecad816da4b5a2564cee34b907da02c8e67.jpg)
- 指令含义：(A₁)OP(A₂)→A₁
- 使用场景：
  - 常用的算术和逻辑运算指令
  - 需要两个操作数
  - 目的操作数地址用于保存运算结果

##### 二地址指令的寻址范围
- 若指令字长为32位：
  - 操作码占8位
  - 两个地址码字段各占12位
  - 每个操作数的直接寻址范围为2¹²=4K
- 访存次数：
  - 若地址码字段均为主存地址
  - 需要4次访存：
    - 取指令1次
    - 取两个操作数2次
    - 存结果1次

#### 三地址指令
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/964f896e4265099daa90e4a7313c3f27dbada8cdcabb04ced0efe9b9d5d4944a.jpg)
- 指令含义：(A₁)OP(A₂)→A₃

##### 三地址指令的寻址范围
- 若指令字长为32位：
  - 操作码占8位
  - 3个地址码字段各占8位
  - 每个操作数的直接寻址范围为2⁸=256
- 访存次数：
  - 若地址码字段均为主存地址
  - 需要4次访存：
    - 取指令1次
    - 取两个操作数2次
    - 存结果1次

#### 四地址指令
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/56bca1a6922d69a95d02641971447a3f6f573122ef2321a9000c316913151d9c.jpg)
- 指令含义：
  - (A₁)OP(A₂)→A₃
  - A₄=下一条将要执行指令的地址

##### 四地址指令的寻址范围
- 若指令字长为32位：
  - 操作码占8位
  - 4个地址码字段各占6位
  - 每个操作数的直接寻址范围为2⁶=64
- 访存次数：
  - 若地址码字段均为主存地址
  - 需要4次访存：
    - 取指令1次
    - 取两个操作数2次
    - 存结果1次
## 定长操作码指令格式  

>pro：定长操作码的指令条数（2015）  

- 定长操作码指令特点：
  - 在指令字的最高位部分分配固定的若干位表示操作码
  - 一般n位操作码字段的指令系统最大能够表示2ⁿ条指令
  - 优点：
    - 简化计算机硬件设计
    - 提高指令译码和识别速度
  - 适用场景：
    - 当计算机字长为32位或更长时的常规用法

## <span style="color: green;">扩展</span>操作码指令格式  

>pro：扩展操作码的设计与分析（2017、2021、2022）  

### 基本概念
- 设计目的：
  - 在指令字长有限的前提下保持丰富的 指令种类
- 特点：
  - 操作码字段 <span style="color: LightSkyBlue;">位数</span> 不**fix**
  - 分散放在 指令字的不同位置上
  - 操作码 长度 随地址码的减少而增加

### 具体实现
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b10a369778010289fef7ffaa5f77b8dcc6e481322d548dc450d59062bbc00886.jpg)  
操作码的位数随地址数的减少而增加  

- 示例分析（16位指令字长）：
  - 基本结构：
    - 4位基本操作码字段OP
    - 3个4位长的地址字段A₁、A₂、A₃
  - 指令分配：
    - 三地址指令：15条（1111留作扩展）
    - 二地址指令：15条（11111111留作扩展）
    - 一地址指令：15条（111111111111留作扩展）
    - 零地址指令：16条

### 注意事项
- 关键原则：
  - 不允许短码是长码的前缀
  - 各指令的操作码不能重复
- 优化建议：
  - 使用频率高的指令分配较短操作码
  - 使用频率低的指令分配较长操作码

## 指令的操作类型  

### 数据传送  
- 主要指令类型：
  - 寄存器之间的传送（MOV）
  - 从内存单元读取数据到CPU寄存器（LOAD）
  - 从CPU寄存器写数据到内存单元（STORE）
  - 进栈操作（PUSH）
  - 出栈操作（POP）

### 算术和逻辑运算  
- 主要指令类型：
  - 算术运算：
    - 加（ADD）
    - 减（SUB）
    - 乘（MUL）
    - 除（DIV）
    - 加1（INC）
    - 减1（DEC）
  - 逻辑运算：
    - 与（AND）
    - 或（OR）
    - 取反（NOT）
    - 异或（XOR）

### 移位操作  
- 主要类型：
  - 算术移位
  - 逻辑移位
  - 循环移位

### 转移操作  

>pro：转跳指令、调用和返回指令、条件转移指令的区分（2019）  

- 主要指令类型：
  - 无条件转移（JMP）
  - 条件转移（BRANCH）
  - 调用（CALL）
  - 返回（RET）
  - 陷阶（TRAP）

- 指令特点：
  - 无条件转移：任何情况下都执行转移操作
  - 条件转移：仅在特定条件满足时执行转移
    - 转移条件：某个标志位的值或几个标志位的组合
  - 调用指令vs转移指令：
    - 调用指令：需保存返回地址，子程序结束后返回主程序
    - 转移指令：不返回执行

### 输入输出操作  
- 主要功能：
  - 完成CPU与外部设备的数据交换
  - 传送控制命令及状态信息 
  

# <span style="color: green;">寻址</span>方式  

寻址方式是指寻找指令或操作数有效地址的方式，即确定本条指令的数据地址及下一条待执行指令的地址的方法。寻址方式分为指令寻址和数据寻址两大类。  

## 指令寻址和数据寻址

寻找下一条将要执行的指令地址称为指令寻址；寻找本条指令的数据地址称为数据寻址。

### 指令寻址

指令寻址方式有两种：一种是顺序导址方式，另一种是跳跃寻址方式。

#### 顺序寻址
- 通过程序计数器PC加1（1条指令的长度），自动形成下一条指令的地址

>pro：PC自增大小与编址方式、指令字长的关系（2013、2014、2019、2023）  

>attention: 

- PC自增的大小与编址方式、指令字长有关
  - 现代计算机通常是按字节编址的
    - 若指令字长为16位，则PC自增为 $(\mathrm{PC})+2$
    - 若指令字长为32位，则PC自增为 $(\mathrm{PC})+4,$

#### 跳跃寻址
- 通过转移类指令实现
- 跳跃是指由本条指令给出下条指令地址的计算方式
- 是否跳跌可能受到状态寄存器的控制
- 跳跃的方式分为：
  - 绝对转移（地址码直接指出转移自标地址）
  - 箱对转移（地址码指出转移目的地址相对于当前PC值的偏移量）
- 由于CPU总是根据PC的内容去主存取指令的，因此转移指令执行的结果是修改PC值，下一条指令仍然通过PC给出

### 数据寻址

>pro：指令格式中各字段的位数分析（2020）  

- 数据寻址是指：
  - 如何在指令中表示一个操作数的地址
  - 怎样计算出操作数的地址
- 数据寻址的方式较多，为区别各种方式：
  - 通常在指令字中设置一个寻址特征字段
  - 用来指明属于哪种寻址方式（其位数决定了寻址方式的种类）

>pro：指令格式中寻址特征字段的作用（2023）  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/cc57f57875406369a446ee41b6e46ac9b01777329de41e632ddfab7ec83264fd.jpg)  

- 指令中的地址码字段并不代表操作数的真实地址
  - 这种地址称为形式地址（A）
  - 形式地址结合寻址方式，可以计算出操作数在存储器中的真实地址
    - 这种地址称为有效地址（EA）
- 不同寻址方式的形式地址位数决定：
  - 若为立即寻址，则形式地址的位数决定了操作数的范围
  - 若为直接寻址，则形式地址的位数决定了可寻址的范围
  - 若为寄存器寻址，则形式地址的位数决定了通用寄存器的最大数量
  - 若为寄存器间接寻址，则寄存器的位数决定了可寻址的范围

>attention: 

（A）表示地址为A的数值，A既可以是寄存器编号，又可以是内存地址。
## 常见的数据寻址方式

### 基本寻址方式
#### 隐含寻址
- 不明显地给出操作数的地址，而是隐含操作数的地址
  - 例如，单地址指令格式隐含约定第二个操作数由累加器(ACC)提供
  - 指令中只明显指出第一个操作数的地址

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/eb95a905f61e44cad56b518a1aa375ef438a60ca7ed3fc676e2fa55c6f573d41.jpg)  
图4.2隐含寻址  

- 优缺点
  - 优点：有利于缩短指令字长
  - 缺点：需增加存储操作数或隐含地址的硬件

#### 立即（数）寻址
>pro：立即寻址的概念（2023）

- 指令字中的地址字段指出的不是操作数的地址，而是操作数本身
  - 也称立即数，采用补码表示
  - #表示立即寻址特征，A就是操作数
- 优缺点
  - 优点：指令在执行阶段不访存，指令执行速度最快
  - 缺点：A的位数限制了立即数的范围

#### 直接寻址
- 指令字中的形式地址A就是操作数的真实地址EA
  - EA = A

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/948183c5b772d6544c6bec9a19645480a2b25ccbad62d507552486df04009957.jpg)  

- 优缺点
  - 优点
    - 简单，不需要专门计算操作数的地址
    - 指令在执行阶段仅需访存一次
  - 缺点
    - A的位数限制了该指令操作数的寻址范围
    - 操作数的地址不易修改

### 间接寻址类
#### 间接寻址
- 指令的地址字段给出的是操作数有效地址所在主存单元的地址
  - 即操作数地址的地址
  - EA = (A)

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/297661d0b53d517f5369db6eeea0399b48288d259fb0194ce89d2cff392ca596.jpg)  
图4.5间接寻址  

- 优缺点
  - 优点
    - 可扩大寻址范围
    - 便于编制程序
  - 缺点：指令在执行阶段要多次访存

#### 寄存器寻址
- 与直接寻址原理相同，但访问寄存器而非主存
  - 指令的地址字段给出操作数所在寄存器的编号
  - EA = Ri

>pro：寄存器编号位数与寄存器数量的关系（2022）  

- 优缺点
  - 优点
    - 执行速度快，不用访存
    - 指令字长较短
  - 缺点
    - 寄存器价格昂贵
    - CPU寄存器数量有限

#### 寄存器间接寻址
>pro：寄存器间接寻址的取数操作（2010）  

- 综合了间接寻址和寄存器寻址特点
  - Ri所指寄存器给出操作数所在主存单元的地址
  - EA = (Ri)

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/92cc364b37cca2cace4edc484a7917ca840b456ec8c78df2714108a04df0e6ef.jpg)  
图4.6寄存器寻址  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/71cf46d10de7a2353718ca3f208d5dd43920b00188d4ad2d26638c7036ec9415.jpg)  
图4.7寄存器间接寻址  

- 特点比较
  - 相比间接寻址
    - 扩大了寻址范围
    - 减少了访存次数
  - 相比寄存器寻址
    - 执行阶段需要访存获得操作数

### 偏移寻址类
#### 相对寻址
>pro：相对寻址的偏移量或目标地址的计算（2009、2013、2014、2019、2023）  

- PC内容加上指令格式中的形式地址A形成操作数的有效地址
  - EA = (PC) + A
  - A是相对于当前PC值的偏移量，可正可负，补码表示

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/54a79a897f2ebe46f3c3320ba9fc90c8d14eba5a2917c433c88919cf0d1c4e2d.jpg)  
图4.8相对寻址  

- A的位数决定操作数的寻址范围
- 优点
  - 操作数地址不固定，随PC值变化
  - 与指令地址保持固定偏移量
  - 便于程序浮动
- 广泛应用于转移指令

>pro：相对寻址转跳范围的计算（2010、2013、2014）  

>attention: 

对于转移指令JMPA，若指令的地址为X，且占2B，则在取出该指令后，PC的值会增2，即 $(\mathrm{PC})\,{=}\,\mathrm{X}+2$ ，这样在执行完该指令后，会自动跳转到 $\mathrm{X}+2+\mathrm{A}$ 的地址继续执行。  

#### 基址寻址
>pro：基址寻址的EA的计算（2019）  

- 基址寄存器内容加上指令字中的形式地址A形成操作数的有效地址
  - EA = (BR) + A
  - 基址寄存器可以是专用寄存器或通用寄存器

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a34564d3543b6f2ccacb8cfb471b140348d32097e27bbf6b321ab8f9a9a2be06.jpg)  
图4.9基址寻址  

- 特点
  - 面向操作系统
  - 内容由操作系统或管理程序确定
  - 执行过程中基址寄存器内容不变
- 优点
  - 可以扩大寻址范围
  - 有利于多道程序设计
  - 可用于编制浮动程序
- 缺点：偏移量位数较短

#### 变址寻址
>pro：变址寻址的EA的计算（2013），先变址后间址方式的EA的计算（2016）  

- 变址寄存器内容加上指令字中的形式地址A形成操作数的有效地址
  - EA = (IX) + A
  - 可用专用变址寄存器或通用寄存器

>pro：变址寻址的适用场景（2017）  

- 特点
  - 面向用户
  - 执行过程中变址寄存器内容可变
  - 形式地址A不变

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9f0e1bf068edf0a515fc2ed92442f6f857a8030bab1164982e17c514ba92116c.jpg)  
图4.10变址寻址  

>pro：变址寻址访问数组的过程（2018）  

- 与基址寻址的区别
  - 基址寻址
    - 面向系统
    - 基址寄存器内容不可变
    - 指令字中A可变
  - 变址寻址
    - 面向用户
    - 变址寄存器内容可变
    - 指令字中A不可变

>pro：偏移寻址的范畴（2011）  

- 偏移寻址包括
  - 相对寻址
  - 基址寻址
  - 变址寻址

### 特殊寻址方式
#### 堆栈寻址
- 堆栈特点
  - 特定存储区域
  - 后进先出(LIFO)原则
  - 使用堆栈指针(SP)管理
- 堆栈类型
  - 硬堆栈(寄存器堆栈)
    - 成本高
    - 不适合大容量
  - 软堆栈(主存区域)
    - 成本低
    - 最常用
- 操作特点
  - 大部分指令表现为无操作数形式
  - 隐含使用SP
  - 自动完成SP的加减操作

表4.1寻址方式、有效地址及访存次数
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c51f3e89ddc451b47a9e622c8b801b80139caf0bb46af25e8b2187d5cd2dfd58.jpg)  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e1c50194cc3786f302b53c78b63af2b45a119ca8380862b67f5dcabb0710cde4.jpg)  
  

# 程序' 机器级**代码**表示  

>pro：涉及过汇编代码的真题的年份（2012、2014、2015、2017、2019、2023）  

本节是2022年才新增的考点，但历年统考真题曾多次以综合题的形式考查过，难度较大，不少跨考生对此无从下手，相信通过本节的学习后，应能从容应对。统考大纲没有指定具体指令集，但历年统考真题主要考查的是x86汇编指令，因此本节主要介绍x86汇编指令。  
## 常用汇编指令介绍  

#### 相关寄存器  

- x86处理器有8个32位的通用寄存器
  - 各寄存器及说明如图4.11所示
  - EAX、EBX、ECX和EDX的高两位字节和低两位字节可独立使用
    - E表示Extended，表示32位寄存器
    - 如EAX的低两位字节称为AX
      - AX的高低字节可分别作为两个8位寄存器
      - 分别称为AH和AL

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/16098179b12ef23c80f73188e819d11bf3ea18af269656a719130684f2a6f922.jpg)  
图4.11x86处理器中的主要寄存器及说明  

- 除EBP和ESP外，其他几个寄存器的用法比较灵活

#### 汇编指令格式  

- 使用不同编程工具开发程序时，用到的汇编程序不同
  - 两种不同的汇编格式
    - AT&T格式 
    - Intel格式（统考要求掌握）

##### 主要区别
- 大小写要求
  - AT&T格式：指令只能用小写字母
  - Intel格式：指令对大小写不敏感

- 操作数顺序
  - AT&T格式：第一个为源操作数，第二个为目的操作数，方向从左到右
  - Intel格式：第一个为目的操作数，第二个为源操作数，方向从右向左

- 前缀使用
  - AT&T格式：寄存器需加前缀"$\omega_{0}$"，立即数需加前缀"$\S$"
  - Intel格式：寄存器和立即数都不需要加前缀

- 内存寻址符号
  - AT&T格式：使用"（"和")"
  - Intel格式：使用"["和"]"

- 复杂寻址方式
  - AT&T格式：disp(base,index,scale)
    - 如"8(%edx,%eax,2)"表示$\mathrm{M}[\mathrm{R}[\mathrm{edx}]+\mathrm{R}[\mathrm{eax}]^{*}2+8]$
  - Intel格式：对应为'$^{*}[\mathrm{edx+ex}^{*}2+8]$

- 数据长度指定
  - AT&T格式：操作码后加字符
    - "b"表示byte（字节）
    - "w"表示word（字）
    - "l"表示long（双字）
  - Intel格式：使用ptr
    - byte ptr
    - word ptr
    - dword ptr

>attention: 

由于32或64位体系结构都是由16位扩展而来的，因此用word（字）表示16位。  

表4.2展示了两种格式的几条不同指令。其中，mov指令用于在内存和寄存器之间或者寄存器之间移动数据；lea指令用于将一个内存地址（而不是其所指的内容）加载到目的寄存器。  
表4.2AT&T格式指令和Imtel格式指令的对比
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/49dd1199e96b48c53ff69b24837136b50fa7439742b0d9afe5606d78dc87dc74.jpg)  
注：R[表示寄存器r的内容，M[addr]表示主存单元addr的内容，→或$\leftarrow$表示信息传送方向。  

- 两种汇编格式的相互转换并不复杂，但历年统考真题采用的均是Intel格式
### 常用指令  

汇编指令通常可分为数据传送指令、算术和逻辑运算指令和控制流指令，下面以Intel格式为例，介绍一些常用的指令。

#### 操作数标记说明
- \<reg>：表示任意寄存器
  - \<reg32>：32位寄存器(eax,ebx,ecx,edx,esi,edi,esp或ebp)
  - \<reg16>：16位寄存器(ax,bx,cx或dx)
  - \<reg8>：8位寄存器(ah,al,bh,bl,ch,cl,dh,dl)
- \<mem>：表示内存地址(如[eax]、[var + 4]或dword ptr[eax + ebx])
- \<con>：表示常数
  - \<con8>：8位常数
  - \<con16>：16位常数
  - \<con32>：32位常数

>pro：分析汇编指令对应的二进制代码（2010）  

#### x86指令机器码
- 指令机器码长度为1字节
- 同一指令有多种编码方式
  - 如mov指令有28种机内编码
    - movax,\<conl6> #机器码为B8H 
    - moval,\<con8> #机器码为BOH
    - mov \<reg16>,\<reg16>/\<mem16> #机器码为89H
    - mov\<reg8>/\<mem8>,\<reg8> #机器码为8AH
    - mov\<reg16>/\<mem16>,\<reg16> #机器码为8BH

>pro：模仿写出简单语句的机器级指令（2012）  

#### 数据传送指令
##### mov指令
- 功能：将第二个操作数复制到第一个操作数
- 语法：
  - mov\<reg>,\<reg>
  - mov\<reg>,\<mem>
  - mov\<mem>,\<reg>
  - mov\<reg>,\<con>
  - mov\<mem>,\<con>
- 举例：
  - moveax,ebx
  - mov byte ptr[var],5
- 注意：双操作数不能都是内存

##### push指令
- 功能：将操作数压入栈
- 语法：
  - push \<reg32>
  - push \<mem>
  - push \<con32>
- 举例：
  - pusheax
  - push[var]

##### pop指令
- 功能：执行出栈工作
- 语法：
  - pop\<reg32>
  - pop\<mem>
- 举例：
  - popeax
  - pop[ebx]

#### 算术和逻辑运算指令
##### add/sub指令
- 功能：
  - add：两操作数相加
  - sub：两操作数相减
- 语法：
  - add/sub\<reg>,\<reg>
  - add/sub\<reg>,\<mem>
  - add/sub\<mem>,\<reg>
  - add/sub\<reg>,\<con>
  - add/sub\<mem>,\<con>
- 举例：
  - subeax,10
  - add byte ptr[var],10

##### inc/dec指令
- 功能：
  - inc：自加1
  - dec：自减1
- 语法：
  - inc/dec\<reg>
  - inc/dec\<mem>
- 举例：
  - deceax
  - inc dword ptr[var]

##### imul指令
- 功能：有符号整数乘法
- 语法：
  - imul\<reg32>,\<reg32>
  - imul\<reg32>,\<mem>
  - imul\<reg32>,\<reg32>,\<con>
  - imul\<reg32>,\<mem>,\<con>
- 举例：
  - imul eax,[var]
  - imul esi,edi,25

##### idiv指令
- 功能：有符号整数除法
- 语法：
  - idiv\<reg32>
  - idiv\<mem>
- 举例：
  - idivebx
  - idiv dword ptr[var]

##### and/or/xor指令
- 功能：位操作
- 语法：
  - and/or/xor\<reg>,\<reg>
  - and/or/xor\<reg>,\<mem>
  - and/or/xor\<mem>,\<reg>
  - and/or/xor\<reg>,\<con>
  - and/or/xor\<mem>,\<con>
- 举例：
  - andeax,OfH
  - xoredx,edx

##### not指令
- 功能：位翻转
- 语法：
  - not\<reg>
  - not\<mem>
- 举例：
  - not byte ptr[var]

##### neg指令
- 功能：取负
- 语法：
  - neg\<reg>
  - neg\<mem>

##### shl/shr指令
- 功能：
  - shl：逻辑左移
  - shr：逻辑右移
- 语法：
  - shl/shr\<reg>,\<con8>
  - shl/shr\<mem>,\<con8>
  - shl/shr\<reg>,\<cl>
  - shl/shr\<mem>,\<cl>
- 举例：
  - shleax,1
  - shrebx,cl

#### 控制流指令
- x86处理器维持着指令指针(IP)
  - IP自动指向下一条指令
  - 可用标签指示程序中的指令地址

>pro：无条件转移指令的指令格式（2021）  

##### jmp指令
- 功能：无条件跳转
- 语法：
  - jmp\<label>
- 举例：
  - jmpbegin

>pro：条件转移指令与标志位的结合（2013）  

##### jcondition指令
- 功能：条件转移
- 语法：
  - je\<label>
  - jz\<label>
  - jne\<label>
  - jg\<label>
  - jge\<label>
  - jl\<label>
  - jle\<label>
- 举例：
  - cmpeax,ebx
  - jledone

##### cmp/test指令
- 功能：
  - cmp：比较操作
  - test：逐位与运算
- 语法：
  - cmp/test\<reg>,\<reg>
  - cmp/test\<reg>,\<mem>
  - cmp/test\<mem>,\<reg>
  - cmp/test\<reg>,\<con>
- 举例：
  - cmp dword ptr[var],10
  - testeax,eax

>pro：call指令的功能（2019）  

##### call/ret指令
- 功能：
  - call：子程序调用
  - ret：子程序返回
- 语法：
  - call\<label>
  - ret
- 特点：
  - call保存调用前地址
  - ret实现返回机制
## 选择语句的机器级表示

### 条件码与指令
- 常见的选择结构语句有if-then、if-then-else等
- 编译器实现方式：
  - 通过条件码（标志位）设置指令
  - 各类转移指令
- 条件码特点：
  - 描述最近的算术或逻辑运算操作的属性
  - 可以检测这些寄存器来执行条件分支指令
  - 最常用的条件码：CF、ZF、SF和OF

### 条件码设置指令
- 常见的算术逻辑运算指令会设置条件码：
  - add, sub, imul
  - or, and
  - shl, inc, dec, not, sal等
- 特殊指令：
  - cmp和test指令只设置条件码
  - 不改变任何其他寄存器
- jcondition条件转跳指令根据条件码ZF和SF来实现转跳

### if-else语句实现
#### 通用形式
- if(test_expr) then_statement else else_statement
- 特点：
  - test_expr是整数表达式
  - 取值为0（假）或非0（真）
  - 两个分支语句只执行一个

#### goto语句形式转换
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/99de2ec0647f045fd562ae8b7c72c2a534fddb8bc8716ce24718f9784d401682.jpg)  

### 实例分析
#### C语言函数示例

int get_cont(int *p1, int *p2)
if(p1>p2) return *p2;
else return *p1;


#### 汇编代码实现
- 已知条件：
  - p1和p2对应实参已压入调用函数的栈帧
  - 存储地址：R[ebp]+8和R[ebp]+12
  - EBP指向当前栈帧底部
  - 返回结果存放在EAX中

- 具体代码：

mov eax,dword ptr [ebp+8]    #R[eax]←M[R[ebp]+8],即R[eax]=p1
mov edx,dword ptr [ebp+12]   #R[edx]←M[R[ebp]+12],即R[edx]=p2
cmp eax,edx                  #比较p1和p2，即根据p1-p2的结果置标志
jbe .L1                      #若p1<=p2，则转标记L1处执行
mov eax,dword ptr [edx]      #R[eax]←M[R[edx]],即R[eax]=M[p2]
jmp .L2                      #无条件跳转到标记L2执行
.L1:
mov eax,dword ptr [eax]      #R[eax]←M[R[eax]],即R[eax]=M[p1]
.L2:


- 实现说明：
  - p1和p2是指针型参数，32位机中长度是dword ptr
  - 比较指令cmp的两个操作数都应来自寄存器
  - 需要先将p1和p2从栈中取到通用寄存器
  - 比较指令执行后得到各个条件码
  - 根据条件码值组合选择执行不同指令
  - 使用条件转移指令实现跳转
## 循环语句的机器级表示  

>pro：循环语句的机器级代码分析（2014、2017、2019、2023）  

### 循环结构概述
- 常见的循环结构语句有while、for和do-while
- 汇编中没有相应的指令存在
  - 可以用条件测试和转跳组合起来实现循环效果
  - 大多数编译器将这三种循环结构都转换为do-while形式来产生机器代码
- 在循环结构中，通常使用条件转移指令来判断循环条件的结束

### 循环语句的实现
#### do-while循环实现
- 通用形式：
  - do body_statement while(test_expr);
- goto语句形式：
  - loop: body_statement
  - t = test_expr;
  - if(t) goto loop;
- 特点：
  - body_statement至少执行一次
  - 然后执行测试表达式
  - 若测试为真，则继续执行循环

#### while循环实现
- 通用形式：
  - while(test_expr) body_statement
- 转换为do-while形式：
  - t = test_expr;
  - if(!t) goto done;
  - do body_statement while(test_expr);
  - done:
- goto语句形式：
  - t = test_expr;
  - if(!t) goto done;
  - loop: body_statement
  - t = test_expr;
  - if(t) goto loop;
  - done:

#### for循环实现
- 通用形式：
  - for(init_expr; test_expr; update_expr)

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c59e1434ff34a9f2d84130def9419a860a7e3cf1681145df32fe17e1ef02bf32.jpg)  

- 等价while循环形式：
  - init_expr;
  - while(test_expr){
    - body_statement
    - update_expr;
  }
- goto语句形式：
  - init_expr;
  - t = test_expr;
  - if(!t) goto done;
  - loop: body_statement
  - update_expr;
  - t = test_expr;
  - if(t) goto loop;
  - done:

### 实例分析：for循环求和
#### 函数代码
- int nsum_for(int n){
  - int i;
  - int result = 0;
  - for(i=1; i<=n; i++)
    - result += i;
  - return result;
}

#### 循环组成部分
- init_expr: i = 1
- test_expr: i <= n
- update_expr: i++
- body_statement: result += i

#### 汇编代码实现
- 已知条件：
  - n对应实参已压入调用函数的栈帧
  - 存储地址为R[ebp]+8
  - 局部变量i和result分别在EDX和EAX中
  - 返回参数在EAX中

- 具体代码：

mov ecx,dword ptr [ebp+8]    #R[ecx]←M[R[ebp]+8]，即R[ecx]=n
mov eax,0                    #R[eax]←0,即result=0
mov edx,1                    #R[edx]←1，即i=1
cmp edx,ecx                  #Compare R[edx]:R[ecx]，即比较i:n
jg L2                        #If greater，转跳到L2执行
.L1:                         #loop:
add eax,edx                  #R[eax]←R[eax]+R[edx], 即result+=i
add edx,1                    #R[edx]←R[edx]+1，即i++
cmp edx,ecx                  #比较R[edx]和R[ecx]，即比较i:n
jle .L1                      #If less or equal，转跳到L1执行
.L2:
## 过程调用的机器级表示

### 过程调用的执行步骤
- 假定过程P（调用者）调用过程Q（被调用者），过程调用的执行步骤如下：
  - 1）P将入口参数（实参）放到Q能访问到的地方
  - 2）P将返回地址存到特定的地方，然后将控制转移到Q
  - 3）Q保存P的现场（通用寄存器的内容），并为自己的非静态局部变量分配空间
  - 4）执行过程Q
  - 5）Q恢复P的现场，将返回结果放到P能访问到的地方，并释放局部变量所占空间
  - 6）Q取出返回地址，将控制转移到P

### 寄存器使用规范
- 用户可见寄存器数量有限，调用者和被调用者需共享寄存器
  - 调用者保存寄存器：EAX、ECX和EDX
  - 被调用者保存寄存器：EBX、ESI、EDI

### 栈帧结构
- 每个过程都有自己的栈区，称为栈帧
  - 一个栈由若干栈帧组成
  - 寄存器EBP指示栈帧的起始位置
  - 寄存器ESP指示栈顶
  - 栈从高地址向低地址增长

### 过程调用实例分析
#### C语言程序示例
- int add（int x, int y）{ 
  - return x+y 
- int caller(){ 
  - int temp1 = 125
  - int temp2 = 80
  - int sum = add(temp1,temp2）
  - return sum

#### caller过程的汇编代码实现
- caller过程对应的代码如下：
  - caller:
    - push ebp
    - mov ebp,esp
    - sub esp,24
    - mov[ebp-12],125
    - mov[ebp-8],80
    - mov eax,dword ptr [ebp-8]
    - mov[esp+4],eax
    - mov eax,dword ptr[ebp-12]
    - mov[esp],eax
    - call add
    - mov[ebp-4],eax
    - mov eax,dword ptr[ebp-4]
    - leave

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d980c64caf10e8c75223e749aaa0890e4e8f054132e40c8f446ccc6806ddab98.jpg)  
图4.12caller add  

#### leave指令功能
- leave指令功能相当于以下两条指令：
  - mov esp，ebp
  - pop ebp

#### add过程的汇编代码实现
- add过程经GCC编译并链接后的代码：
  - 8048469:55 push ebp
  - 804846a:89e5 mov ebp,esp
  - 804846c:8b450c mov eax,dword ptr [ebp+12]
  - 804846f:8b5508 mov edx,dword ptr [ebp+8]
  - 8048472:8d0402 lea eax,[edx+eax]
  - 8048475:5d pop ebp
  - 8048476:c3 ret

### 过程的代码组成部分
#### 准备阶段
- 将当前栈指针ESP传送到EBP
- 完成将EBP指向当前栈帧底部的任务

#### 过程体
- 执行主要功能
- 过程体结束时将返回值放在EAX中

#### 结束阶段
- 通过将EBP弹出栈帧来恢复EBP值
- 在栈中退出过程的栈帧
- 使栈顶指向返回地址 

# <span style="color: purple;">C</span>ISC <span style="color: green;">R</span>ISC  

### CISC与RISC的发展方向
- 指令系统朝两个截然不同的方向的发展：
  - 一是增强原有指令的功能，设置更为复杂的新指令实现软件功能的硬化
    - 这类机器称为复杂指令系统计算机（CISC）
    - 典型的有采用 $\mathrm{x86}$ 架构的计算机
  - 二是减少指令种类和简化指令功能，提高指令的执行速度
    - 这类机器称为精简指令系统计算机（RISC）
    - 典型的有ARM、MIPS架构的计算机

### 复杂指令系统计算机（CISC）
Complex Instruction Set Computer
#### CISC的产生背景
- 随着集成电路技术的发展，软件成本不断上升
- 促使人们在指令系统中增加更多、更复杂的指令，以适应不同的应用领域

>pro： CISC的特点(2017)  

#### CISC的主要特点
- 指令系统复杂庞大，指令数目一般为200条以上
- 指令的长度不固定，指令格式多，寻址方式多
- 可以访存的指令不受限制
- 各种指令使用频度相差很大
- 各种指令执行时间相差很大，大多数指令需多个时钟周期才能完成
- 控制器大多数采用微程序控制，有些指令非常复杂，以至于无法采用硬连线控制

#### CISC的局限性
- 庞大的指令系统对指令设计提出极高要求，研制周期长
- 指令使用频率差异大
  - 20%的简单指令被反复使用，约占整个程序的80%
  - 80%的复杂指令很少使用，约占整个程序的20%

### 精简指令系统计算机（RISC）
Reduced Instruction Set Computer
#### RISC的设计理念
- 中心思想：
  - 要求指令系统简化
  - 尽量使用寄存器-寄存器操作指令
  - 指令格式力求一致

#### RISC的主要特点
- 选取使用频率最高的简单指令，复杂指令由简单指令组合实现
- 指令长度固定，指令格式种类少，寻址方式种类少
- 只有LOAD/STORE指令访存，其余指令在寄存器间进行
- CPU中通用寄存器数量多
- 采用指令流水线技术，大部分指令在一个时钟周期内完成
- 以硬布线控制为主，不用或少用微程序控制
- 特别重视编译优化工作，以减少程序执行时间

#### RISC的兼容性问题
- CISC大多能实现软件兼容
- RISC简化指令系统，与老机器不兼容
- 现状分析：
  - Intel几乎一统江湖
  - 早期软件多基于CISC设计
  - 现代CISC已融合RISC特性，性能差距缩小

### CISC与RISC的比较
#### RISC的优势
- VLSI芯片面积利用
  - CISC：控制存储器占CPU芯片面积50%以上
  - RISC：硬布线逻辑只占CPU芯片面积10%左右
- 运算速度
  - 指令数、寻址方式和格式种类少
  - 多个通用寄存器
  - 采用流水线技术
- 设计和可靠性
  - 设计周期短
  - 逻辑简单，出错概率低
- 编译优化
  - 指令类型少，寻址方式少
  - 便于编译程序选择更有效的指令和寻址方式

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c72ca4df9a8e8d7fdeb190d640247354dcff3e2ee6fb58e6a641d46da41d6b00.jpg)  


# <span style="color: gray;">本章小结</span>  

本章开头提出的问题的参考答案如下。  

1）什么是指令？什么是指令系统？为什么要引入指令系统？  

指令就是要计算机执行某种操作的命令。一台计算机中所有机器指令的集合，称为这台计算机的指令系统。引入指令系统后，避免了用户与二进制代码直接接触，使得用户编写程序更为方便。另外，指令系统是表征一台计算机性能的重要因素，它的格式与功能不仅直接影响到机器的硬件结构，而且也直接影响到系统软件，影响到机器的适用范围。  
2）一般来说，指令分为哪些部分？每部分有什么用处？  

一条指令通常包括操作码字段和地址码字段两部分。其中，操作码指出指令中该指令应该执行什么性质的操作和具有何种功能，它是识别指令、了解指令功能与区分操作数地址内容的组成和使用方法等的关键信息。地址码用于给出被操作的信息（指令或数据）的地址，包括参加运算的一个或多个操作数所在的地址、运算结果的保存地址、程序的转移地址、被调用子程序的入口地址等。  

3）对于一个指令系统来说，寻址方式多和少有什么影响？  

寻址方式的多样化能让用户编程更为方便，但多重寻址方式会造成CPU结构的复杂化（详见下章），也不利于指令流水线的运行。而寻址方式太少虽然能够提高CPU的效率，但对于用户而言，少数几种寻址方式会使编程变得复杂，很难满足用户的需求。  

# <span style="color: gray;">常见问题和易混淆知识点</span>  

1.简述各常见指令寻址方式的特点和适用情况。  

立即寻址操作数获取便捷，通常用于给寄存器赋初值。  

直接寻址相对于立即寻址，缩短了指令长度。  

间接寻址扩大了寻址范围，便于编制程序，易于完成子程序返回。  

寄存器寻址的指令字较短，指令执行速度较快。  

寄存器间接寻址扩大了寻址范围。  

基址寻址扩大了操作数寻址范围，适用于多道程序设计，常用于为程序或数据分配存储空间。  

变址寻址主要用于处理数组问题，适合编制循环程序。  

相对寻址用于控制程序的执行顺序、转移等。  

基址寻址和变址寻址的区别：两种方式有效地址的形成都是寄存器内容+偏移地址，但是在基址寻址中，程序员操作的是偏移地址，基址寄存器的内容由操作系统控制，在执行过程中是动态调整的；而在变址寻址中，程序员操作的是变址寄存器，偏移地址是固定不变的。  

2.一个操作数在内存可能占多个单元，怎样在指令中给出操作数的地址？  

现代计算机都采用字节编址方式，即一个内存单元只能存放一字节的信息。一个操作数（如char、int、float、double）可能是8位、16位、32位或64位等，因此可能占用1个、2个、4个或8个内存单元。也就是说，一个操作数可能有多个内存地址对应。  

有两种不同的地址指定方式：大端方式和小端方式。大端方式：指令中给出的地址是操作数最高有效字节（MSB）所在的地址。小端方式：指令中给出的地址是操作数最低有效字节（LSB）所在的地址。3.装入/存储（LOAD/STORE）型指令有什么特点？  

装入/存储型指令是用在规整型指令系统中的一种通用寄存器型指令风格。这种指令风格在RISC指令系统中较为常见。为了规整指令格式，使指令具有相同的长度，规定只有LOAD/STORE指令才能访问内存。而运算指令不能直接访问内存，只能从寄存器取数进行运算，运算的结果也只能送到寄存器。因为寄存器编号较短，而主存地址位数较长，通过某种方式可使运算指令和访存指令的长度一致。  

这种装入/存储型风格的指令系统的最大特点是，指令格式规整，指令长度一致，一般为32位。由于只有LOAD/STORE指令才能访问内存，因此程序中可能包含许多装入指令和存储指令，与一般通用寄存器型指令风格相比，其程序长度会更长。  