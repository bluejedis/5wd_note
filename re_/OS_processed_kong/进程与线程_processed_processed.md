以下是按照您的要求对提供的 Markdown 文档进行挖空处理后的结果，挖空的关键词、公式定理和关键步骤已设置为空缺，并在每个次级标题下使用 HTML 折叠块列出答案。内容结构保持不变，输出格式同时包括 Markdown 和 HTML 折叠块。

---

# 进程与线程

<ul>

在学习本节时，请读者思考以下问题：  
1）为什么要引入进程？2）什么是进程？进程由什么组成？  
3）进程是如何解决问题的？  

希望读者带着上述问题去学习本节内容，并在学习的过程中多思考，从而更深入地理解本节内容。进程本身是一个比较抽象的概念，它不是实物，看不见、摸不着，初学者在理解进程概念时存在一定困难，在介绍完进程的相关知识后，我们会用比较直观的例子帮助大家理解。

## 概念和特征

<ul>

### 进程的概念

<ul>

#### 进程的引入背景
- 多道程序环境下的特点：
  - 程序失去____性
  - 具有____性
  - 具有____性特征
- 引入进程的目的：
  - 更好地____和____程序的并发执行
  - 实现操作系统的____性和____性

#### 进程实体的组成
- ____段
- 相关____段
- ____（进程控制块）
  - 创建进程即创建____
  - 撤销进程即撤销____

#### 进程的定义
- 典型定义：
  - 进程是一个正在____程序的实例
  - 进程是程序及数据从磁盘加载到内存后在____上的执行过程
  - 进程是程序在数据集合上____的过程
- 传统操作系统定义：
  - 进程是进程实体的____过程
  - 是系统进行____和____的独立单位

</ul>

<div>
<details>
  <summary> </summary>
  <ul>
    <li>

封闭</li>
    <li>

间断</li>
    <li>

不可再现</li>
    <li>

描述</li>
    <li>

控制</li>
    <li>

并发</li>
    <li>

共享</li>
    <li>

程序</li>
    <li>

数据</li>
    <li>

PCB</li>
    <li>

PCB</li>
    <li>

PCB</li>
    <li>

执行</li>
    <li>

CPU</li>
    <li>

运行</li>
    <li>

运行</li>
    <li>

资源分配</li>
    <li>

调度</li>
  </ul>
</details>
</div>

### 进程的特征

<ul>

#### 基本特征
- ____性：
  - 有创建、活动、暂停、终止等过程
  - 具有____周期
  - 是动态产生、变化和消亡的
- ____性：
  - 多个进程同存于内存
  - 能在一段时间内同时运行
- ____性：
  - 能独立运行
  - 能独立获得资源
  - 能独立接受调度
- ____性：
  - 进程按各自独立的速度推进
  - 导致执行结果不可再现
  - 需要进程____机制

</ul>

<div>
<details>
  <summary> </summary>
  <ul>
    <li>

动态</li>
    <li>

生命</li>
    <li>

并发</li>
    <li>

独立</li>
    <li>

异步</li>
    <li>

同步</li>
  </ul>
</details>
</div>

</ul>

## 组成

<ul>

### 进程控制块

<ul>

#### PCB的基本概念
- 创建时机：进程____时
- 存在特点：常驻____
- 重要性：是进程存在的____标志

#### PCB的作用
- 进程____时的作用
- 进程____时的作用
- 进程____通信时的作用
- 进程____时的作用

#### PCB的内容
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/40c9fe37acec0dc1358828cc24c82b9fbaff9508f1d593f7c1605e5a6ae8ff94.jpg)

<ul>

##### 进程描述信息
- 进程____符
- 用户____符

##### 进程控制和管理信息
- 进程当前____
- 进程____级

##### 资源分配清单
- 内存____空间信息
- 打开____列表
- ____设备信息

##### 处理机相关信息
- ____上下文
- ____器值

</ul>

#### PCB的组织方式
- ____方式：
  - 同状态PCB链接成队列
  - 可根据阻塞原因分多队列
- ____方式：
  - 同状态进程组织在索引表中
  - 不同状态对应不同索引表

</ul>

<div>
<details>
  <summary> </summary>
  <ul>
    <li>

创建</li>
    <li>

内存</li>
    <li>

唯一</li>
    <li>

执行</li>
    <li>

调度</li>
    <li>

同步</li>
    <li>

暂停</li>
    <li>

标识</li>
    <li>

标识</li>
    <li>

状态</li>
    <li>

优先</li>
    <li>

地址</li>
    <li>

文件</li>
    <li>

I/O</li>
    <li>

CPU</li>
    <li>

寄存</li>
    <li>

链接</li>
    <li>

索引</li>
  </ul>
</details>
</div>

### 程序段
- 能被进程____程序调度到____执行的代码段
- 可被多个进程____

### 数据段
- 程序加工处理的____数据
- 程序执行时的____或最终结果

</ul>

<div>
<details>
  <summary> </summary>
  <ul>
    <li>

调度</li>
    <li>

CPU</li>
    <li>

共享</li>
    <li>

原始</li>
    <li>

中间</li>
  </ul>
</details>
</div>

## 进程的状态与转换

<ul>

### 五种基本状态

<ul>

#### 运行态
- 进程正在____上运行
- 单CPU系统同时只有一个进程处于____态

#### 就绪态
- 获得除____外的所有资源
- 等待____分配
- 组织为____队列

> pro：执行中断处理程序时进程的状态（2023）

#### 阻塞态
- 等待某____或____
- 即使____空闲也不能运行
- 可能有多个____队列

#### 创建态
- 进程正在被____
- 尚未转到____态
- 创建步骤：
  - 申请空白____
  - 填写____信息
  - 分配必要____
  - 转入____态

#### 终止态
- 进程正从系统中____
- 可能原因：
  - ____结束
  - 其他原因____

</ul>

<div>
<details>
  <summary> </summary>
  <ul>
    <li>

CPU</li>
    <li>

运行</li>
    <li>

CPU</li>
    <li>

CPU</li>
    <li>

就绪</li>
    <li>

事件</li>
    <li>

资源</li>
    <li>

CPU</li>
    <li>

阻塞</li>
    <li>

创建</li>
    <li>

就绪</li>
    <li>

PCB</li>
    <li>

控制</li>
    <li>

资源</li>
    <li>

就绪</li>
    <li>

消失</li>
    <li>

正常</li>
    <li>

退出</li>
  </ul>
</details>
</div>

### 状态转换

<ul>

> pro：引起进程状态转换的事件（2014、2015、2018、2023）

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2796d43857bddecd8eca8a18aecf8570c278e84dba5e8cfb5c23a1843cc5dc7b.jpg)

#### 基本状态间的转换

<ul>

##### 就绪态→运行态
- 被____获得____资源
- 分派____时间片

##### 运行态→就绪态
- ____片用完
- 更高____级进程就绪

##### 运行态→阻塞态
- 请求____使用
- 等待____发生

##### 阻塞态→就绪态
- 等待____到来
- ____操作完成
- ____结束

</ul>

</ul>

<div>
<details>
  <summary> </summary>
  <ul>
    <li>

调度</li>
    <li>

CPU</li>
    <li>

CPU</li>
    <li>

时间</li>
    <li>

优先</li>
    <li>

资源</li>
    <li>

事件</li>
    <li>

事件</li>
    <li>

I/O</li>
    <li>

中断</li>
  </ul>
</details>
</div>

</ul>

## 进程控制

<ul>

进程控制的主要功能是对系统中的所有进程实施有效的____，它具有创建新进程、撤销已有进程、实现进程____转换等功能。  
在操作系统中，一般将进程控制用的程序段称为____，原语的特点是执行期间不允许____，它是一个不可分割的基本单位。

### 进程的创建

<ul>

> pro：父进程与子进程的关系和特点（2020）

#### 父子进程关系
- 允许一个进程____另一个进程
  - 创建者称为____进程
  - 被创建的进程称为____进程
- 资源关系
  - 子进程可____父进程资源
  - 子进程撤销时归还资源给____进程
  - 父进程撤销时通常同时撤销所有____进程

> pro：导致创建进程的操作（2010）

#### 创建触发事件
- 终端用户____系统
- ____调度
- 系统提供____
- 用户程序的应用____

> pro：创建新进程时的操作（2021）

#### 创建过程

<ul>

##### 分配标识与PCB
- 分配唯一进程____号
- 申请空白____
  - PCB申请失败则创建____

##### 资源分配
- 分配运行所需____
  - ____
  - ____
  - ____设备
  - ____时间
- 资源来源
  - ____系统
  - ____进程
- 资源不足处理
  - 进入____态等待资源

##### PCB初始化
- 初始化____信息
- 初始化____状态信息
- 初始化____控制信息
- 设置进程____级

##### 就绪队列处理
- 检查____队列是否可接纳
- 插入____队列等待调度

</ul>

</ul>

<div>
<details>
  <summary> </summary>
  <ul>
    <li>

管理</li>
    <li>

状态</li>
    <li>

原语</li>
    <li>

中断</li>
    <li>

创建</li>
    <li>

父</li>
    <li>

子</li>
    <li>

继承</li>
    <li>

父</li>
    <li>

子</li>
    <li>

登录</li>
    <li>

作业</li>
    <li>

服务</li>
    <li>

请求</li>
    <li>

标识</li>
    <li>

PCB</li>
    <li>

失败</li>
    <li>

资源</li>
    <li>

内存</li>
    <li>

文件</li>
    <li>

I/O</li>
    <li>

CPU</li>
    <li>

操作</li>
    <li>

父</li>
    <li>

创建</li>
    <li>

标志</li>
    <li>

CPU</li>
    <li>

CPU</li>
    <li>

优先</li>
    <li>

就绪</li>
    <li>

就绪</li>
  </ul>
</details>
</div>

### 进程的终止

<ul>

#### 终止事件类型

<ul>

##### 正常结束
- 任务完成并准备____

##### 异常结束
- 存储区____
- ____错
- 非法____
- ____指令错
- 运行____
- ____运算错
- ____故障

##### 外界干预
- ____员干预
- ____系统干预
- ____进程请求
- ____进程终止

</ul>

> pro：终止进程时的操作（2024）

#### 终止过程

<ul>

##### PCB处理
- 检索进程____
- 读取进程____

##### 运行状态处理
- 终止____状态进程执行
- 分配____给其他进程

##### 子进程处理
- 终止所有____进程(系统要求不同)

##### 资源回收
- 归还资源给____进程
- 归还资源给____系统

##### 队列更新
- 从所在____删除PCB

</ul>

</ul>

<div>
<details>
  <summary> </summary>
  <ul>
    <li>

退出</li>
    <li>

越界</li>
    <li>

保护</li>
    <li>

指令</li>
    <li>

特权</li>
    <li>

超时</li>
    <li>

算术</li>
    <li>

I/O</li>
    <li>

操作</li>
    <li>

操作</li>
    <li>

父</li>
    <li>

父</li>
    <li>

PCB</li>
    <li>

状态</li>
    <li>

运行</li>
    <li>

CPU</li>
    <li>

子孙</li>
    <li>

父</li>
    <li>

操作</li>
    <li>

队列</li>
  </ul>
</details>
</div>

### 进程的阻塞和唤醒

<ul>

> pro：进程阻塞的事件与时机（2018、2022、2023）

> pro：I/O事件阻塞或唤醒进程的过程（2023）

#### 阻塞机制

<ul>

##### 阻塞原因
- 请求系统____失败
- 等待____完成
- 新____未到达
- 无新____可做

##### 阻塞特点
- 是进程的____行为
- 仅____态进程可转为阻塞态

##### 阻塞过程
- 查找进程____
- 保护____态进程现场
- 转换状态为____态
- 插入____队列
- 调度____给其他进程

</ul>

> pro：进程唤醒的事件与时机（2014、2019）

#### 唤醒机制

<ul>

##### 唤醒条件
- ____操作完成
- 所需____到达

##### 唤醒过程
- 查找____队列中的PCB
- 将进程转为____态
- 插入____队列等待调度

</ul>

#### 原语使用要求
- ____和____必须成对使用
- 必须在相关进程中安排对应____原语
- 避免进程____阻塞

</ul>

<div>
<details>
  <summary> </summary>
  <ul>
    <li>

资源</li>
    <li>

操作</li>
    <li>

数据</li>
    <li>

任务</li>
    <li>

主动</li>
    <li>

运行</li>
    <li>

PCB</li>
    <li>

运行</li>
    <li>

阻塞</li>
    <li>

等待</li>
    <li>

CPU</li>
    <li>

I/O</li>
    <li>

数据</li>
    <li>

等待</li>
    <li>

就绪</li>
    <li>

就绪</li>
    <li>

Block</li>
    <li>

Wakeup</li>
    <li>

唤醒</li>
    <li>

永久</li>
  </ul>
</details>
</div>

</ul>

## 进程的通信

<ul>

进程通信是指进程之间的____交换。PV操作（见2.3节）是____通信方式，高级通信方式是指以较高的效率传输大量数据的通信方式。高级通信方法主要有以下三类。

### 共享存储

<ul>

#### 基本概念
- 通信进程之间存在可直接访问的____空间
- 通过对共享空间进行____操作实现信息交换
- 需使用____工具控制写/读操作

#### 共享方式分类
- ____方式：基于数据结构的共享
- ____方式：基于存储区的共享

#### 系统职责
- 提供可____使用的存储空间
- 提供____工具
- 数据交换由用户自行安排____指令完成

#### 注意事项
- 进程空间通常____
- 需通过特殊____调用实现共享空间
- 进程内____自然共享进程空间

#### 简单类比
- 类似甲乙通过____交换物品
- 不能直接在双方手中交换物品

</ul>

<div>
<details>
  <summary> </summary>
  <ul>
    <li>

信息</li>
    <li>

低级</li>
    <li>

共享</li>
    <li>

写/读</li>
    <li>

同步互斥</li>
    <li>

低级</li>
    <li>

高级</li>
    <li>

共享</li>
    <li>

同步互斥</li>
    <li>

读/写</li>
    <li>

独立</li>
    <li>

系统</li>
    <li>

线程</li>
    <li>

大布袋</li>
  </ul>
</details>
</div>

### 消息传递

<ul>

#### 基本特征
- 适用于无直接____空间的进程通信
- 以____消息为数据交换单位
- 通过____和____两个原语实现

#### 应用优势
- ____通信实现细节
- 对用户____
- ____通信程序设计
- 应用广泛，特别适用于：
  - ____内核操作系统
  - ____CPU系统
  - ____系统
  - 计算机____

#### 通信方式

<ul>

##### 直接通信
- 发送进程直接将消息发送给____进程
- 消息挂在接收进程的____队列上
- 接收进程从队列中____消息

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4e378c14db3ecaf63a9189b82896c975963663cfed48df20335663062fd6dff2.jpg)

##### 简单类比
- 类似____送信
  - 直接通信：直接送到____手中
  - 间接通信：放入____邮箱

</ul>

</ul>

<div>
<details>
  <summary> </summary>
  <ul>
    <li>

共享</li>
    <li>

格式化</li>
    <li>

发送</li>
    <li>

接收</li>
    <li>

隐藏</li>
    <li>

透明</li>
    <li>

简化</li>
    <li>

微</li>
    <li>

多</li>
    <li>

分布式</li>
    <li>

网络</li>
    <li>

接收</li>
    <li>

缓冲</li>
    <li>

获取</li>
    <li>

邮递员</li>
    <li>

收件人</li>
    <li>

收件人</li>
  </ul>
</details>
</div>

### 管道通信

<ul>

> pro：管道通信的特点（2014）

#### 基本概念
- 特殊的____文件(pipe文件)
- 数据____先出
- 支持____方式通信

#### 协调能力
- ____：进程读/写操作互斥
- ____：读写进程间的同步机制
- 确定____存在

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0aa0d9d676a835dc9a42cff1fc91636ab53c2ace9cbc0f3c38960a43f226917a.jpg)  
图2.4管道通信

#### Linux中的管道特性

<ul>

##### 缓冲区管理
- 固定大小(____)缓冲区
- 写满时____等待读取
- 读空时____等待写入

##### 访问限制
- 仅____进程可访问
- 子进程____父进程管道
- 可用于____进程通信

</ul>

> attention：

#### 重要说明
- 读取为____操作
- 读取后立即____空间
- 普通管道仅支持____通信
- 双向通信需要____管道

</ul>

<div>
<details>
  <summary> </summary>
  <ul>
    <li>

共享</li>
    <li>

先进</li>
    <li>

生产者-消费者</li>
    <li>

互斥</li>
    <li>

同步</li>
    <li>

对方</li>
    <li>

4KB</li>
    <li>

阻塞</li>
    <li>

阻塞</li>
    <li>

创建</li>
    <li>

继承</li>
    <li>

父子</li>
    <li>

一次性</li>
    <li>

释放</li>
    <li>

单向</li>
    <li>

两个</li>
  </ul>
</details>
</div>

</ul>

## 线程和多线程模型

<ul>

### 线程的基本概念
- 引入线程的目的
  - 减少程序并发执行的____开销
  - 提高操作系统的____性能

- 线程的本质理解
  - ____级进程
  - 基本____执行单元
  - 程序执行流的____单元
  - 组成部分
    - 线程____
    - ____计数器
    - ____集合
    - ____

- 线程的特征
  - 是进程中的____
  - 系统独立____和____的基本单位
  - 资源共享特性
    - 自身只拥有必要的____资源
    - 可共享所属进程的____资源
  - 线程间关系
    - 可以____和____其他线程
    - 同进程内多线程可____执行
    - 存在相互____关系
  - 基本状态
    - ____
    - ____
    - ____

### 线程与进程的比较

<ul>

> pro：进程和线程的比较（2012）

#### 调度方面
- 传统操作系统
  - 进程是____基本单位
  - 每次调度需____切换
  - 开销较大
- 引入线程后
  - 线程是____基本单位
  - 切换开销低于____
  - 同进程内线程切换不引起____切换
  - 跨进程线程切换会引起____切换

#### 并发性方面
- 多层次并发
  - ____间并发
  - 同进程内____并发
  - 不同进程____并发
- 系统效益
  - 更好的____性
  - 提高____利用率
  - 提高系统____量

#### 资源拥有方面
- 进程：系统____基本单位
- 线程
  - 不拥有____资源
  - 仅有必要的____资源
  - 可访问所属进程____
  - 同进程线程共享____空间

#### 独立性方面
- 进程独立性
  - 独立____空间和资源
  - 仅共享____变量
  - 进程间线程____
- 线程协作性
  - 为提高____性而创建
  - 共享进程____空间和资源

#### 系统开销方面
- 进程开销
  - 创建/撤销需分配/回收____等资源
  - 切换涉及完整____切换
- 线程开销
  - 创建/撤销开销____
  - 切换仅需保存少量____
  - 同进程线程____简单

#### 多处理器支持方面
- 单线程进程：仅能在____运行
- 多线程进程：可分配到____执行

</ul>

<div>
<details>
  <summary> </summary>
  <ul>
    <li>

时空</li>
    <li>

并发</li>
    <li>

轻量</li>
    <li>

CPU</li>
    <li>

最小</li>
    <li>

ID</li>
    <li>

程序</li>
    <li>

寄存器</li>
    <li>

堆栈</li>
    <li>

实体</li>
    <li>

调度</li>
    <li>

分派</li>
    <li>

运行</li>
    <li>

全部</li>
    <li>

创建</li>
    <li>

撤销</li>
    <li>

并发</li>
    <li>

制约</li>
    <li>

就绪</li>
    <li>

阻塞</li>
    <li>

运行</li>
    <li>

调度</li>
    <li>

上下文</li>
    <li>

调度</li>
    <li>

进程</li>
    <li>

进程</li>
    <li>

进程</li>
    <li>

进程</li>
    <li>

线程</li>
    <li>

线程</li>
    <li>

并发</li>
    <li>

资源</li>
    <li>

吞吐</li>
    <li>

资源</li>
    <li>

系统</li>
    <li>

运行</li>
    <li>

资源</li>
    <li>

地址</li>
    <li>

地址</li>
    <li>

全局</li>
    <li>

不可见</li>
    <li>

并发</li>
    <li>

地址</li>
    <li>

PCB</li>
    <li>

上下文</li>
    <li>

小</li>
    <li>

寄存器</li>
    <li>

通信</li>
    <li>

单CPU</li>
    <li>

多CPU</li>
  </ul>
</details>
</div>

### 线程的属性

<ul>

> pro：线程所拥有资源的特点（2011、2024）

- ____实体特性
  - 不拥有____资源
  - 拥有唯一____符
  - 拥有线程____块
    - 记录执行____
    - 记录栈____状态

- 程序执行特性
  - 可执行____程序
  - 不同用户调用创建____线程

- 资源共享特性
  - 共享所属进程____

- 调度特性
  - ____独立调度单位
  - 并发执行能力
    - 单CPU：____占用
    - 多CPU：____占用

- 生命周期特性
  - 创建到____的完整周期
  - 状态变化
    - ____态
    - ____态
    - ____态

</ul>

<div>
<details>
  <summary> </summary>
  <ul>
    <li>

轻型</li>
    <li>

系统</li>
    <li>

标识</li>
    <li>

控制</li>
    <li>

寄存器</li>
    <li>

现场</li>
    <li>

相同</li>
    <li>

不同</li>
    <li>

资源</li>
    <li>

CPU</li>
    <li>

交替</li>
    <li>

同时</li>
    <li>

终止</li>
    <li>

阻塞</li>
    <li>

就绪</li>
    <li>

运行</li>
  </ul>
</details>
</div>

### 线程的状态与转换

<ul>

#### 基本状态
- ____态：获得CPU正在运行
- ____态：具备执行条件待获得CPU
- ____态：因事件受阻暂停状态

</ul>

<div>
<details>
  <summary> </summary>
  <ul>
    <li>

执行</li>
    <li>

就绪</li>
    <li>

阻塞</li>
  </ul>
</details>
</div>

### 线程的组织与控制

<ul>

#### 线程控制块

<ul>

> pro：线程的组织（2019、2024）

##### TCB组成
- 线程____符
- ____组
  - ____计数器
  - ____寄存器
  - 通用____
- 线程运行____
- ____级
- 线程专有____区
- ____指针

##### 地址空间共享
- 完全共享进程____空间
- 共享____变量
- 线程间可互相访问____

</ul>

#### 线程的创建

<ul>

##### 初始化线程
- 程序启动时____
- 主要用于创建____线程

##### 创建过程
- 使用线程____函数
- 提供必要____
  - 线程主程序____指针
  - ____大小
  - 线程____级
- 返回线程____符

</ul>

#### 线程的终止

<ul>

##### 终止情况
- 任务完成自然____
- ____情况强制终止
- 系统线程持续____

##### 资源处理
- 终止后不立即____资源
- 需其他线程执行____函数
- 分离后资源可被____
- 未分离前可被重新____运行

</ul>

</ul>

<div>
<details>
  <summary> </summary>
  <ul>
    <li>

标识</li>
    <li>

寄存器</li>
    <li>

程序</li>
    <li>

状态</li>
    <li>

寄存器</li>
    <li>

状态</li>
    <li>

优先</li>
    <li>

存储</li>
    <li>

堆栈</li>
    <li>

地址</li>
    <li>

全局</li>
    <li>

堆栈</li>
    <li>

创建</li>
    <li>

新</li>
    <li>

创建</li>
    <li>

参数</li>
    <li>

入口</li>
    <li>

堆栈</li>
    <li>

优先</li>
    <li>

标识</li>
    <li>

终止</li>
    <li>

异常</li>
    <li>

运行</li>
    <li>

释放</li>
    <li>

分离</li>
    <li>

利用</li>
    <li>

恢复</li>
  </ul>
</details>
</div>

### 线程的实现方式

<ul>

> pro: 两种线程的特点与比较（2019）

#### 线程实现的基本类型

<ul>

##### 用户级线程（ULT）
- 通俗定义：从用户视角能看到的____
- 管理特点：
  - 所有线程管理工作在____空间完成
  - 无需____系统干预
  - 内核不感知____存在
- 实现方式：
  - 通过____库设计多线程程序
  - 从____线程开始运行
  - 可通过线程库派生例程创建____线程

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/53a12e70cc68896b3ad08729bf6efe7fb0936d9f8fc50ad5a1dfe89b5862053c.jpg)  
图2.5用户级线程和内核级线程

- 调度特点：
  - 以____为单位进行调度
  - 可能导致线程间运行时间不____
- 优点：
  - 线程切换无需转换到____空间
  - 调度算法可进程____
  - 实现与____系统平台无关
- 缺点：
  - 系统调用会导致所有____阻塞
  - 无法充分利用____优势

##### 内核级线程（KLT）
- 基本特征：
  - 在____支持下运行
  - 线程管理在____空间实现
  - 每个线程有独立____
- 优点：
  - 可充分利用____
  - 线程____不影响其他线程
  - 切换开销____
  - 可提高系统执行____
- 缺点：
  - 线程切换需要____转换，开销较大

##### 组合方式
- 实现特点：
  - 同时支持____级和____级线程
  - ____级线程对应多个____级线程
  - 通过____复用方式实现
- 优势：
  - 结合____和____优点
  - 克服各自____
  - 支持____并行执行

</ul>

#### 线程库实现方法
- 用户空间库：
  - 无____支持
  - 代码和数据结构在____空间
  - 仅涉及____函数调用
- 内核级库：
  - ____系统直接支持
  - 代码和数据结构在____空间
  - 涉及____调用
- 常见线程库：
  - ____ Pthreads
  - ____ API
  - ____线程API

#### 多线程模型

<ul>

##### 多对一模型
- 映射关系：多个____级线程映射到一个____级线程
- 特点：
  - 每进程只分配一个____级线程
  - 线程管理在____空间完成
- 优点：
  - 线程管理____高
- 缺点：
  - 一个线程____导致整个进程阻塞
  - 无法利用____

##### 一对一模型
- 映射关系：每个____级线程映射到一个____级线程
- 特点：
  - 内核线程数量等于____线程
  - 线程切换由____完成
- 优点：
  - ____能力强
- 缺点：
  - 创建____大

##### 多对多模型
- 映射关系：n个____级线程映射到m个____级线程(n≥m)
- 特点：
  - 克服____模型并发度不高的缺点
  - 避免____模型开销大的问题
  - 保留两种模型的____

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b86efe1592c3ce83305d75f921bd586fa96327898e677be35ee886df29c5ce3f.jpg)  
图2.6多线程模型

</ul>

</ul>

<div>
<details>
  <summary> </summary>
  <ul>
    <li>

线程</li>
    <li>

用户</li>
    <li>

操作</li>
    <li>

线程</li>
    <li>

线程</li>
    <li>

单</li>
    <li>

新</li>
    <li>

进程</li>
    <li>

公平</li>
    <li>

内核</li>
    <li>

专用</li>
    <li>

操作</li>
    <li>

线程</li>
    <li>

多CPU</li>
    <li>

内核</li>
    <li>

内核</li>
    <li>

TCB</li>
    <li>

多CPU</li>
    <li>

阻塞</li>
    <li>

小</li>
    <li>

效率</li>
    <li>

模式</li>
    <li>

内核</li>
    <li>

用户</li>
    <li>

内核</li>
    <li>

用户</li>
    <li>

时分</li>
    <li>

KLT</li>
    <li>

ULT</li>
    <li>

不足</li>
    <li>

多CPU</li>
    <li>

内核</li>
    <li>

用户</li>
    <li>

本地</li>
    <li>

操作</li>
    <li>

内核</li>
    <li>

系统</li>
    <li>

POSIX</li>
    <li>

Windows</li>
    <li>

Java</li>
    <li>

用户</li>
    <li>

内核</li>
    <li>

内核</li>
    <li>

用户</li>
    <li>

效率</li>
    <li>

阻塞</li>
    <li>

多CPU</li>
    <li>

用户</li>
    <li>

内核</li>
    <li>

用户</li>
    <li>

内核</li>
    <li>

并发</li>
    <li>

开销</li>
    <li>

用户</li>
    <li>

内核</li>
    <li>

多对一</li>
    <li>

一对一</li>
    <li>

优点</li>
  </ul>
</details>
</div>

</ul>

## 本节小结

<ul>

本节开头提出的问题的参考答案如下。

### 1）为什么要引入进程？

<ul>

在多道程序设计的背景下，进程之间需要____系统资源，因此会导致各程序在执行过程中出现相互____的关系，程序的执行会表现出____性等特征。这些特征都是在程序的执行过程中发生的，是____的过程，而传统的程序本身是一组____的集合，是____的概念，无法描述程序在内存中的执行情况，即无法从程序的字面上看出它何时执行、何时停顿，也无法看出它与其他执行程序的关系，因此，程序这个静态概念已不能如实反映程序____执行过程的特征。为了深刻描述程序____执行过程的性质乃至更好地支持和管理多道程序的____执行，便引入了进程的概念。

</ul>

<div>
<details>
  <summary> </summary>
  <ul>
    <li>

共享</li>
    <li>

制约</li>
    <li>

间断</li>
    <li>

动态</li>
    <li>

指令</li>
    <li>

静态</li>
    <li>

并发</li>
    <li>

动态</li>
    <li>

并发</li>
  </ul>
</details>
</div>

### 2）什么是进程？进程由什么组成？

<ul>

进程是一个具有____功能的程序关于某个数据集合的一次运行活动。它可以申请和拥有____资源，是一个____的概念，是一个活动的____。它不只是程序的代码本身，还包括当前的活动，通过____计数器的值和处理____的内容来表示。

一个进程实体由____段、相关____段和____三部分构成，其中____是标志一个进程存在的唯一标识，____段是进程运行的程序的代码，____段则存储程序运行过程中相关的一些数据。

</ul>

<div>
<details>
  <summary> </summary>
  <ul>
    <li>

独立</li>
    <li>

系统</li>
    <li>

动态</li>
    <li>

实体</li>
    <li>

程序</li>
    <li>

寄存器</li>
    <li>

程序</li>
    <li>

数据</li>
    <li>

PCB</li>
    <li>

PCB</li>
    <li>

程序</li>
    <li>

数据</li>
  </ul>
</details>
</div>

### 3）进程是如何解决问题的？

<ul>

进程将能够识别程序运行状态的一些____存放在____中，通过这些变量系统能够更好地了解进程的状况，并在适当时机进行进程的____，以避免一些资源的浪费，甚至划分为更小的____单位一一____来提高系统的____度。

本节主要介绍什么是进程，并围绕这个问题进行一些阐述和讨论，为下一节讨论的内容做铺垫，但之前未学过相关课程的读者可能会比较费解，到现在为止对进程这个概念还未形成比较清晰的认识。接下来，我们再用一个比较熟悉的概念来类比进程，以便大家能彻底理解本节的内容到底在讲什么，到底解决了什么问题。

我们用“人的生命历程”来类比进程。首先，人的生命历程一定是一个____的、过程性的概念，要研究人的生命历程，先要介绍经历这个历程的主体是什么。主体当然是____，相当于经历进程的主体是____映像，人有自己的身份，相当于进程映像里有____；人生历程会经历好几种状态：出生的时候、弥留的时候、充满斗志的时候、发奋图强的时候及失落的时候，相当于进程有____、____、____、____、____等状态，这几种状态会发生改变，人会充满斗志而转向发奋图强，发奋图强获得进步之后又会充满斗志预备下一次发奋图强，或者发奋图强后遇到阻碍会进入失落状态，然后在别人的开导之下又重新充满斗志。类比进程，会由____态转向____态，____态转向____态，或者____态转向____态，然后在别的进程帮助下返回____态。若我们用“人生历程”这个过程的概念去类比进程，则对进程的理解就更深一层。前面生活化的例子可以帮我们理解进程的实质，但它毕竟有不严谨的地方。一种较好的方式是，在类比进程和人生历程后，再看一遍前面较为严谨的书面阐述和讨论，这样对知识的掌握会更加准确而全面。

这里再给出一些学习计算机科学知识的建议。学习时，很多同学会陷入一个误区，即只注重对____、____的应用，而忽视对____概念的理解。这是我们从小到大应付考试而培养出的一个毛病，因为熟练应用公式和定理对考试有立竿见影的效果。公式、定理的应用固然重要，但基础概念的理解能让我们透彻地理解一门学科，更利于我们产生兴趣，培养____性思维。

</ul>

<div>
<details>
  <summary> </summary>
  <ul>
    <li>

变量</li>
    <li>

PCB</li>
    <li>

切换</li>
    <li>

调度</li>
    <li>

线程</li>
    <li>

并发</li>
    <li>

动态</li>
    <li>

人</li>
    <li>

进程</li>
    <li>

PCB</li>
    <li>

创建</li>
    <li>

撤销</li>
    <li>

就绪</li>
    <li>

运行</li>
    <li>

阻塞</li>
    <li>

就绪</li>
    <li>

运行</li>
    <li>

运行</li>
    <li>

就绪</li>
    <li>

运行</li>
    <li>

阻塞</li>
    <li>

就绪</li>
    <li>

定理</li>
    <li>

公式</li>
    <li>

基础</li>
    <li>

创造</li>
  </ul>
</details>
</div>

</ul>

</ul>

# CPU调度

<ul>

在学习本节时，请读者思考以下问题

1）为什么要进行CPU调度？  
2）调度算法有哪几种？结合第1章学习的分时操作系统和实时操作系统，思考哪种调度算法比较适合这两种操作系统。  

希望读者能够在学习调度算法前，先自己思考一些调度算法，在学习的过程中注意将自己的想法与这些经典的算法进行比对，并学会计算一些调度算法的____时间。

## 调度的概念

<ul>

### 调度的基本概念
- 在多道程序系统中，进程的数量往往多于____的个数，因此进程争用CPU的情况在所难免
- CPU调度是对____进行分配，即从____队列中按照一定的____（公平、高效的原则）选择一个进程并将CPU分配给它运行，以实现进程____地执行
- CPU调度是多道程序操作系统的____，是操作系统设计的核心问题

### 调度的层次

<ul>

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7f02ae01d0a171c46a1a035b0848db7cb0ff1cf0d5d243f56b408c781bf2bcb8.jpg)  
图2.7CPU的三级调度

#### 高级调度（作业调度）
- 主要功能：
  - 从外存上处于____队列的作业中挑选作业
  - 分配____、____设备等必要资源
  - 建立相应进程使其获得竞争____权利
- 特点：
  - 本质是____与辅存之间的调度
  - 每个作业只调入____、调出____
  - 多道批处理系统中配有作业调度，其他系统通常不需要

#### 中级调度（内存调度）
- 目的：
  - 提高____利用率和系统____量
- 工作机制：
  - 将暂时不能运行的进程调至____等待（进入____态）
  - 当具备运行条件且内存有空闲时重新调入____
  - 修改状态为____态，进入____队列等待
- 本质：是存储器管理中的____功能

#### 低级调度（进程调度）
- 基本功能：
  - 按照____从就绪队列中选取进程
  - 将____分配给选中的进程
- 特点：
  - 是最基本的____，各种操作系统必须配置
  - 调度频率很高，一般几十毫秒一次

#### 三级调度的联系
- 工作流程关系：
  - ____调度选择作业进入内存并建立进程
  - 这些进程进入____队列
  - ____调度从就绪队列选择进程运行
  - ____调度负责进程的挂起管理
- 主要特点：
  - 作业调度为进程活动做准备，进程调度使进程正常活动
  - 中级调度位于____调度和____调度之间
  - 调度频率：____调度最少，中级调度略多，进程调度最高
  - 进程调度最基本且不可或缺

</ul>

</ul>

<div>
<details>
  <summary> </summary>
  <ul>
    <li>

周转</li>
    <li>

CPU</li>
    <li>

CPU</li>
    <li>

就绪</li>
    <li>

算法</li>
    <li>

并发</li>
    <li>

基础</li>
    <li>

后备</li>
    <li>

内存</li>
    <li>

I/O</li>
    <li>

CPU</li>
    <li>

内存</li>
    <li>

一次</li>
    <li>

一次</li>
    <li>

内存</li>
    <li>

吞吐</li>
    <li>

外存</li>
    <li>

挂起</li>
    <li>

内存</li>
    <li>

就绪</li>
    <li>

就绪</li>
    <li>

对换</li>
    <li>

算法</li>
    <li>

CPU</li>
    <li>

调度</li>
    <li>

作业</li>
    <li>

就绪</li>
    <li>

进程</li>
    <li>

中级</li>
    <li>

作业</li>
    <li>

进程</li>
    <li>

作业</li>
  </ul>
</details>
</div>

## 调度的实现

<ul>

### 调度程序（调度器）

<ul>

#### 调度程序的组成部分

<ul>

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/dfa12b23fc0749597359e6144d67fec5ae58c52eea70cfd649d23e9485a3b0e5.jpg)  
图2.8调度程序的结构

- ____器
  - 将系统中的所有就绪进程按照一定的____排成一个或多个队列
  - 每当有进程转为____态时，将其插入相应就绪队列

- ____器
  - 依据调度程序所选的进程，将其从____队列中取出
  - 将____分配给新进程

- 上下文____器
  - 执行两对上下文切换操作：
    - 第一对：保存当前进程上下文到____，装入分派程序上下文
    - 第二对：移出分派程序上下文，装入新进程____现场信息
  - 优化方法：
    - 采用两组____(内核组和用户组)
    - 通过改变____指向来减少切换时间

</ul>

</ul>

<div>
<details>
  <summary> </summary>
  <ul>
    <li>

排队</li>
    <li>

策略</li>
    <li>

就绪</li>
    <li>

分派</li>
    <li>

就绪</li>
    <li>

CPU</li>
    <li>

切换</li>
    <li>

PCB</li>
    <li>

CPU</li>
    <li>

寄存器</li>
    <li>

指针</li>
  </ul>
</details>
</div>

### 调度的时机、切换与过程

<ul>

#### 调度时机

<ul>

> pro：可以进行CPU调度的事件或时机（2012、2021）

- 可以进行调度的情况：
  - 创建____进程后
  - 进程____或异常终止后
  - 进程被____时
  - ____设备完成时
  - 更高____级进程就绪时
  - 当前进程____片用完时

</ul>

#### 进程切换过程
- 保存原进程____信息
- 恢复被调度进程____
- 切换步骤：
  - 将原进程信息推入____堆栈
  - 更新____指针
  - 装入新进程____信息
  - 更新进程____指针
  - 重设____寄存器

#### 不可调度情况
- ____处理过程中
- ____操作过程中：
  - ____、____操作
  - 中断____保护
  - ____等原子操作

</ul>

<div>
<details>
  <summary> </summary>
  <ul>
    <li>

新</li>
    <li>

结束</li>
    <li>

阻塞</li>
    <li>

I/O</li>
    <li>

优先</li>
    <li>

时间</li>
    <li>

现场</li>
    <li>

现场</li>
    <li>

内核</li>
    <li>

堆栈</li>
    <li>

现场</li>
    <li>

空间</li>
    <li>

PC</li>
    <li>

中断</li>
    <li>

原子</li>
    <li>

加锁</li>
    <li>

解锁</li>
    <li>

现场</li>
    <li>

恢复</li>
  </ul>
</details>
</div>

### 进程调度的方式

<ul>

#### 非抢占调度方式
- 特点：
  - 正在执行的进程继续执行直至____或____
  - 实现____，系统开销小
  - 适用于早期____系统
  - 不适用于____系统和____系统

#### 抢占调度方式
- 特点：
  - 允许暂停当前____
  - 将____分配给更重要进程
  - 提高系统____率和____效率
- 抢占原则：
  - ____权原则
  - ____进程优先原则
  - ____片原则

</ul>

<div>
<details>
  <summary> </summary>
  <ul>
    <li>

完成</li>
    <li>

阻塞</li>
    <li>

简单</li>
    <li>

批处理</li>
    <li>

分时</li>
    <li>

实时</li>
    <li>

进程</li>
    <li>

CPU</li>
    <li>

吞吐</li>
    <li>

响应</li>
    <li>

优先</li>
    <li>

短</li>
    <li>

时间</li>
  </ul>
</details>
</div>

### 闲连进程

<ul>

#### 闲逛进程的特点
- 在进程切换时，如果系统中没有____进程，就会调度____进程（IdleProcess）运行
  - PID为____
  - 如果没有其他进程就绪，该进程就一直____
  - 并在指令周期后测试____
- 优先级特征
  - 优先级____
  - 没有就绪进程时才会运行
  - 只要有进程就绪，就会立即让出____
- 资源需求
  - 不需要____之外的资源
  - 不会被____

</ul>

<div>
<details>
  <summary> </summary>
  <ul>
    <li>

就绪</li>
    <li>

闲逛</li>
    <li>

0</li>
    <li>

运行</li>
    <li>

中断</li>
    <li>

最低</li>
    <li>

CPU</li>
    <li>

CPU</li>
    <li>

阻塞</li>
  </ul>
</details>
</div>

### 两种线程的调度

<ul>

#### 用户级线程调度
- ____不知道线程存在
- ____选择进程并给予时间控制
- 由进程中的____程序决定线程运行

#### 内核级线程调度
- ____直接选择特定线程运行
- 通常不考虑线程所属____
- 对被选择线程赋予____片
- 超过时间片会强制____

#### 线程切换比较
- 用户级线程切换
  - 在同一____中进行
  - 仅需少量____指令
- 内核级线程切换
  - 需要完整____切换
  - 需要修改____映像
  - 使高速____失效
  - 导致较大____

</ul>

<div>
<details>
  <summary> </summary>
  <ul>
    <li>

内核</li>
    <li>

内核</li>
    <li>

调度</li>
    <li>

内核</li>
    <li>

进程</li>
    <li>

时间</li>
    <li>

挂起</li>
    <li>

进程</li>
    <li>

机器</li>
    <li>

上下文</li>
    <li>

内存</li>
    <li>

缓存</li>
    <li>

延迟</li>
  </ul>
</details>
</div>

### 调度的目标

<ul>

#### CPU利用率
- CPU是重要昂贵____
- 应保持"____"状态以最大化利用率
- 计算方法：
  - CPU利用率 = CPU有效工作时间/(CPU有效工作时间+CPU____等待时间)

> attention：

计算作业完成时间时，要注意____与设备、设备与设备之间是可以____的。

#### 系统吞吐量
- 含义：单位时间内____完成作业数量
- 影响因素
  - 长作业消耗较长____时间，降低吞吐量
  - 短作业消耗较短____时间，提高吞吐量
  - ____算法和方式会影响系统吞吐量

#### 周转时间
- 定义：从作业提交到____的时间总和
- 组成部分
  - 作业____时间
  - ____队列排队时间
  - ____运行时间
  - ____操作时间
- 计算方法
  - 周转时间 = 作业完成时间-作业____时间
  - 平均周转时间 = (作业1的周转时间+..+作业n的周转时间)/____
  - 带权周转时间 = 作业周转时间/作业实际____时间
  - 平均带权周转时间 = (作业1的带权周转时间+...+作业n的带权周转时间)/____

#### 等待时间
- 定义：进程等待____的时间总和
- 特点
  - 等待时间越长，用户____度越低
  - CPU调度算法不影响作业____或____操作时间
  - 只影响____队列等待时间
- 作用：常用于简单评价____算法优劣

#### 响应时间
- 定义：从用户提交____到系统首次____的时间
- 应用场景
  - ____系统中重要评价准则
  - 比周转时间更适合作为____标准
- 优化目标
  - 尽量降低____时间
  - 使响应时间在用户____范围内

#### 调度程序设计考虑因素
- 用户____
  - 满足特定系统用户要求
  - 如____和____进程的快速响应
- 系统____
  - 考虑系统整体效率
  - 减少进程平均____时间
- 算法____
  - 需权衡调度算法的实现成本

</ul>

</ul>

<div>
<details>
  <summary> </summary>
  <ul>
    <li>

资源</li>
    <li>

忙</li>
    <li>

空闲</li>
    <li>

CPU</li>
    <li>

并行</li>
    <li>

CPU</li>
    <li>

CPU</li>
    <li>

CPU</li>
    <li>

调度</li>
    <li>

完成</li>
    <li>

等待</li>
    <li>

就绪</li>
    <li>

CPU</li>
    <li>

I/O</li>
    <li>

提交</li>
    <li>

n</li>
    <li>

运行</li>
    <li>

n</li>
    <li>

CPU</li>
    <li>

满意</li>
    <li>

执行</li>
    <li>

I/O</li>
    <li>

就绪</li>
    <li>

调度</li>
    <li>

请求</li>
    <li>

响应</li>
    <li>

交互式</li>
    <li>

评价</li>
    <li>

响应</li>
    <li>

可接受</li>
    <li>

需求</li>
    <li>

实时</li>
    <li>

交互</li>
    <li>

效率</li>
    <li>

周转</li>
    <li>

开销</li>
  </ul>
</details>
</div>

## 进程切换

<ul>

> pro：进程调度前后CPU模式的变化（2023）

### 进程与内核关系
- 进程的基本操作需要通过____调用进入内核完成：
  - 进程____
  - 进程____
  - ____操作请求
- 进程切换在____支持下实现
- 所有进程都在操作系统____支持下运行

### 上下文切换

<ul>

> pro：切换进程时的操作（2024）

#### 上下文切换定义与内容
- 切换CPU到另一个进程需要：
  - 保存当前进程____
  - 恢复另一个进程____
- 进程上下文采用____表示，包含：
  - ____寄存器值
  - 进程____
  - ____管理信息

#### 上下文切换流程
1. ____进程
   - 将CPU上下文保存到____
   - 包括____计数器和其他寄存器
2. PCB队列调整
   - 将进程PCB移入相应____
   - 如____队列、____队列等
3. 新进程____
   - 选择另一进程执行
   - 更新其____
4. 上下文____
   - 恢复新进程的____上下文
5. 程序____
   - 跳转到新进程PCB中____计数器指向的位置

#### 上下文切换开销
- ____密集型操作
- 消耗大量____时间
- 每次切换需要____量级时间
- 优化方案：
  - 某些CPU提供多个____组
  - 通过改变____组指针简化切换

#### 上下文切换与模式切换的区别
- 模式切换特点：
  - CPU可能仍执行同一____
  - 在____态和____态间切换
  - 不改变当前____
- 上下文切换特点：
  - 只能在____态发生
  - 是____系统必需特性

</ul>

> attention：

调度和切换的区别：调度是指决定资源分配给哪个进程的____，是一种____行为；切换是指实际分配的____，是____行为。一般来说，先有资源的调度，然后才有进程的切换。

</ul>

<div>
<details>
  <summary> </summary>
  <ul>
    <li>

系统</li>
    <li>

创建</li>
    <li>

撤销</li>
    <li>

I/O</li>
    <li>

内核</li>
    <li>

内核</li>
    <li>

状态</li>
    <li>

状态</li>
    <li>

PCB</li>
    <li>

CPU</li>
    <li>

状态</li>
    <li>

内存</li>
    <li>

挂起</li>
    <li>

PCB</li>
    <li>

程序</li>
    <li>

队列</li>
    <li>

就绪</li>
    <li>

阻塞</li>
    <li>

选择</li>
    <li>

PCB</li>
    <li>

恢复</li>
    <li>

CPU</li>
    <li>

执行</li>
    <li>

程序</li>
    <li>

计算</li>
    <li>

CPU</li>
    <li>

纳秒</li>
    <li>

寄存器</li>
    <li>

寄存器</li>
    <li>

进程</li>
    <li>

用户</li>
    <li>

内核</li>
    <li>

进程</li>
    <li>

内核</li>
    <li>

多任务</li>
    <li>

行为</li>
    <li>

决策</li>
    <li>

行为</li>
    <li>

执行</li>
  </ul>
</details>
</div>

## 典型的调度算法

<ul>

> pro：各种调度算法的特点与对比（2009、2011、2014）

操作系统中存在多种调度算法，有的调度算法适用于____调度，有的调度算法适用于____调度，有的调度算法两者都适用。下面介绍几种常用的调度算法。

### 先来先服务（FCFS）调度算法

<ul>

> pro：FIFO调度算法的思想（2017）

#### 基本原理
- 作业调度应用
  - 从后备作业队列选择最先进入的____
  - 调入____并分配资源
  - 创建进程并放入____队列
- 进程调度应用
  - 从就绪队列选择最先进入的____
  - 分配____使其运行
  - 直到____或____才释放CPU

#### 性能分析示例

<ul>

> pro：批处理系统中作业完成时间的分析（2012、2016）

- 实例参数
  - 4个作业的提交时间：8,8.4,8.8,9
  - 运行时间：2,1,0.5,0.2
- 性能指标计算
  ![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/71bce0079791dd4ca8962d3658de3c744a6b1040134b154650e16bc9cb314fbc.jpg)
  - 平均等待时间：____
  - 平均周转时间：____
  - 平均带权周转时间：____

</ul>

#### 算法特点
- 优点
  - 算法____
  - 对所有作业____
  - 适合作为其他调度策略的____
- 缺点
  - ____低
  - 不利于____作业
  - 不利于____繁忙型作业
  - 不适合____系统和____系统

</ul>

<div>
<details>
  <summary> </summary>
  <ul>
    <li>

作业</li>
    <li>

进程</li>
    <li>

作业</li>
    <li>

内存</li>
    <li>

就绪</li>
    <li>

进程</li>
    <li>

CPU</li>
    <li>

完成</li>
    <li>

阻塞</li>
    <li>

(0+1.6+2.2+2.5)/4=1.575</li>
    <li>

(2+2.6+2.7+2.7)/4=2.5</li>
    <li>

(1+2.6+5.4+13.5)/4=5.625</li>
    <li>

简单</li>
    <li>

公平</li>
    <li>

补充</li>
    <li>

效率</li>
    <li>

短</li>
    <li>

I/O</li>
    <li>

分时</li>
    <li>

实时</li>
  </ul>
</details>
</div>

### 短作业优先（SJF）调度算法

<ul>

> pro：SJF调度算法的思想（2017）

#### 基本原理
- 短作业优先(SJF)
  - 从后备队列选择估计运行时间最短的____
  - 调入____运行
- 短进程优先(SPF)
  - 从就绪队列选择估计运行时间最短的____
  - 分配____执行
  - ____或____时释放CPU

#### 性能分析示例
- 实例数据分析
  ![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3e627e4443655f02ad8e96b1151a083196d164b190b937102d743f45c4f90bb1.jpg)
  - 平均等待时间：____
  - 平均周转时间：____
  - 平均带权周转时间：____

#### 算法缺点
- 对____作业不利
  - 长作业____时间增加
  - 可能产生"____"现象
- 未考虑作业____程度
- 依赖用户提供的____时间
  - 可能不____
  - 用户可能故意缩短____时间

#### 算法变体
- 抢占式SPF
  - 也称最短____时间优先
  - 新进程到达时比较____时间
  - 可能暂停当前____

> attention：

短作业（SJF）调度算法的平均等待时间、平均周转时间是最____的。

</ul>

<div>
<details>
  <summary> </summary>
  <ul>
    <li>

作业</li>
    <li>

内存</li>
    <li>

进程</li>
    <li>

CPU</li>
    <li>

完成</li>
    <li>

阻塞</li>
    <li>

(0+2.3+1.4+1)/4=1.175</li>
    <li>

(2+3.3+1.9+1.2)/4=2.1</li>
    <li>

(1+3.3+3.8+6)/4=3.525</li>
    <li>

长</li>
    <li>

周转</li>
    <li>

饥饿</li>
    <li>

紧迫</li>
    <li>

估计</li>
    <li>

准确</li>
    <li>

估计</li>
    <li>

剩余</li>
    <li>

剩余</li>
    <li>

进程</li>
    <li>

优</li>
  </ul>
</details>
</div>

### 高响应比优先调度算法

<ul>

#### 基本特征
- 主要用于____调度
- 综合平衡____和____算法
- 考虑因素
  - 作业____时间
  - 估计____时间

#### 响应比计算
- 计算公式
  - 响应比 = (____时间+要求服务时间)/要求服务时间
- 响应比特点
  - 等待时间相同时，服务时间短的响应比____
  - 服务时间相同时，等待时间长的响应比____
  - 长作业可通过等待时间增加提高____比

</ul>

<div>
<details>
  <summary> </summary>
  <ul>
    <li>

作业</li>
    <li>

FCFS</li>
    <li>

SJF</li>
    <li>

等待</li>
    <li>

运行</li>
    <li>

等待</li>
    <li>

高</li>
    <li>

高</li>
    <li>

响应</li>
  </ul>
</details>
</div>

### 优先级调度算法

<ul>

#### 基本特征
- 适用范围
  - 可用于____调度
  - 可用于____调度
- 优先级含义
  - 用于描述作业的____程度

#### 调度方式
- 作业调度
  - 从后备队列选择____最高的作业
  - 调入____并创建进程
- 进程调度
  - 从就绪队列选择____最高的进程
  - 分配____执行

#### 调度类型

<ul>

> pro：非抢占式优先级调度算法的应用分析（2018）

##### 非抢占式优先级调度
- 运行进程不被____
- 直到进程主动让出____才调度新进程

> pro：抢占式优先级调度算法的应用分析（2022、2023）

##### 抢占式优先级调度
- 高优先级进程可____运行进程
- 立即暂停当前进程并____新进程

</ul>

#### 优先级类型

<ul>

> pro：静态优先级和动态优先级的分析（2016）

##### 静态优先级
- 特点
  - 创建时____
  - 运行期间____
- 依据
  - 进程____
  - ____要求
  - 用户____
- 优缺点
  - 优点：____，开销小
  - 缺点：不够____，可能饿死

> pro：调整进程优先级的合理时机（2010）

##### 动态优先级
- 特点
  - 初始优先级____
  - 随时间动态____
- 调整机制
  - 等待时间增加提高____
  - 确保低优先级进程最终获得____

</ul>

#### 优先级设置原则
- ____进程 > ____进程
  - 系统进程作为管理者优先级更高

- ____型 > ____型
  - 前台进程优先于后台进程
  - 保证用户交互响应速度

> pro：进程优先级的设置：I/O型和计算型（2013）

- ____型 > ____型
  - I/O设备速度慢于CPU
  - 提前启动I/O提升系统____

</ul>

<div>
<details>
  <summary> </summary>
  <ul>
    <li>

作业</li>
    <li>

进程</li>
    <li>

紧迫</li>
    <li>

优先级</li>
    <li>

内存</li>
    <li>

优先级</li>
    <li>

CPU</li>
    <li>

打断</li>
    <li>

CPU</li>
    <li>

抢占</li>
    <li>

调度</li>
    <li>

确定</li>
    <li>

不变</li>
    <li>

类型</li>
    <li>

资源</li>
    <li>

要求</li>
    <li>

简单</li>
    <li>

精确</li>
    <li>

可变</li>
    <li>

调整</li>
    <li>

优先级</li>
    <li>

CPU</li>
    <li>

系统</li>
    <li>

用户</li>
    <li>

交互</li>
    <li>

非交互</li>
    <li>

I/O</li>
    <li>

计算</li>
    <li>

效率</li>
  </ul>
</details>
</div>

### 时间片轮转（RR）调度算法

<ul>

> pro: 时间片轮转调度算法的原理（2021、2024）

#### 基本原理
- 适用于____系统
- 运行机制
  - 就绪进程____排队
  - 定时产生____中断
  - 每个进程执行一个____片
  - 时间片用完进程返回____

#### 调度触发
- 时间片未完成时
  - 进程____立即调度
- 时间片用完时
  - ____中断触发调度

> pro：时间片轮转调度算法的特点（2017）

#### 时间片设置
- 影响因素
  - 系统____时间
  - 就绪队列____数
  - 系统____能力
- 大小选择
  - 过大退化为____
  - 过小增加____开销

</ul>

<div>
<details>
  <summary> </summary>
  <ul>
    <li>

分时</li>
    <li>

FCFS</li>
    <li>

时钟</li>
    <li>

时间</li>
    <li>

队尾</li>
    <li>

完成</li>
    <li>

时钟</li>
    <li>

响应</li>
    <li>

进程</li>
    <li>

处理</li>
    <li>

FCFS</li>
    <li>

切换</li>
  </ul>
</details>
</div>

### 多级队列调度算法

<ul>

#### 基本特征
- 设置多个____队列
- 不同类型进程分配到不同____
- 每个队列可用不同____算法

#### 实现机制
- 队列____设置
  - 同队列内进程可设不同____
  - 不同队列间可设____
- 多CPU系统支持
  - 每CPU可设独立____队列
  - 可实施不同____策略

</ul>

<div>
<details>
  <summary> </summary>
  <ul>
    <li>

就绪</li>
    <li>

队列</li>
    <li>

调度</li>
    <li>

优先级</li>
    <li>

优先级</li>
    <li>

优先级</li>
    <li>

就绪</li>
    <li>

调度</li>
  </ul>
</details>
</div>

### 多级反馈队列调度算法

<ul>

> pro：多级反馈队列调度算法的应用分析（2019）

#### 算法特点
- 融合多种算法优点
  - ____片轮转
  - ____调度
- 动态调整机制
  - 调整进程____
  - 调整____片大小

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3023703bf0e3b363dc5e01064053932a2178825f747e4c88ea109ba1efb82934.jpg)

> pro：多级反馈队列调度算法的实现思想（2020）

#### 实现思想
- 队列设置
  - 多级____队列
  - 优先级逐级____
  - 时间片逐级____
- 进程调度
  - 新进程进入____级队列
  - 时间片用完____
  - 最低级采用____方式
- 优先级处理
  - 高优先级队列优先____
  - 高优先级进程可____低优先级

#### 算法优势
- 用户类型适应
  - 终端型：____作业优先
  - 短批处理：较短____时间
  - 长批处理：避免____

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3f58ae6aca33d8e74ff64d9d67034421710e0d3eb7e9b23e14633164897d2541.jpg)

</ul>

</ul>

<div>
<details>
  <summary> </summary>
  <ul>
    <li>

时间</li>
    <li>

优先级</li>
    <li>

优先级

以下是按照要求对提供的 Markdown 文档进行挖空处理后的结果，挖空的关键词、公式定理和关键步骤以空缺形式呈现，并在每个次级标题下使用 HTML 折叠块列出答案。内容保持原有结构完整，Markdown 和 HTML 格式结合输出。

---

# 数据结构相关知识点（挖空处理）

### 进程间关系

<ul>

#### 同步关系
- 定义：____制约关系
- 特点：
  - 涉及两个或多个进程间的____
  - 为完成特定任务而建立
  - 包含____和____
- 示例：
  - 输入进程A和进程B通过____交互
  - 缓冲区空时B____，A输入后B____
  - 缓冲区满时A____，B取走数据后A____

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>直接</li>
    <li>协调</li>
    <li>等待</li>
    <li>信息传递</li>
    <li>单缓冲区</li>
    <li>阻塞</li>
    <li>唤醒</li>
    <li>阻塞</li>
    <li>唤醒</li>
  </ul>
</details>
</div>
</ul>

#### 互斥关系
- 定义：____制约关系
- 特点：
  - 一个进程使用____时其他进程等待
  - 使用完毕后其他进程才能____
- 示例：
  - 系统单一打印机被进程B____
  - 进程A需要打印时必须____
  - B释放后A被____转为____

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>间接</li>
    <li>临界资源</li>
    <li>访问</li>
    <li>占用</li>
    <li>阻塞等待</li>
    <li>唤醒</li>
    <li>就绪态</li>
  </ul>
</details>
</div>
</ul>

#### 临界区互斥准则

<ul>

> pro：实现临界区互斥必须遵循的准则（2020）

- ____：临界区空闲时允许请求进程立即进入
- ____：有进程在临界区时其他进程必须等待
- ____：保证请求进程能在有限时间内进入
- ____：
  - 不能进入时应立即____
  - 防止进程____
  - 原则上应遵循但____

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>空闲让进</li>
    <li>忙则等待</li>
    <li>有限等待</li>
    <li>让权等待</li>
    <li>释放处理器</li>
    <li>忙等待</li>
    <li>非必须</li>
  </ul>
</details>
</div>
</ul>

</ul>

</ul>

## 实现临界区互斥的基本方法

<ul>

> pro：实现互斥的软/硬件方法的特点（2018）

### 软件实现方法
- 基本思路：
  - 在____设置并检查标志来标明是否有进程在临界区中
  - 若已有进程在临界区，则在____通过循环检查进行等待
  - 进程离开临界区后则在____修改标志

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>进入区</li>
    <li>进入区</li>
    <li>退出区</li>
  </ul>
</details>
</div>
</ul>

#### 单标志法
- 算法设计：
  - 设置公用整型变量____指示允许进入临界区的进程编号
    - turn=0：允许____进入临界区
    - turn=1：允许____进入临界区
  - 进程退出时将使用权赋给____
- 代码实现：
  - 进程P0:
    - while(____);
    - critical section;
    - turn=____
    - remainder section;
  - 进程P1:
    - while(____);
    - critical section;
    - turn=____
    - remainder section;
- 缺点：
  - 必须____进入临界区
  - 若某进程不再进入，另一进程也____
  - 违背"____"准则
  - 容易造成____

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>turn</li>
    <li>P0</li>
    <li>P1</li>
    <li>另一个进程</li>
    <li>turn!=0</li>
    <li>1</li>
    <li>turn!=1</li>
    <li>0</li>
    <li>交替</li>
    <li>无法进入</li>
    <li>空闲让进</li>
    <li>资源利用不充分</li>
  </ul>
</details>
</div>
</ul>

#### 双标志先检查法
- 算法设计：
  - 设置布尔型数组____标记进程进入意愿
  - flag[i]=____表示Pi想要进入临界区
- 执行流程：
  - 先检查对方是否想____
  - 若想进入则____
  - 否则将自己的flag置为____后进入
  - 退出时将flag置为____

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c8a7b8684c1253055bb582e4d790f92a8ed08ef0eec2c8a606352bef6ef4f4d4.jpg)

- 优缺点：
  - 优点：不用交替进入，可____
  - 缺点：可能同时进入临界区，违背"____"准则

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>flag[2]</li>
    <li>true</li>
    <li>进入</li>
    <li>等待</li>
    <li>true</li>
    <li>false</li>
    <li>连续使用</li>
    <li>忙则等待</li>
  </ul>
</details>
</div>
</ul>

#### 双标志后检查法
- 算法设计：
  - 先设置自己的____
  - 再检查对方的____
- 代码实现：
  - 进程P0:
    - flag[0]=____;
    - while(____);
    - critical section;
    - flag[0]=____;
    - remainder section;
  - 进程P1:
    - flag[1]=____;
    - while(____);
    - critical section;
    - flag[1]=____;
    - remainder section;
- 缺点：
  - 可能导致双方都____
  - 违背"____"和"____"准则
  - 会出现"____"现象

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>标志</li>
    <li>标志</li>
    <li>true</li>
    <li>flag[1]</li>
    <li>false</li>
    <li>true</li>
    <li>flag[0]</li>
    <li>false</li>
    <li>无法进入临界区</li>
    <li>空闲让进</li>
    <li>有限等待</li>
    <li>饥饿</li>
  </ul>
</details>
</div>
</ul>

#### Peterson算法

<ul>

> pro：Peterson算法实现互斥的分析（2010）

- 算法设计：
  - 结合____法和____法的思想
  - 用____解决互斥访问
  - 用____解决"饥饿"问题
- 执行流程：
  - 先设置自己的____标志
  - 再设置允许进入____标志
  - 同时检测对方的____和____标志

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9d2b15f4aff86a62f31437cfeddcf39136669afcc3c2023b99d11c01915fbc35.jpg)

- 算法特点：
  - 遵循"____"、"____"、"____"准则
  - 未遵循"____"准则
  - 相比前三种算法最好，但仍____

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>单标志</li>
    <li>双标志后检查</li>
    <li>flag</li>
    <li>turn</li>
    <li>flag</li>
    <li>turn</li>
    <li>flag</li>
    <li>turn</li>
    <li>空闲让进</li>
    <li>忙则等待</li>
    <li>有限等待</li>
    <li>让权等待</li>
    <li>不够完善</li>
  </ul>
</details>
</div>
</ul>

</ul>

### 硬件实现方法

理解本节介绍的硬件实现，对学习后面的信号量很有帮助。计算机提供了特殊的硬件指令，允许对一个字的内容进行____和____，或对两个字的内容进行____等。

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>检测</li>
    <li>修正</li>
    <li>交换</li>
  </ul>
</details>
</div>
</ul>

#### 中断屏蔽方法

<ul>

> pro：关中断指令实现互斥的分析（2021）

- 实现原理：
  - 当进程执行临界区代码时，通过____防止其他进程进入
  - CPU只在发生____时引起进程切换
  - ____保证当前进程完成临界区代码执行
- 典型模式：
  - ____
  - 临界区
  - ____
- 缺点：
  - 限制CPU____能力，系统效率降低
  - 对用户开放____权限不明智
  - 不适用于____系统

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>关中断</li>
    <li>中断</li>
    <li>屏蔽中断</li>
    <li>关中断</li>
    <li>开中断</li>
    <li>交替执行程序</li>
    <li>关中断</li>
    <li>多处理器</li>
  </ul>
</details>
</div>
</ul>

</ul>

#### 硬件指令方法

<ul>

##### TestAndSet指令

借助一条硬件指令—TestAndSet指令（简称TS指令）实现互斥，这条指令是____操作。其功能是读出指定标志后将该标志设置为____。

- 指令功能描述：

```
boolean TestAndSet(boolean *lock) {
    boolean old;
    old = *lock; //old用来存放lock的旧值
    *lock = ____; //无论之前是否已加锁，都将lock置为true
    return old; //返回lock的旧值
}
```

<ul>

> pro：TestAndSet指令实现互斥的分析（2016）

- 实现过程：
  - 为每个临界资源设置共享布尔变量____
  - lock表示资源状态：
    - true：正被____（已加锁）
    - false：____（未加锁）
  - 进入临界区前用TS指令检查____值
  - 实现代码：

```
while ____(&lock); //加锁并检查
// 进程的临界区代码段
lock = ____; //解锁
// 进程的其他代码
```

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>原子</li>
    <li>true</li>
    <li>true</li>
    <li>lock</li>
    <li>占用</li>
    <li>空闲</li>
    <li>lock</li>
    <li>TestAndSet</li>
    <li>false</li>
  </ul>
</details>
</div>
</ul>

</ul>

##### Swap指令

- 功能描述：
  - ____两个字的内容

```
void Swap(boolean *a, boolean *b) {
    boolean temp = *a;
    *a = *b;
    *b = temp;
}
```

> attention：

以上对TS和Swap指令的描述仅为功能描述，它们由____实现，不会被____。

<ul>

> pro：Swap指令与函数实现的分析（2023）

- 实现过程：
  - 设置共享布尔变量____（初值____）
  - 设置局部布尔变量____（初值____）
  - 处理过程代码：

```
boolean key = ____;
while (key != ____)
    Swap(&lock, &key);
// 进程的临界区代码段
lock = ____;
// 进程的其他代码
```

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>交换</li>
    <li>硬件逻辑</li>
    <li>中断</li>
    <li>lock</li>
    <li>false</li>
    <li>key</li>
    <li>true</li>
    <li>true</li>
    <li>false</li>
    <li>false</li>
  </ul>
</details>
</div>
</ul>

</ul>

- 硬件指令方法优缺点：
  - 优点：
    - ____、容易验证正确性
    - 适用于任意数目进程
    - 支持____系统
    - 支持多个____
  - 缺点：
    - 等待进程占用CPU执行____
    - 可能导致"____"现象

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>简单</li>
    <li>多处理器</li>
    <li>临界区</li>
    <li>循环</li>
    <li>饥饿</li>
  </ul>
</details>
</div>
</ul>

</ul>

</ul>

### 互斥锁

<ul>

- 基本概念：
  - 最简单的____解决工具
  - 使用____获得锁
  - 使用____释放锁
  - 通过布尔变量____表示锁可用性

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6ca1d9e89f710eed2244894c9e3ddcf6cf093b3086a42dd982c28bcf739ad6f6.jpg)

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>临界区</li>
    <li>acquire()</li>
    <li>release()</li>
    <li>available</li>
  </ul>
</details>
</div>
</ul>

#### 自旋锁
- 特点：
  - acquire()和release()必须是____操作
  - 通常采用____机制实现
  - 主要缺点是____
  - 适用于____系统
  - 无____
  - 短时间等待代价____

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>原子</li>
    <li>硬件</li>
    <li>忙等待</li>
    <li>多处理器</li>
    <li>上下文切换</li>
    <li>较低</li>
  </ul>
</details>
</div>
</ul>

</ul>

</ul>

## 信号量

<ul>

### 基本概念
- 信号量机制是功能较强的机制，可用来解决____与____问题
- 只能被两个标准原语____和____访问
  - 也可简写为____和____
  - 或简称____操作和____操作

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>互斥</li>
    <li>同步</li>
    <li>wait()</li>
    <li>signal()</li>
    <li>P()</li>
    <li>V()</li>
    <li>P</li>
    <li>V</li>
  </ul>
</details>
</div>
</ul>

#### 原语特性
- 原语定义：完成某种功能且不被____、不被____执行的操作序列
- 实现方式：
  - 通常由____实现
  - 如TS指令和Swap指令是硬件实现的____操作
  - 在单处理机上可通过____实现
- 不中断原因：
  - 若原语对变量操作被____
  - 可能运行另一个对同变量的____
  - 导致____问题

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>分割</li>
    <li>中断</li>
    <li>硬件</li>
    <li>原子</li>
    <li>软件屏蔽中断</li>
    <li>打断</li>
    <li>操作</li>
    <li>临界段</li>
  </ul>
</details>
</div>
</ul>

> pro：信号量的含义（2010）

### 整型信号量

<ul>

#### 定义与操作
- 定义为表示____的整型量S
- 三种操作：
  - ____
  - ____操作
  - ____操作

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>资源数目</li>
    <li>初始化</li>
    <li>wait</li>
    <li>signal</li>
  </ul>
</details>
</div>
</ul>

#### 具体实现
```
wait(S) { // 相当于进入区
    while (____); // 若资源数不够，则一直循环等待
    S = ____; // 若资源数够，则占用一个资源
}

signal(S) { // 相当于退出区
    S = ____; // 使用完后，就释放一个资源
}
```

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>S <= 0</li>
    <li>S - 1</li>
    <li>S + 1</li>
  </ul>
</details>
</div>
</ul>

#### 缺点
- 未遵循"____"准则
- 进程处于"____"状态

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>让权等待</li>
    <li>忙等</li>
  </ul>
</details>
</div>
</ul>

</ul>

### 记录型信号量

<ul>

#### 数据结构
- 组成部分：
  - 整型变量____：代表资源数目
  - 进程链表____：链接等待资源的进程
- 结构定义：
```
typedef struct {
    int value;
    struct process *L;
} ____;
```

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>value</li>
    <li>L</li>
    <li>semaphore</li>
  </ul>
</details>
</div>
</ul>

#### 操作实现

<ul>

##### wait操作
```
void wait(semaphore S) { // 相当于申请资源
    S.value--;
    if (____) {
        add this process to ____;
        ____(S.L);
    }
}
```

<ul>

> pro：wait操作导致线程状态的变化（2023）

> pro：遵循"让权等待"的互斥方法（2018）

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>S.value < 0</li>
    <li>S.L</li>
    <li>block</li>
  </ul>
</details>
</div>
</ul>

</ul>

##### P操作特点
- 请求资源：执行____
- 资源耗尽时(____)：
  - 调用____原语自我阻塞
  - 状态转换：____→____
  - 主动____
  - 插入等待队列____

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>S.value--</li>
    <li>S.value < 0</li>
    <li>block</li>
    <li>运行态</li>
    <li>阻塞态</li>
    <li>放弃CPU</li>
    <li>S.L</li>
  </ul>
</details>
</div>
</ul>

##### signal操作
```
void signal(semaphore S) { // 相当于释放资源
    S.value++;
    if (____) {
        remove a process P from ____;
        ____(P);
    }
}
```

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>S.value <= 0</li>
    <li>S.L</li>
    <li>wakeup</li>
  </ul>
</details>
</div>
</ul>

##### V操作特点
- 释放资源：执行____
- 仍有进程等待时(____)：
  - 调用____原语唤醒S.L中第一个进程
  - 状态转换：____→____

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>S.value++</li>
    <li>S.value <= 0</li>
    <li>wakeup</li>
    <li>阻塞态</li>
    <li>就绪态</li>
  </ul>
</details>
</div>
</ul>

</ul>

</ul>

### 利用信号量实现进程互斥

<ul>

> pro：利用信号量实现互斥的实现（2024）

#### 实现方法
- 设置互斥信号量S，初值为____
- 临界区代码放在____和____之间
- 具体实现：
```
semaphore S = ____; // 初始化信号量，初值为1

P1() {
    ____(S); // 准备访问临界资源，加锁
    // 进程P1的临界区
    ____(S); // 访问结束，解锁
}

P2() {
    ____(S); // 准备访问临界资源，加锁
    // 进程P2的临界区
    ____(S); // 访问结束，解锁
}
```

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>1</li>
    <li>P(S)</li>
    <li>V(S)</li>
    <li>1</li>
    <li>P</li>
    <li>V</li>
    <li>P</li>
    <li>V</li>
  </ul>
</details>
</div>
</ul>

#### 信号量取值说明
- S取值范围：____
  - S=1：两进程都未____
  - S=0：一个进程已____
  - S=-1：一进程在临界区，另一进程____

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>(-1,0,1)</li>
    <li>进入临界区</li>
    <li>进入临界区</li>
    <li>阻塞等待</li>
  </ul>
</details>
</div>
</ul>

> attention：

$\textcircled{\scriptsize{1}}$ 对不同的临界资源需要设置____。 $\circledcirc$ P(S）和V(S)必须____，缺少P(S）就不能保证对临界资源的____访问；缺少V(S会使临界资源____，从而使因等待该资源而阻塞的进程____。 $\textcircled{3}$ 考试还会考查多个资源的问题，有多少资源就将信号量初值设为____，申请资源时执行____操作，释放资源时执行____操作。

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>不同的互斥信号量</li>
    <li>成对出现</li>
    <li>互斥</li>
    <li>永远不被释放</li>
    <li>永远不能被唤醒</li>
    <li>多少</li>
    <li>P</li>
    <li>V</li>
  </ul>
</details>
</div>
</ul>

</ul>

### 利用信号量实现同步

<ul>

> pro：利用信号量实现同步（2024）

#### 基本原理
- 目的：使____进程相互配合有序推进
- 实现方式：
  - 设置同步信号量S，初值为____
  - 在关键语句前后添加____操作

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>异步并发</li>
    <li>0</li>
    <li>PV</li>
  </ul>
</details>
</div>
</ul>

#### 具体实现
```
semaphore S = ____; // 初始化信号量，初值为0

P1() {
    x; // 执行语句x
    ____(S); // 告诉进程P2，语句x已经完成
}

P2() {
    ____(S); // 检查语句x是否运行完成
    y; // 获得x的运行结果，执行语句y
}
```

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>0</li>
    <li>V</li>
    <li>P</li>
  </ul>
</details>
</div>
</ul>

#### 执行过程分析

<ul>

##### 先执行V(S)情况
- V(S)后S=____
- P2执行P(S)时可____

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>1</li>
    <li>直接继续</li>
  </ul>
</details>
</div>
</ul>

##### 先执行P(S)情况
- P(S)后S=____导致P2____
- P1完成后V(S)____P2

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>-1</li>
    <li>阻塞</li>
    <li>唤醒</li>
  </ul>
</details>
</div>
</ul>

</ul>

#### PV操作使用原则
- 同步问题：
  - 提供资源后执行____
  - 使用资源前执行____
- 互斥问题：
  - PV操作紧夹____
  - 中间不能有____

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>V</li>
    <li>P</li>
    <li>临界资源</li>
    <li>冗余代码</li>
  </ul>
</details>
</div>
</ul>

</ul>

### 利用信号量实现前驱关系

<ul>

> pro：信号量实现前驱关系的应用题（2020、2022）

#### 基本概念
- 用于描述程序或语句间的____关系
- 每对前驱关系视为一个____问题

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7b8c21ad5698140e1c8ff7d4a669ea5acb4c62209064712bcf68ad67f3e5d278.jpg)  
图2.10前驱关系举例

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>前驱</li>
    <li>同步</li>
  </ul>
</details>
</div>
</ul>

#### 实现方法
- 为每对前驱关系设置____(初值为____)
- 前驱操作后执行____操作
- 后继操作前执行____操作

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>同步信号量</li>
    <li>0</li>
    <li>V</li>
    <li>P</li>
  </ul>
</details>
</div>
</ul>

#### 具体实现
```
semaphore a12 = ____, a13 = ____, a24 = ____, a25 = ____, a36 = ____, a46 = ____, a56 = ____; // 初始化信号量

S1() {
    // S1的操作
    ____(a12);
    ____(a13); // S1已经运行完成
}

S2() {
    ____(a12); // 检查S1是否运行完成
    // S2的操作
    ____(a24);
    ____(a25); // S2已经运行完成
}

S3() {
    ____(a13); // 检查S1是否已经运行完成
    // S3的操作
    ____(a36); // S3已经运行完成
}

S4() {
    ____(a24); // 检查S2是否已经运行完成
    // S4的操作
    ____(a46); // S4已经运行完成
}

S5() {
    ____(a25); // 检查S2是否已经运行完成
    // S5的操作
    ____(a56); // S5已经运行完成
}

S6() {
    ____(a36); // 检查S3是否已经运行完成
    ____(a46); // 检查S4是否已经运行完成
    ____(a56); // 检查S5是否已经运行完成
    // S6的操作
}
```

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>0</li>
    <li>0</li>
    <li>0</li>
    <li>0</li>
    <li>0</li>
    <li>0</li>
    <li>0</li>
    <li>V</li>
    <li>V</li>
    <li>P</li>
    <li>V</li>
    <li>V</li>
    <li>P</li>
    <li>V</li>
    <li>P</li>
    <li>V</li>
    <li>P</li>
    <li>V</li>
    <li>P</li>
    <li>P</li>
    <li>P</li>
  </ul>
</details>
</div>
</ul>

</ul>

### 分析进程同步和互斥问题的方法步骤

<ul>

#### 关系分析
- 确定____数量
- 分析____关系
- 按经典范式____

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>进程</li>
    <li>同步互斥</li>
    <li>改写</li>
  </ul>
</details>
</div>
</ul>

#### 整理思路
- 找出____
- 参考已有____
- 确定____顺序

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>关键点</li>
    <li>题目</li>
    <li>PV操作</li>
  </ul>
</details>
</div>
</ul>

#### 设置信号量
- 根据前两步设置____
- 确定____
- 完善____

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>信号量</li>
    <li>初值</li>
    <li>整理</li>
  </ul>
</details>
</div>
</ul>

#### 示例分析
- 以图2.10为例：
  - S2使用S1资源：S2前需____操作
  - S2为S4,S5提供资源：S2后需____操作

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>P</li>
    <li>V</li>
  </ul>
</details>
</div>
</ul>

</ul>

</ul>

## 经典同步问题

<ul>

> pro: 程序并发执行的分析（2011、2018）

> pro: PV操作的应用题（2009、2011、2013、2014、2015、2017、2019）

### 生产者-消费者问题

<ul>

#### 基本生产者-消费者问题

<ul>

##### 问题描述
- 一组生产者进程和一组消费者进程共享初始为____、大小为____的缓冲区
- 生产者规则：
  - 缓冲区不满时才能____
  - 缓冲区满时必须____
- 消费者规则：
  - 缓冲区不空时才能____
  - 缓冲区空时必须____
- 缓冲区作为临界资源必须____访问

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>空</li>
    <li>n</li>
    <li>放入消息</li>
    <li>阻塞等待</li>
    <li>取出消息</li>
    <li>等待</li>
    <li>互斥</li>
  </ul>
</details>
</div>
</ul>

##### 问题分析
- 关系分析
  - 互斥关系：生产者和消费者对缓冲区____访问
  - 同步关系：生产者和消费者____
- 整理思路
  - 两个进程：____和____
  - 需解决____和____PV操作位置
- 信号量设置
  - mutex：____信号量，控制互斥访问，初值为____
  - full：记录____缓冲区数，初值为____
  - empty：记录____缓冲区数，初值为____

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>互斥</li>
    <li>相互协作</li>
    <li>生产者</li>
    <li>消费者</li>
    <li>互斥</li>
    <li>同步</li>
    <li>互斥</li>
    <li>1</li>
    <li>满</li>
    <li>0</li>
    <li>空</li>
    <li>n</li>
  </ul>
</details>
</div>
</ul>

##### 代码实现
```
semaphore mutex = ____;
semaphore empty = ____;
semaphore full = ____;

producer() {
    while (1) {
        // 生产一个产品
        ____(empty); // 申请一个空缓冲区
        ____(mutex); // 互斥访问缓冲区
        // 将产品放入缓冲区
        ____(mutex); // 释放互斥
        ____(full); // 增加一个满缓冲区
    }
}

consumer() {
    while (1) {
        ____(full); // 申请一个满缓冲区
        ____(mutex); // 互斥访问缓冲区
        // 从缓冲区取出一个产品
        ____(mutex); // 释放互斥
        ____(empty); // 增加一个空缓冲区
        // 消费产品
    }
}
```

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>1</li>
    <li>n</li>
    <li>0</li>
    <li>P</li>
    <li>P</li>
    <li>V</li>
    <li>V</li>
    <li>P</li>
    <li>P</li>
    <li>V</li>
    <li>V</li>
  </ul>
</details>
</div>
</ul>

##### 注意事项
- 缓冲区大小____的处理
- empty和full的P操作必须在____的P操作之前
- 信号量释放顺序____

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>n</li>
    <li>mutex</li>
    <li>不影响结果</li>
  </ul>
</details>
</div>
</ul>

</ul>

#### 复杂生产者-消费者问题

<ul>

##### 问题描述
- 场景设定：
  - 一个盘子只能放____水果
  - 四个角色：爸爸(放____)、妈妈(放____)、儿子(吃____)、女儿(吃____)
- 规则限制：
  - 盘子空时才能____
  - 有对应水果时才能____

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>一个</li>
    <li>苹果</li>
    <li>橘子</li>
    <li>橘子</li>
    <li>苹果</li>
    <li>放水果</li>
    <li>取出</li>
  </ul>
</details>
</div>
</ul>

##### 问题分析
- 关系分析
  - 互斥关系：爸爸和妈妈____
  - 同步关系：
    - 爸爸和女儿____
    - 妈妈和儿子____
  - 儿子和女儿____
- 整理思路
  - 抽象为____模型
  - 共享缓冲区大小为____

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6ca23faa0313ec798575240909ed9cd726157fb6661276b2ade50932077638ab.jpg)

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>互斥</li>
    <li>同步</li>
    <li>同步</li>
    <li>无直接关系</li>
    <li>两生产者两消费者</li>
    <li>1</li>
  </ul>
</details>
</div>
</ul>

##### 信号量设置与代码实现
- 信号量定义：
  - plate：____信号量，初值____
  - apple：____存在标志，初值____
  - orange：____存在标志，初值____

```
semaphore plate = ____, apple = ____, orange = ____;

dad() { // 父亲进程
    while (1) {
        prepare an apple;
        ____(plate); // 互斥向盘中放水果
        put the apple on the plate;
        ____(apple); // 允许取苹果
    }
}

mom() { // 母亲进程
    while (1) {
        prepare an orange;
        ____(plate); // 互斥向盘中放水果
        put the orange on the plate;
        ____(orange); // 允许取橘子
    }
}

son() { // 儿子进程
    while (1) {
        ____(orange); // 互斥向盘中取橘子
        take an orange from the plate;
        ____(plate); // 允许向盘中取、放水果
        eat the orange;
    }
}

daughter() { // 女儿进程
    while (1) {
        ____(apple); // 互斥向盘中取苹果
        take an apple from the plate;
        ____(plate); // 允许向盘中取、放水果
        eat the apple;
    }
}
```

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>互斥</li>
    <li>1</li>
    <li>苹果</li>
    <li>0</li>
    <li>橘子</li>
    <li>0</li>
    <li>1</li>
    <li>0</li>
    <li>0</li>
    <li>P</li>
    <li>V</li>
    <li>P</li>
    <li>V</li>
    <li>P</li>
    <li>V</li>
    <li>P</li>
    <li>V</li>
  </ul>
</details>
</div>
</ul>

</ul>

</ul>

### 读者一写者问题

<ul>

#### 问题描述
- 共享文件访问规则：
  - 多个读进程可____访问
  - 只允许一个写进程____
  - 写操作期间禁止____
  - 写操作前需清空已有____进程

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>同时</li>
    <li>写入</li>
    <li>其他访问</li>
    <li>读写</li>
  </ul>
</details>
</div>
</ul>

#### 问题分析

<ul>

##### 关系分析
- 读者和写者____
- 写者之间____
- 读者之间____

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>互斥</li>
    <li>互斥</li>
    <li>无互斥</li>
  </ul>
</details>
</div>
</ul>

##### 整理思路
- 两类进程：
  - 写者进程：与任何进程____
  - 读者进程：需要特殊处理
    - 实现与写者____
    - 实现与其他读者____
    - 使用____判断当前读者数量

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>互斥</li>
    <li>互斥</li>
    <li>同步</li>
    <li>计数器</li>
  </ul>
</details>
</div>
</ul>

##### 信号量设置
- count：记录当前____数量，初值____
- mutex：保护____更新的互斥信号量
- rw：保证____互斥访问

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>读者</li>
    <li>0</li>
    <li>count</li>
    <li>读写</li>
  </ul>
</details>
</div>
</ul>

##### 代码实现
```
int count = ____; // 用于记录当前的读者数量
semaphore mutex = ____; // 用于保护更新count变量时的互厅
semaphore rw = ____; // 用于保证读者和写者互厅地访问文件

writer() { // 写者进程
    while (1) {
        ____(rw); // 互斥访问共享文件
        writing; // 写入
        ____(rw); // 释放共享文件
    }
}

reader() { // 读者进程
    while (1) {
        ____(mutex); // 互厅访问count变量
        if (count == 0)
            ____(rw); // 当第一个读进程读共享文件时阻止写进程写
        count++; // 读者计数器加1
        ____(mutex); // 释放互斥变量count
        reading; // 读取
        ____(mutex); // 互斥访问count变量
        count--; // 读者计数器减1
        if (count == 0)
            ____(rw); // 当最后一个读进程读完共享文件允许写进程写
        ____(mutex); // 释放互斥变量count
    }
}
```

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>0</li>
    <li>1</li>
    <li>1</li>
    <li>P</li>
    <li>V</li>
    <li>P</li>
    <li>P</li>
    <li>V</li>
    <li>P</li>
    <li>V</li>
    <li>V</li>
  </ul>
</details>
</div>
</ul>

##### 写优先实现
- 问题：读进程优先可能导致写进程____
- 解决方案：增加信号量实现____
- 代码实现：
```
int count = ____; // 用于记录当前的读者数量
semaphore mutex = ____; // 用于保护更新count变量时的互斥
semaphore rw = ____; // 用于保证读者和写者互厅地访问文件
semaphore w = ____; // 用于实现"写优先"

writer() { // 写者进程
    while (1) {
        ____(w); // 在无写进程请求时进入
        ____(rw); // 互厅访问共享文件
        writing; // 写入
        ____(rw); // 释放共享文件
        ____(w); // 恢复对共享文件的访问
    }
}

reader() { // 读者进程
    while (1) {
        ____(w); // 在无写进程请求时进入
        ____(mutex); // 互斥访问count变量
        if (count == 0)
            ____(rw); // 当第一个读进程读共享文件时阻止写进程写
        count++; // 读者计数器加1
        ____(mutex); // 释放互斥变量count
        ____(w); // 恢复对共享文件的访问
        reading; // 读取
        ____(mutex); // 互斥访问count变量
        count--; // 读者计数器减1
        if (count == 0)
            ____(rw); // 当最后一个读进程读完共享文件允许写进程写
        ____(mutex); // 释放互斥变量count
    }
}
```

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>饿死</li>
    <li>写优先</li>
    <li>0</li>
    <li>1</li>
    <li>1</li>
    <li>1</li>
    <li>P</li>
    <li>P</li>
    <li>P</li>
    <li>V</li>
    <li>P</li>
    <li>P</li>
    <li>V</li>
    <li>V</li>
    <li>P</li>
    <li>V</li>
    <li>V</li>
  </ul>
</details>
</div>
</ul>

</ul>

</ul>

### 哲学家进餐问题

<ul>

#### 问题描述
- 场景设定：
  - ____名哲学家围坐圆桌
  - 每两人之间一根____
  - 需要____根筷子才能进餐
  - 思考时不影响____

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/567eb1efeb3cc2f9ca660455e2c6d5ab14a621176352deb48365ab56996ee8d6.jpg)

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>5</li>
    <li>筷子</li>
    <li>两</li>
    <li>他人</li>
  </ul>
</details>
</div>
</ul>

#### 问题分析

<ul>

##### 关系分析
- 相邻哲学家对筷子____访问

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>互斥</li>
  </ul>
</details>
</div>
</ul>

##### 整理思路
- ____个进程
- 关键：避免____和____

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>5</li>
    <li>饥饿</li>
    <li>死锁</li>
  </ul>
</details>
</div>
</ul>

##### 信号量设置
- chopstick[5]：____个互斥信号量
- 编号规则：
  - 哲学家编号____
  - 左筷子编号____
  - 右筷子编号____

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>5</li>
    <li>0~4</li>
    <li>i</li>
    <li>(i+1)%5</li>
  </ul>
</details>
</div>
</ul>

##### 代码实现与改进
- 初始实现：
```
semaphore chopstick[5] = {____, ____, ____, ____, ____}; // 定义信号量数组chopstick[5]，并初始化

Pi() { // i号哲学家的进程
    do {
        ____(chopstick[i]); // 取左边筷子
        ____(chopstick[(i + 1) % 5]); // 取右边筷子
        eat; // 进餐
        ____(chopstick[i]); // 放回左边筷子
        ____(chopstick[(i + 1) % 5]); // 放回右边筷子
        think; // 思考
    } while (1);
}
```

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>1</li>
    <li>1</li>
    <li>1</li>
    <li>1</li>
    <li>1</li>
    <li>P</li>
    <li>P</li>
    <li>V</li>
    <li>V</li>
  </ul>
</details>
</div>
</ul>

- 死锁问题解决方案：
  - 限制同时进餐____
  - 要求同时获得____
  - 奇偶编号采用____

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>人数</li>
    <li>两根筷子</li>
    <li>不同顺序</li>
  </ul>
</details>
</div>
</ul>

- 改进实现：
```
semaphore chopstick[5] = {____, ____, ____, ____, ____}; // 初始化信号量
semaphore mutex = ____; // 设置取筷子的信号量

Pi() { // i号哲学家的进程
    do {
        ____(mutex); // 在取筷子前获得互厅量
        ____(chopstick[i]); // 取左边筷子
        ____(chopstick[(i + 1) % 5]); // 取右边筷子
        ____(mutex); // 释放取筷子的信号量
        eat; // 进餐
        ____(chopstick[i]); // 放回左边筷子
        ____(chopstick[(i + 1) % 5]); // 放回右边筷子
        think; // 思考
    } while (1);
}
```

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>1</li>
    <li>1</li>
    <li>1</li>
    <li>1</li>
    <li>1</li>
    <li>1</li>
    <li>P</li>
    <li>P</li>
    <li>P</li>
    <li>V</li>
    <li>V</li>
    <li>V</li>
  </ul>
</details>
</div>
</ul>

</ul>

</ul>

### 吸烟者问题

<ul>

#### 问题描述
- 系统组成：
  - ____个抽烟者进程
  - ____个供应者进程
- 材料需求：
  - 需要三种材料：____、____和____
  - 每个抽烟者拥有一种材料：
    - 第一个拥有____
    - 第二个拥有____
    - 第三个拥有____
- 运行机制：
  - 供应者无限提供____
  - 每次放____种材料到桌上
  - 拥有剩余材料的抽烟者可以____
  - 抽完后通知____
  - ____进行

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>3</li>
    <li>1</li>
    <li>烟草</li>
    <li>纸</li>
    <li>胶水</li>
    <li>烟草</li>
    <li>纸</li>
    <li>胶水</li>
    <li>材料</li>
    <li>两</li>
    <li>抽烟</li>
    <li>供应者</li>
    <li>循环</li>
  </ul>
</details>
</div>
</ul>

#### 问题分析

<ul>

##### 关系分析
- 供应者与抽烟者是____关系
- 抽烟者之间____关系

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>同步</li>
    <li>互斥</li>
  </ul>
</details>
</div>
</ul>

##### 整理思路
- ____个进程
- 供应者作为____
- 三个抽烟者作为____

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>4</li>
    <li>生产者</li>
    <li>消费者</li>
  </ul>
</details>
</div>
</ul>

##### 信号量设置
- offer1、offer2、offer3：表示不同____组合
- finish：____抽烟信号量

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>材料</li>
    <li>互斥</li>
  </ul>
</details>
</div>
</ul>

##### 代码实现

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/bd5b548d53c5c6177ed7838bce4b43d990cea070b913efcc9de738968c216af0.jpg)

```
while (1) {
    ____(offer3);
    // 拿纸和胶水，卷成烟，抽掉
    ____(finish);
}

process P3() { // 拥有纸者
    while (1) {
        ____(offer2);
        // 拿烟草和胶水，卷成烟，抽掉
        ____(finish);
    }
}

process P4() { // 拥有胶水者
    while (1) {
        ____(offer1);
        // 拿烟草和纸，卷成烟，抽掉
        ____(finish);
    }
}
```

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>P</li>
    <li>V</li>
    <li>P</li>
    <li>V</li>
    <li>P</li>
    <li>V</li>
  </ul>
</details>
</div>
</ul>

</ul>

</ul>

### 管程

<ul>

#### 基本概念
- 产生原因：
  - 信号量机制的____
  - 同步操作____
  - 容易导致____
- 优势：
  - 保证进程____
  - 降低____风险
  - 提供____

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>缺陷</li>
    <li>分散</li>
    <li>死锁</li>
    <li>互斥</li>
    <li>死锁</li>
    <li>条件变量</li>
  </ul>
</details>
</div>
</ul>

#### 管程定义

<ul>

> pro：管程的特点（2016）

##### 资源抽象
- 硬件和软件资源用____描述
- 忽略____和____

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>数据结构</li>
    <li>内部结构</li>
    <li>实现细节</li>
  </ul>
</details>
</div>
</ul>

##### 组成部分
- ____名称
- ____说明
- 操作过程或____
- ____语句

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>管程</li>
    <li>共享数据结构</li>
    <li>函数</li>
    <li>初始化</li>
  </ul>
</details>
</div>
</ul>

##### 示例代码
```
monitor Demo {
    // ②定义共享数据结构，对应系统中的某种共享资源
    共享数据结构 ____;
    // ④对共享数据结构初始化的语句
    init_code() {
        S = ____; // 初始资源数等于5
    }
    takeaway() { // ③过程1：申请一个资源
        // 对共享数据结构x的一系列处理
        S____; // 可用资源数-1
    }
    giveback() { // ③过程2：归还一个资源
        // 对共享数据结构x的一系列处理
        S____; // 可用资源数+1
    }
}
```

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>S</li>
    <li>5</li>
    <li>--</li>
    <li>++</li>
  </ul>
</details>
</div>
</ul>

##### 特性分析
- 封装性：
  - 共享资源操作____
  - 只能通过管程内____访问
- 互斥性：
  - ____进程访问
  - ____执行管程内过程

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>封装</li>
    <li>过程</li>
    <li>单一</li>
    <li>顺序</li>
  </ul>
</details>
</div>
</ul>

</ul>

#### 条件变量

<ul>

##### 基本概念
- 作用：解决进程____问题
- 特点：
  - 可设置多个____
  - 每个变量有____

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>阻塞</li>
    <li>条件变量</li>
    <li>等待队列</li>
  </ul>
</details>
</div>
</ul>

##### 操作方式
- x.wait：
  - 条件不满足时使用
  - 进程进入____
  - ____管程
- x.signal：
  - 条件变化时使用
  - ____阻塞进程

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>等待队列</li>
    <li>释放</li>
    <li>唤醒</li>
  </ul>
</details>
</div>
</ul>

##### 示例代码
```
monitor Demo {
    共享数据结构 ____;
    condition ____; // 定义一个条件变量x
    init_code() {
        // 初始化
    }
    takeaway() {
        if (S <= 0)
            ____.wait(); // 资源不够，在条件变量x上阻塞等待
        // 资源足够，分配资源，做一系列相应处理
    }
    giveback() {
        // 归还资源，做一系列相应处理
        if (有进程在等待)
            ____.signal(); // 唤醒一个阻塞进程
    }
}
```

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>S</li>
    <li>x</li>
    <li>x</li>
    <li>x</li>
  </ul>
</details>
</div>
</ul>

##### 与信号量比较
- 相似点：
  - wait/signal类似____操作
  - 实现进程____/____
- 不同点：
  - 条件变量____，只有排队功能
  - 信号量____，表示资源数

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>P/V</li>
    <li>阻塞</li>
    <li>唤醒</li>
    <li>无值</li>
    <li>有值</li>
  </ul>
</details>
</div>
</ul>

</ul>

</ul>

</ul>

## 本节小结

<ul>

本节开头提出的问题的参考答案如下。

1）为什么要引入进程同步的概念？

<ul>

在多道程序共同执行的条件下，进程与进程是____执行的，不同进程之间存在不同的____关系。为了协调进程之间的____关系，引入了进程同步的概念。

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>并发</li>
    <li>相互制约</li>
    <li>相互制约</li>
  </ul>
</details>
</div>
</ul>

</ul>

2）不同的进程之间会存在什么关系？

<ul>

进程之间存在____与____的制约关系。

同步是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而____、____所产生的制约关系。

互厅是指当一个进程进入临界区使用临界资源时，另一个进程必须____，当占用临界资源的进程退出临界区后，另一进程才允许去____此临界资源。

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>同步</li>
    <li>互厅</li>
    <li>等待</li>
    <li>传递信息</li>
    <li>等待</li>
    <li>访问</li>
  </ul>
</details>
</div>
</ul>

</ul>

3）当单纯用本节介绍的方法解决这些问题时会遇到什么新的问题吗？

<ul>

当两个或两个以上的进程在执行过程中，因占有一些资源而又需要对方的资源时，会因为____而造成一种互相等待的现象，若无外力作用，它们都将无法推进下去。这种现象称为____，具体介绍和解决方案请参考下一节。

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>争夺资源</li>
    <li>死锁</li>
  </ul>
</details>
</div>
</ul>

</ul>

</ul>

# 死锁

<ul>

在学习本节时，请读者思考以下问题：

1）为什么会产生死锁？产生死锁有什么条件？

2）有什么办法可以解决死锁问题？

学完本节，读者应了解死锁的由来、产生条件及基本解决方法，区分避免死锁和预防死锁。

## 概念

<ul>

### 死锁的定义
- 在多道程序系统中，由于进程的____执行，极大提升了系统效率
- 多个进程的并发执行带来了新问题-____
  - 死锁定义：多个进程因____而造成的僵局（互相等待对方手里的资源）
  - 结果：各个进程都被____，若无外力干涉，这些进程都无法____

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>并发</li>
    <li>死锁</li>
    <li>竞争资源</li>
    <li>阻塞</li>
    <li>向前推进</li>
  </ul>
</details>
</div>
</ul>

#### 死锁实例说明

<ul>

##### 生活实例
- 窄桥通行问题：
  - 桥面很窄，只能容纳____通行
  - 两辆汽车分别从桥的____驶上该桥
  - 双方都只想向前行驶，导致都____

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>一辆汽车</li>
    <li>左右两端</li>
    <li>无法过桥</li>
  </ul>
</details>
</div>
</ul>

##### 计算机系统实例
- 打印机和输入设备竞争：
  - P1占用____，请求____
  - P2占用____，请求____
  - 两个进程____，无法推进

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>输入设备</li>
    <li>打印机</li>
    <li>打印机</li>
    <li>输入设备</li>
    <li>相互等待</li>
  </ul>
</details>
</div>
</ul>

</ul>

</ul>

### 死锁与饥饿

<ul>

#### 基本概念
- 死锁：组内每个进程都在等待只能由____产生的事件
- 饥饿：进程在信号量内____的情况

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>组内另一个进程</li>
    <li>无穷等待</li>
  </ul>
</details>
</div>
</ul>

#### 饥饿产生原因
- 系统分配策略____
- 不能保证____上界
- 示例：最短文件优先打印策略导致长文件任务被____

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>不公平</li>
    <li>等待时间</li>
    <li>无限期推迟</li>
  </ul>
</details>
</div>
</ul>

#### 死锁与饥饿的比较

<ul>

##### 共同点
- 都是进程无法顺利____的现象

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>向前推进</li>
  </ul>
</details>
</div>
</ul>

##### 差别
- 进程数量：
  - 饥饿可以只有____进程
  - 死锁必须____进程
- 进程状态：
  - 饥饿的进程可能处于____或____
  - 死锁的进程必定处于____

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>一个</li>
    <li>大于或等于两个</li>
    <li>就绪态</li>
    <li>阻塞态</li>
    <li>阻塞态</li>
  </ul>
</details>
</div>
</ul>

</ul>

</ul>

### 死锁产生的原因

<ul>

> pro: 单类资源竞争时发生死锁的临界条件的分析（2009、2014）

#### 系统资源的竞争
- ____资源数量不足
- 只有对____资源的竞争才可能产生死锁
- 对____资源的竞争不会引起死锁

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>不可剥夺</li>
    <li>不可剥夺</li>
    <li>可剥夺</li>
  </ul>
</details>
</div>
</ul>

#### 进程推进顺序非法
- 请求和释放资源____
- 信号量使用____
- 进程间____对方消息

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>顺序不当</li>
    <li>不当</li>
    <li>相互等待</li>
  </ul>
</details>
</div>
</ul>

</ul>

### 死锁产生的必要条件
- 必须同时满足以下____个条件：
  1. ____条件：资源排他性使用
  2. ____条件：资源只能由获得者主动释放
  3. ____条件：进程保持资源的同时请求新资源
  4. ____条件：存在进程资源的循环等待链

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8382f5327fbc8823d52780a2673570e56eed41df9c30bb9c88f94f8a9c2dd8bf.jpg)  
图2.13循环等待

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/70b26273296eb44fa64f010de91910da39cd2519c4626ecd3dc2a1c826139085.jpg)  
图2.14满足条件但无死锁

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>4</li>
    <li>互斥</li>
    <li>不可剥夺</li>
    <li>请求并保持</li>
    <li>循环等待</li>
  </ul>
</details>
</div>
</ul>

#### 特殊说明
- 循环等待与死锁定义的区别：
  - 死锁定义要求Pi等待的资源必须由____满足
  - 循环等待条件____
- 资源分配图含圈的情况：
  - 同类资源数大于1时，不一定有____
  - 每类资源只有一个时，含圈就是死锁的____条件

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>Pi+1</li>
    <li>无此限制</li>
    <li>死锁</li>
    <li>充分必要</li>
  </ul>
</details>
</div>
</ul>

### 死锁的处理策略

<ul>

#### 主要策略
1. ____：破坏死锁必要条件
2. ____：防止系统进入不安全状态
3. ____：允许死锁发生但及时检测和解除

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>死锁预防</li>
    <li>避免死锁</li>
    <li>死锁的检测及解除</li>
  </ul>
</details>
</div>
</ul>

#### 策略比较
- 预防死锁：
  - 限制条件____
  - 实现____
  - 系统效率____
- 避免死锁：
  - 限制条件____
  - 实现____
  - 需要____判断

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>严格</li>
    <li>简单</li>
    <li>低</li>
    <li>宽松</li>
    <li>复杂</li>
    <li>算法</li>
  </ul>
</details>
</div>
</ul>

表2.4死锁处理策略的比较
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/66a9b4bf08130fd2eed0f5eceaf0f8e8b965b0314dc89eeca7ada07badd65762.jpg)

</ul>

</ul>

## 死锁预防

<ul>

> pro：死锁预防的特点（2019）

预防死锁的发生只需破坏死锁产生的____个必要条件之一即可。

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>4</li>
  </ul>
</details>
</div>
</ul>

### 破坏互斥条件
- 如果将只能互斥使用的资源改造为允许____，那么系统不会进入死锁状态
- 但有些资源根本不能____，如打印机等临界资源只能____
- 所以，破环互厅条件而预防死锁的方法____，而且为了系统安全，很多时候还必须保护这种____

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>共享使用</li>
    <li>同时访问</li>
    <li>互斥使用</li>
    <li>不太可行</li>
    <li>互斥性</li>
  </ul>
</details>
</div>
</ul>

### 破坏不可剥夺条件
- 当一个已经保持了某些不可剥夺资源的进程，请求新的资源而得不到满足时：
  - 必须____已经保持的所有资源
  - 待以后需要时____
- 实现特点：
  - 实现起来比较____
  - 释放已获得的资源可能造成____
  - 常用于状态易于____的资源(如CPU寄存器及内存资源)
  - 一般不能用于____之类的资源
  - 反复申请和释放资源会影响进程____和____

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>释放</li>
    <li>重新申请</li>
    <li>复杂</li>
    <li>前一阶段工作的失效</li>
    <li>保存和恢复</li>
    <li>打印机</li>
    <li>推进速度</li>
    <li>系统吞吐量</li>
  </ul>
</details>
</div>
</ul>

### 破坏请求并保持条件

<ul>

#### 实现方法

<ul>

##### 方法一：预先静态分配
- 进程在运行前一次申请完____
- 资源未满足前不让____
- 运行期间不再提出____

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>所需全部资源</li>
    <li>投入运行</li>
    <li>资源请求</li>
  </ul>
</details>
</div>
</ul>

##### 方法二：动态分配
- 允许进程获得运行初期所需资源后____
- 逐步释放已使用完毕的资源后才能____

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>开始运行</li>
    <li>请求新资源</li>
  </ul>
</details>
</div>
</ul>

</ul>

#### 方法比较
- 方法一：
  - 实现____
  - 系统资源被____
  - 可能导致"____"现象
- 方法二：
  - 改进了方法一的____

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>简单</li>
    <li>严重浪费</li>
    <li>饥饿</li>
    <li>缺点</li>
  </ul>
</details>
</div>
</ul>

</ul>

### 破坏循环等待条件

<ul>

#### 实现方法：顺序资源分配法
- 给系统各类资源____
- 规定进程按编号____请求资源
- 同类资源____

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>编号</li>
    <li>递增顺序</li>
    <li>一次申请完</li>
  </ul>
</details>
</div>
</ul>

#### 缺点
- 编号必须____，不便于增加新设备
- 实际使用顺序可能与____不一致，造成资源浪费
- 按规定次序申请给用户____带来麻烦

<ul>
<div>
<details>
  <summary> </summary>
  <ul>
    <li>相对稳定</li>
    <li>编号次序</li>
    <li>编程</li>
  </ul>
</details>
</div>
</ul>

</ul>

</ul>

## 死锁避免

<ul>

避免死锁同样属于事先预防策略，但并不是事先采取某种限制措施破坏死锁的必要条件，而是在每次分配资源的过程中，都要分析此次分配是否

以下是按照您的要求对提供的内容进行挖空处理后的结果，包含 Markdown 和 HTML 折叠块格式。每个次级标题下的挖空答案均在下方使用 `<details>` 和 `<ul>` 标签设置为折叠块，且保留了原有的目录结构和完整内容。

---

## 银行家算法

<ul>

银行家算法的基本思想是进程提出资源请求时，系统首先判断是否满足____条件，若满足则进行试探性分配，并检查分配后系统的____状态。若状态安全，则正式分配资源，否则拒绝分配。

### 银行家算法步骤

<ul>

1. 检查资源请求是否合法
   - 检查进程i的资源请求向量Request[i]是否____Need[i]

2. 检查____[i] ≤ Available
3. 试探分配资源并修改数据
   - Available = Available - ____
   - Allocation[i] = Allocation[i] + ____
   - Need[i] = Need[i] - ____
4. 执行____检查
   - 安全则____分配
   - 不安全则____原状态

<ul>

<div>
<details>
  <summary> </summary>
  <ul>
    <li>

基本</li>
    <li>

安全</li>
    <li>

≤</li>
    <li>

Request</li>
    <li>

Request</li>
    <li>

Request</li>
    <li>

Request</li>
    <li>

安全性</li>
    <li>

正式</li>
    <li>

恢复</li>
  </ul>
</details>
</div>

</ul>

#### 安全性算法

<ul>

##### 初始化
- 设置工作向量Work = ____
- 安全序列初始为____

##### 执行步骤
1. 查找符合条件的进程
   - 不在____序列中
   - Need行 ≤ ____向量
2. 将找到的进程加入____序列
3. 更新Work向量
   - Work = Work + ____[i]
4. 检查结果
   - 所有进程都在序列中则____
   - 否则____

<ul>

<div>
<details>
  <summary> </summary>
  <ul>
    <li>

Available</li>
    <li>

空</li>
    <li>

安全</li>
    <li>

Work</li>
    <li>

安全</li>
    <li>

Allocation</li>
    <li>

安全</li>
    <li>

不安全</li>
  </ul>
</details>
</div>

</ul>

</ul>

</ul>

### 安全性算法举例

<ul>

> pro：银行家算法的安全序列分析（2011、2012、2018、2020、2022）

#### 系统初始状态
- 5个进程：{P0, P1, P2, P3, P4}
- 3类资源：{A, B, C}，数量分别为____, ____, ____
- T0时刻资源分配情况如表2.6所示

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a8adbee6a8825ebe4dcf6c32cbd452fbdefa774952f8c76667dbb0a512dbe973.jpg)

#### 安全性分析步骤
1. 计算____矩阵
   - 由Max矩阵减____矩阵得到

2. 比较Work向量与____矩阵
   - 初始时(3,3,2)>____
   - (3,3,2)>____
   - 可选P1或P3，这里选____

3. 释放P1资源并更新Work
   - Work = (3,3,2) + ____ = (5,3,2)
   - 更新____矩阵，去除P1行

4. 重复分析过程
   - 如表2.7所示
   - 最终得到安全序列____

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/934bf38cec4146d12fb5d939e6937668939e21fdacbbcdd945edd27be3a1bdfa.jpg)

<ul>

<div>
<details>
  <summary> </summary>
  <ul>
    <li>

10</li>
    <li>

5</li>
    <li>

7</li>
    <li>

Need</li>
    <li>

Allocation</li>
    <li>

Need</li>
    <li>

(1,2,2)</li>
    <li>

(0,1,1)</li>
    <li>

P1</li>
    <li>

(2,0,0)</li>
    <li>

Need</li>
    <li>

{P1,P3,P4,P2,P0}</li>
  </ul>
</details>
</div>

</ul>

</ul>

### 银行家算法举例

<ul>

安全性算法是银行家算法的____，在银行家算法的题目中，一般会有某个进程的一个资源请求向量，读者只要执行上面所介绍的银行家算法的前____步，马上就会得到更新的____矩阵和____矩阵，再按照上例的安全性算法判断，就能知道系统能否满足进程提出的资源请求。

假设当前系统中资源的分配和剩余情况如表2.6所示。

(1) $\mathrm{P_{1}}$ 请求资源： $\mathrm{P_{1}}$ Request $\mathbf{\Phi}_{1}$____ ，系统按银行家算法进行检查Request $_1$____$\mathrm{Ned}_{1}$____ Request $\mathrm{st}_{1}$____$\mathrm{Available}_{1}$____ 系统先假定可为 $\mathrm{P}_{1}$ 分配资源，并修改Available $\mathbf{\Psi}=$$\mathbf{A}\mathbf{v}\mathbf{a}\mathbf{i}\mathbf{l}\mathbf{o}\mathbf{l}\mathbf{e}-$$\mathbf{R}\mathbf{e}\mathbf{q}\mathbf{e}\mathbf{s}\mathbf{t}_{1}$$\mathbf{=}$____ Alloc $\mathrm{action}_{1}\!=\!$$\mathrm{Allreduce}_{1}+$$\mathrm{Recong}_{1}\!=\!$____ $\mathrm{Ned}_{1}\,{=}\,$$\mathrm{Ned}_{1}\,{-}\,$$\mathrm{Reqest}_{1}\,{=}$____ 由此形成的资源变化情况如表2.6中的圆括号所示。令Work $=$ Available $\mathbf{\chi}=$(2,3,0) ，再利用安全性算法检查此时系统是否____，如表2.8所示。

表2.8 $\mathbf{P}_{1}$ 申请资源时的安全性检查
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/11daabec04206bf68237fabfdbb67ee829540e13d552a5b8b4ac587ea8d7319c.jpg)

由所进行的安全性检查得知，可找到一个安全序列 ____ 。因此，系统是安全的，可以立即将 $\mathrm{P}_{1}$ 所申请的资源分配给它。分配后系统中的资源情况如表2.9所示。

表2.9为 $\mathbf{P}_{1}$ 分配资源后的有关资源数据
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/334aa28832f016418a963592eb9b59ff66a14a150d66d6179335758c310f4c07.jpg)

（2) $\mathrm{P_{4}}$ 请求资源： $\mathrm{{P_{4}}}$ 发出请求向量Request4____，系统按银行家算法进行检查Request ____$\mathrm{Ned}_{4}$____ Request ____ Available____，让 $\mathrm{{P_{4}}}$ ____。(3) $\mathrm{{P_{0}}}$ 请求资源： $\mathrm{{P_{0}}}$ Request $\phantom{}_{0}$____ ，系统按银行家算法进行检查：Request $_{0}$____$\mathrm{Ned}_{0}$____ Requesto____Available____ 系统暂时先假定可为 $\mathrm{{P_{0}}}$ 分配资源，并修改有关数据：Available $=$ Available-Requesto=____ $\mathrm{Alllocation}_{0}\,{=}\,$$\mathrm{Alllocation}_{0}\,{+}\,\mathrm{Recong}_{0}\,{=}$____ Need $_0=$ Needo-Reques $\mathfrak{t}_{0}\!=\!$____ ，结果如表2.10所示。

表2.10为 $\mathbf{P_{0}}$ 分配资源后的有关资源数据
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6c035c506edf8b4ea581fe8a4957b7dc4d56ce1adbecab24ac8bff3825a908fb.jpg)

进行安全性检查：可用资源Available ____ 已不能满足任何进程的需要，系统进入____状态，因此拒绝 $\mathrm{{P_{0}}}$ 的请求，让 $\mathrm{{P_{0}}}$ ____，Available，Allocation o，Need o。

<ul>

<div>
<details>
  <summary> </summary>
  <ul>
    <li>

核心</li>
    <li>

三</li>
    <li>

Allocation</li>
    <li>

Need</li>
    <li>

(1,0,2)</li>
    <li>

(1,0,2)≤</li>
    <li>

(1,2,2)</li>
    <li>

(1,0,2)≤</li>
    <li>

(3,3,2)</li>
    <li>

(2,3,0)</li>
    <li>

(3,0,2)</li>
    <li>

(0,2,0)</li>
    <li>

安全</li>
    <li>

$\{\mathrm{P}_{1},\mathrm{P}_{3},\mathrm{P}_{4},\mathrm{P}_{0},\mathrm{P}_{2}\}$</li>
    <li>

(3,3,0)</li>
    <li>

(3,3,0)≤</li>
    <li>

(4,3,1)</li>
    <li>

(3,3,0)> </li>
    <li>

(2,3,0)</li>
    <li>

等待</li>
    <li>

(0,2,0)</li>
    <li>

(0,2,0)≤</li>
    <li>

(7,4,3)</li>
    <li>

(0,2,0)≤</li>
    <li>

(2,3,0)</li>
    <li>

(2,1,0)</li>
    <li>

(0,3,0)</li>
    <li>

(7,2,3)</li>
    <li>

(2,1,0)</li>
    <li>

不安全</li>
    <li>

等待</li>
  </ul>
</details>
</div>

</ul>

</ul>

</ul>

## 死锁检测和解除

<ul>

pro：死锁避免和死锁检测的区分（2015）

前面介绍的死锁预防和避免算法，都是在为进程分配资源时施加____条件或进行检测，若系统为进程分配资源时不采取任何预防或避免措施，则应该提供死锁____和____的手段。

### 死锁检测

<ul>

> pro：死锁避免和死锁检测对比（2015）

#### 死锁避免和检测的区别
- 死锁避免:
  - 需要在进程运行过程中持续保证不会出现____
  - 需要知道进程从开始到结束的所有____请求
- 死锁检测:
  - 只检测某个时刻是否发生____
  - 只需知道对应时刻的____请求

> pro：多在资源竞争时发生死锁的临界条件分析（2016、2021)

#### 资源分配图检测
- 图形表示方法:
  - 圆圈表示____
  - 框表示____类型
  - 框中圆表示单个____
  - 有向边分类:
    - 请求边:____到资源
    - 分配边:____到进程

- 示例说明:
  - P1进程:
    - 已分配两个____资源
    - 请求一个____资源
  - P2进程:
    - 已分配一个____和一个____资源
    - 请求一个____资源

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/77b5c15fac24c0dd51fd809180026878402240b17f0e37a3fc36084e15d76733.jpg)

#### 简化资源分配图方法
- 步骤1:
  - 找出非____非____进程
  - 消除其____边和____边
  - 使其成为____节点
- 步骤2:
  - 释放资源可能唤醒____进程
  - 重复步骤1的____过程
- 死锁判定:
  - 图不可完全简化则存在____

<ul>

<div>
<details>
  <summary> </summary>
  <ul>
    <li>

限制</li>
    <li>

检测</li>
    <li>

解除</li>
    <li>

死锁</li>
    <li>

资源</li>
    <li>

死锁</li>
    <li>

资源</li>
    <li>

进程</li>
    <li>

资源</li>
    <li>

资源</li>
    <li>

进程</li>
    <li>

资源</li>
    <li>

R1</li>
    <li>

R2</li>
    <li>

R1</li>
    <li>

R2</li>
    <li>

R1</li>
    <li>

阻塞</li>
    <li>

孤立</li>
    <li>

请求</li>
    <li>

分配</li>
    <li>

孤立</li>
    <li>

阻塞</li>
    <li>

简化</li>
    <li>

死锁</li>
  </ul>
</details>
</div>

</ul>

</ul>

### 死锁解除

<ul>

> pro：解除死锁的方式（2019）

#### 主要解除方法
- 资源剥夺法:
  - 挂起部分____进程
  - 抢占其资源分配给其他____
  - 注意防止进程长期资源____

> attention：

在资源分配图中，用死锁定理化简后，还有边相连的那些进程就是____进程。

- 撤销进程法:
  - 强制撤销部分或全部____进程
  - 按进程____和____选择撤销对象
  - 实现简单但____可能较大

- 进程回退法:
  - 让死锁进程____避免死锁
  - 进程自愿释放____
  - 要求系统:
    - 保持进程____信息
    - 设置____点

<ul>

<div>
<details>
  <summary> </summary>
  <ul>
    <li>

死锁</li>
    <li>

进程</li>
    <li>

匮乏</li>
    <li>

死锁</li>
    <li>

死锁</li>
    <li>

优先级</li>
    <li>

代价</li>
    <li>

代价</li>
    <li>

回退</li>
    <li>

资源</li>
    <li>

历史</li>
    <li>

还原</li>
  </ul>
</details>
</div>

</ul>

</ul>

</ul>

## 本节小结

<ul>

本节开头提出的问题的参考答案如下。

1）为什么会广生死锁！广生死锁有什么余件？

由于系统中存在一些不可剥夺资源，当两个或两个以上的进程占有自身的资源并请求对方的资源时，会导致每个进程都无法向前推进，这就是____。死锁产生的必要条件有____个，分别是____条件、____条件、____并保持条件和____等待条件。

互斥条件是指进程要求分配的资源是____性的，即最多只能同时供一个进程使用。

不剥夺条件是指进程在使用完资源之前，资源不能被____夺走。请求并保持条件是指进程占有自身本来拥有的资源并要求____资源。循环等待条件是指存在一种进程资源的____等待链。

2）有什么办法可以解决死锁问题？

死锁的处理策略可以分为____死锁、____死锁及死锁的____与____。死锁预防是指通过设立一些限制条件，破坏死锁的一些必要条件，让死锁无法发生。死锁避免指在动态分配资源的过程中，用一些算法防止系统进入____状态，从而避免死锁，死锁的检测和解除是指在死锁产生前不采取任何措施，只检测当前系统有没有发生____，若有，则采取一些措施____死锁。

<ul>

<div>
<details>
  <summary> </summary>
  <ul>
    <li>

死锁</li>
    <li>

4</li>
    <li>

互斥</li>
    <li>

不剥夺</li>
    <li>

请求</li>
    <li>

循环</li>
    <li>

排他</li>
    <li>

强制</li>
    <li>

其他</li>
    <li>

循环</li>
    <li>

预防</li>
    <li>

避免</li>
    <li>

检测</li>
    <li>

解除</li>
    <li>

不安全</li>
    <li>

死锁</li>
    <li>

解除</li>
  </ul>
</details>
</div>

</ul>

</ul>

## 本章疑难点

<ul>

### 进程与程序的区别与联系

<ul>

1）进程是程序及其数据在计算机上的一次运行活动，是一个____的概念。进程的运行实体是____，离开程序的进程没有存在的意义。从静态角度看，进程是由____、____和进程控制块（PCB）三部分组成的。而程序是一组有序的指令集合，是一种____的概念。

2）进程是程序的一次执行过程，它是动态地创建和消亡的，具有一定的____，是暂时存在的：而程序则是一组代码的集合，是____存在的，可长期保存。

3）一个进程可以执行一个或几个____，一个程序也可构成多个____。进程可创建____，而程序不可能形成新的____。

4）进程与程序的组成不同。进程的组成包括____、____和PCB。

<ul>

<div>
<details>
  <summary> </summary>
  <ul>
    <li>

动态</li>
    <li>

程序</li>
    <li>

程序</li>
    <li>

数据</li>
    <li>

静态</li>
    <li>

生命周期</li>
    <li>

永久</li>
    <li>

程序</li>
    <li>

进程</li>
    <li>

进程</li>
    <li>

程序</li>
    <li>

程序</li>
    <li>

数据</li>
  </ul>
</details>
</div>

</ul>

</ul>

### 银行家算法的工作原理

<ul>

银行家算法的主要思想是避免系统进入____状态。在每次进行资源分配时，它首先检查系统是否有足够的资源满足要求，若有则先进行试分配，并对分配后的新状态进行____检查。若新状态____，则正式分配上述资源，否则拒绝分配上述资源。这样，它保证系统始终处于____状态，从而避免了____现象的发生。

<ul>

<div>
<details>
  <summary> </summary>
  <ul>
    <li>

不安全</li>
    <li>

安全性</li>
    <li>

安全</li>
    <li>

安全</li>
    <li>

死锁</li>
  </ul>
</details>
</div>

</ul>

</ul>

## 进程同步、互斥的区别和联系

<ul>

并发进程的执行会产生相互制约的关系：一种是进程之间竞争使用____资源，只能让它们逐个使用，这种现象称为____，是一种____关系；另一种是进程之间协同完成任务，在关键点上等待另一个进程发来的消息，以便协同一致，是一种____关系。

<ul>

<div>
<details>
  <summary> </summary>
  <ul>
    <li>

临界</li>
    <li>

互斥</li>
    <li>

竞争</li>
    <li>

协作</li>
  </ul>
</details>
</div>

</ul>

</ul>

---

以上内容严格遵循您的要求，保留了原有结构，挖空了关键词、公式和关键步骤，并在每个次级标题下以折叠块形式提供答案。折叠块中的内容使用 `<ul>` 和 `<li>` 标签，并为公式渲染预留了空行。

