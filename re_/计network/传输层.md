# 第5章传输层  

## 【考纲内容】  

（一）传输层提供的服务传输层的功能：传输层寻址与端口：无连接服务和面向连接服务（二）UDPUDP数据报：UDP检验（三）TCPTCP段：TCP连接管理：TCP可靠传输：TCP流量控制与拥塞控制  

## 【复习提示】  

- 传输层是整个网络体系结构中的关键层次
  - 要求掌握：传输层在计算机网络中的功能、工作方式及原理等
  - 掌握: UDP及TCP
    - 如首部格式、可靠传输、流量控制、拥塞控制、连接管理等

- **TCP**报文分析、连接管理、流量控制与拥塞控制机制
  - 出选择题、综合题的概率均较大
  - 因此要将其工作原理透彻掌握
    - 以便能在具体的题目中灵活运用


# 传输层提供的<span style="color: blue;">服务  

## 传输层的功能  

- 网络分层通信概述：
  - 数据链路层：提供链路上相邻节点之间的逻辑通信。
  - 网络层：提供主机之间的逻辑通信。
  - 传输层：为运行在不同主机上的进程之间提供逻辑通信。

- 传输层的定位：
  - 位于网络层之上、应用层之下。
  - 属于面向通信部分的最高层。
  - 也是用户功能中的最低层。

- 传输层的可靠性：
  - 即使网络层协议不可靠，传输层仍能为应用程序提供可靠服务。

- 传输层功能的存在：
  - 网络边缘的主机有传输层，用于端到端通信。
  - 路由器在转发分组时只用到下三层功能，不涉及传输层。

- 传输层的具体功能：
  - 见图5.1


### 应用进程之间的逻辑通信  

- 网络层与传输层的通信区别：
  - 网络层：
    - 通信的双方是两台主机，IP数据报首部包含这两台主机的IP地址。
  - 实际通信：
    - 两台主机中的应用进程之间的通信，称为端到端的逻辑通信。
  - IP协议：
    - 负责将分组送到目的主机，但分组仅停留在网络层，未交付给主机中的进程。
  - 传输层：
    - 通信的真正端点是主机中的进程。

### 复用和分用  

- 传输层的复用和分用：
  - 复用：发送方不同的应用进程可以使用同一个传输层协议传送数据。
  - 分用：**接收方**的传输层**剥去** 报文**首部**后，将数据正确交付到目的应用进程。
>attention
- 网络层的复用和分用：
  - 复用：发送方不同协议的数据都可以被封装成IP数据报发送。
  - 分用：接收方的网络层剥去首部后，将数据交付给相应的协议。

- 传输层逻辑通信示例：
  - ![传输层逻辑通信](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/63d78670549561819a300f6b9fc62e30df373cce7e510de756f34b967bc87bb0.jpg)
  - 图5.1展示了传输层为相互通信的进程提供逻辑通信。


### 检错检测  

- 传输层的差错检测：
  - 对收到的报文（**首部**和**数据**部分）进行差错检测。
  - TCP协议：
    - 接收方发现报文段出错，**要求**发送方**重发**该报文段。
  - UDP协议：
    - 接收方发现数据报出错，**直接丢弃**。

- **网络层**的限制：
  - IP数据报首部的检验和字段仅检验首部是否出错
  - **不检查** **数据部分**是否出错


### 提供面向连接和无连接的传输协议  

- 传输层的**作用**：
  - **屏蔽**低层网络核心的**细节**，如网络拓扑、路由协议等。
  - 为应用进程提供端到端的逻辑通信信道。
  - 逻辑通信信道的可靠性取决于传输层协议。

- 传输层协议与逻辑通信信道的关系：
  - 使用TCP协议时：
    - 网络不可靠，只提供尽最大努力服务。
    - 逻辑通信信道表现为全双工的可靠信道。
  - 使用UDP协议时：
    - 逻辑通信信道仍然是不可靠的。

- 网络层的限制：
  - 无法同时实现面向连接和无连接的协议。
  - 要么提供面向连接的服务，如虚电路。
  - 要么提供无连接服务，如数据报。


## 传输层的寻址与<span style="color: blue;">端口  

### 端口的作用  

- 端口的作用：
  - 应用层进程通过端口将数据交付给传输层。
  - 传输层通过端口将报文段数据交付给应用层相应进程。
  - 端口在传输层的作用类似于IP地址在网络层的作用。
  - IP地址标识主机，而端口标识主机中的应用进程。

- 协议栈各层的服务访问点：
  - 数据链路层：帧的“类型”字段。
  - 网络层：IP数据报的“协议”字段。
  - 传输层：“端口号”字段。
  - 应用层：“用户界面”。

- 端口与硬件端口的区别：
  - 协议栈中的端口是软件端口。
  - 软件端口是应用层协议进程与传输实体交互的地址。
  - 硬件端口是不同硬件设备交互的接口。
  - 传输层使用软件端口。


### ⚠️端口号  

- 应用进程通过端口号进行标识：
  - 端口号长度为16比特，可表示65536个不同的端口号。
  - 端口号只具有本地意义，标识本计算机应用层中的各进程。
  - 不同计算机的相同端口号没有联系。

- 端口号的分类：
  - 服务器端使用的端口号：
    - **熟知**端口号：
      - 数值为**0**~**1**023，IANA指派给重要应用程序。
    - **登记**端口号：
      - 数值为**1**024~**4**9151，供无熟知端口号应用使用，需在IANA登记。
  - **客户**端使用的端口号：
    - 数值为**4**9152~**6**5535，动态选择，故称短暂端口号。
    - 服务器根据客户端报文中的端口号发送数据。
    - 通信结束后，短暂端口号可供其他客户进程使用。

- 常用的熟知端口号示例：
  - ![熟知端口号图片](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e1544960964df4d9da3367ec224ca92c1bb3a1058ebde23539b5c5d0aa0c544a.jpg)
- 
  | 应用程序 | 端口号 |
  |---------|--------|
  | **FTP** | **21** |
  | SSH | 22 |
  | TELNET | 23 |
  | **SMTP** | **25** |
  | DNS | 53 |
  | HTTP | 80 |
  | **POP3** | **110** |
  | HTTPS | 443 |


### 套接字Socket  

- **网络标识**与**套接字**：
  <details>
  <summary>网络标识</summary>
  网络标识是机器在网络中的标志信息，它们使得网络设备能够被唯一识别和定位。在不同的网络层次中，有不同的标识类型：

  &emsp;&emsp;数据链路层：MAC地址 ← 设备在局域网（如以太网）中的&emsp;&emsp;物理地址
  &emsp;&emsp;网络层：IP地址 ← 标识 主机或路由器
  &emsp;&emsp;传输层：端口号 ← 区分 同一台主机上的不同 网络服务
  </details>

  - IP地址： 标识和区别不同的**主机**
    - 端口号： 标识和区分一台主机中的不同**应用进程**
  - 套接字(**Socket**)=(**IP**地址：**端口号**)
    - 唯一标识网络中的一个应用进程
    - 用于**识别**网络通信中的**端点**
      - 唯一的通信端点



  

- **网络通信**中的套接字使用：
  - 主机A → 主机B的报文
    - 报文包含目的端口号和源端口号
    - 源端口号是“返回地址”的一部分
  - 主机A ← 主机B，会使用主机A报文中的源端口号作为目的端口号。
  - 完整的返回地址
    - 主机A的 IP地址和源端口号
  - ```mermaid
    sequenceDiagram
    participant Host_A
    participant Host_B

    Note over Host_A,Host_B: Socket Communication
    
    Host_A->>Host_B: Message(Source Port, Destination Port)
    Note over Host_B: Records Source Port & IP
    
    Host_B->>Host_A: Reply(Using Host_A's Source Port as Destination)
    Note over Host_A,Host_B: Return Address = (Host_A IP : Source Port)


## 无连接服务与面向连接服务  

### TCP/IP传输层协议概述
- TCP/IP协议族在IP层之上使用了两个传输协议：
  - 面向连接的传输控制协议（TCP）
    - 采用TCP时，传输层向上提供的是一条全双工的可靠逻辑信道
  - 无连接的用户数据报协议（UDP）
    - 采用UDP时，传输层向上提供的是一条不可靠的逻辑信道

### 传输层协议特点
#### TCP特点与应用
- TCP提供面向连接的可靠服务
  - 通信双方在传送数据之前必须先建立连接
  - 然后基于此连接进行可靠数据传输
  - 数据传输结束后要释放连接
  - TCP不提供广播或多播服务
- TCP为实现可靠数据传输的措施
  - 确认
  - 流量控制
  - 计时器
  - 连接管理等
- TCP的开销
  - 协议数据单元的首部增大很多
  - 要占用许多的处理机资源
- TCP的适用场合
  - 主要适用于可靠性更重要的场合，如：
    - 文件传输协议（FTP）
    - 超文本传输协议（HTTP）
    - 远程登录（TELNET）等

#### UDP特点与应用
- UDP提供无连接的不可靠服务
  - 通信双方在传送数据之前不需要建立连接
  - 接收方的传输层在收到UDP用户数据报后，无须给发送方发回任何确认
- UDP在IP层之上的附加服务
  - 多路复用
  - 对数据的错误检查
- UDP的优势
  - 比较简单
  - 执行速度比较快
  - 实时性好
- UDP的应用包括
  - 小文件传送协议（TFTP）
  - DNS
  - SNIMP
  - 实时传输协议（RTP）

表5.1所示为一些典型互联网应用所用的TCP/IP应用层协议和传输层协议。  

表5.1一些典型互联网应用所用的TCP/IP应用层协议和传输层协议
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/31e145544e04ef12547e4868bcdfac5ddf5c7a417aa2b6348a1ff3570218580d.jpg)  

> attention:  

### 重要区别说明
#### IP数据报和UDP数据报的区别
- IP数据报
  - 在**网络层**要经过 **路由器** 的存储转发
- UDP数据报
  - 在**传输层**的**端到端**的逻辑信道中传输
  - **封装**成IP数据报在网络层传输时
    - UDP数据报的信息对路由器是不可见的

#### TCP和网络层虚电路的区别
- TCP报文段在传输层抽象的逻辑信道中传输，对路由器不可见
- 虚电路所经过的交换结点都必须保存虚电路状态信息
- 在网络层若采用虚电路方式，则无法提供无连接服务
- 而传输层采用TCP不影响网络层提供无连接服务

# <span style="color:blue;">U</span>DP <span style="font-size: 14px;">User Datagram Protocol  

## UDP数据报  

### UDP概述  
#### 定义
UDP（User Datagram Protocol，用户数据报协议）
- 互联网协议套件（TCP/IP）中的一种无连接的传输层协议
  - 无连接的、不可靠
- TCP提供面向连接的、可靠的数据传输服务
#### UDP的基本功能
- UDP仅在 IP层的数据报（网络层） 服务之上增加了两个最基本的功能：
  - 复用和分用
  - 差错检测

#### UDP的优点选择
- 为什么应用开发者宁愿在UDP之上构建应用，也不选择TCP？
- 既然TCP提供可靠的服务，而UDP不提供，则TCP总是首选吗？
  - 答案是否定的，因为有很多应用更适合用UDP

> pro：UDP协议的特点（2014）  

##### 主要优势
- **无须**建立**连接**
  - 因此UDP不会引入建立连接的时延
    - 试想若DNS运行在TCP而非UDP上，则DNS的速度会慢很多
  - HTTP使用TCP而非UDP，是因为对于基于文本数据的Web网页来说，可靠性是至关重要的
- 无连接状态
  - TCP需要在端系统中维护连接状态
    - 此连接状态包括接收和发送缓存、拥塞控制参数和序号与确认号的参数
  - UDP既不维护连接状态，也不跟踪这些参数
  - 因此，当某些专用服务器使用UDP时，一般都能支持更多的活动客户机
- UDP的**首部开销小**
  - **TCP**有**20B**的首部开销，而UDP仅有8B的开销
- UDP **无拥塞控制**
  - 因此网络中的拥塞**不会影响**源主机的**发送速率**
  - 某些实时应用要求源主机以稳定的速率发送数据，能容忍一些数据的丢失，但不允许有太大的时延
- UDP支持**多种通信**方式
  - 一对一、一对多、多对一和多对多的交互通信

#### UDP的应用场景
- UDP常用于**一次性**传输**较少数据**的网络应用
  - 如DNS、SNMP等
  - 因为对于这些应用，若采用TCP，则将为连接创建、维护和拆除带来不小的开销
- UDP也常用于多媒体应用
  - 如IP电话、实时视频会议、流媒体等
  - 显然，可靠数据传输对这些应用来说并不是最重要的
  - TCP的拥塞控制会导致数据出现较大的延迟，这是它们不可容忍的

#### UDP的可靠性与报文特性
##### 可靠性处理
- UDP不保证可靠交付，但这并不意味着应用对数据的要求是不可靠的
- 所有维护可靠性的工作可由用户在应用层来完成
- 应用开发者可根据应用的需求来灵活设计自己的可靠性机制

##### 报文处理特性
- UDP是面向报文的
  - 发送方处理：
    - UDP对应用层交下来的报文，在添加首部后就向下交付给IP层
    - 一次发送一个报文，既不合并，也不拆分，而是保留这些报文的边界
  - 接收方处理：
    - UDP对IP层交上来UDP数据报，在去除首部后就原封不动地交付给上层应用进程
    - **一次交付**一个完整的报文
- 报文大小选择
  - 报文**不可分割**，是UDP数据报处理的最小单位
  - 应用程序必须选择合适大小的报文
    - 若报文太长，UDP把它交给IP层后，可能会导致分片
    - 若报文太短，UDP把它交给IP层后，会使IP数据报的首部的相对长度太大
    - 两者都会降低IP层的效率

### UDP的首部格式  

#### 基本结构
- UDP数据报包含两部分：
  - 首部字段
  - 用户数据字段
- UDP首部有8B，由4个字段组成
  - 每个字段的长度都是2B，如图5.2所示

> pro：UDP首部格式及各字段意义（2018）  

#### 字段说明
- **源**端口
  - 源端口号
  - 在需要对方**回信时**选用，不需要时可用全0
- **目的**端口
  - 目的端口号
  - 这在终点**交付**报文时**必须使用**到

> pro： UDP首部的长度（2021)  

- 长度
  - UDP数据报的长度（包括**首部**和**数据**）
  - 其**min值**是**8**（仅有首部）
- 检验和
  - 检测UDP数据报在传输中是否有错
  - 有错就丢弃
  - 该字段是可选的，当源主机不想计算检验和时，则直接令该字段为全0

- 当传输层从IP层收到UDP数据报时，就根据首部中的目的端口，把UDP数据报通过应的端口，上交最后的终点一一应用进程，如图5.3所示

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/da63d7c9b93503146918383294c5c15589fdbdc37358c5de93970ddb49063021.jpg)  
图5.2UDP数据报格式  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a16cc2056a05a15b10c395b7339bc3ac5fd58814468389f9a0015024fd2be756.jpg)  
图5.3UDP基于端口的分用  

#### 端口处理
- 若接收方UDP发现收到的报文中的自的**端口号不正确**（即不存在对应于端口号的应用进程）
  - 则就**丢弃**该报文
  - 并由**ICMP**发送"端口不可达"**差错报文**给发送方
## ⚠️UDP<span style="color: orange;">检验</span>

### UDP<span style="color: orange;">检验</span><span style="color: green;">和</span>计算概述
- 在计算检验和时，要在UDP数据报之前增加12B的伪首部
  - 伪首部并不是UDP的真正首部
  - 只是在计算检验和时，临时添加在UDP数据报的前面，得到一个临时的UDP数据报
  - 检验和就是按照这个临时的UDP数据报来计算的
  - 伪首部既不向下传送又不向上递交，而只是为了计算检验和

- ![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/05fa857d9ae050353446295e04e96bef0c74167c8553e5cf4439dd5c06e12f8d.jpg)  
图5.4UDP数据报的首部和伪首部  

### UDP检验和特点
- UDP计算检验和的方法和计算IP数据报首部检验和的方法相似
- 不同点：
  - IP数据报的检验和只检验IP数据报的首部
  - UDP的检验和要将首部和数据部分一起检验

### UDP检验和<span style="color: green;">计算</span>方法
- 发送方计算步骤：
  - 首先把全0放入检验和字段并添加伪首部
  - 把UDP数据报视为许多16位的字串接起来
  - 若UDP数据报的数据部分不是偶数个字节，则要在末尾填入一个全0字节（但此字节不发送）
  - 按二进制反码计算出这些16位字的和
  - 将此和的二进制反码写入检验和字段，并发送
- 接收方计算步骤：
  - 把收到的UDP数据报加上伪首部（若不为偶数个字节，则还需要补上全0字节）
  - 按二进制反码求这些16位字的和
  - 当无差错时其结果应为全1，否则就表明有差错出现
  - 有差错时接收方就应该丢弃这个UDP数据报
- ![image](https://bluejedis.github.io/picx-images-hosting/image.4g4j0ss5qe.webp)
- ![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9a474cc8b394cdcf814dda506d8775a8ef67f54081079a382c666e8607f4cb96.jpg)  
图5.5计算UDP检验和的例子  
-
  ```mermaid
  flowchart TD
    subgraph 发送方
        A[开始] --> B[校验和字段填充0]
        B --> C[添加伪首部]
        C --> D[将UDP数据报视为16位字串]
        D --> E[若为奇数字节则末尾补0]
        E --> F[计算二进制反码和]
        F --> G[将反码写入校验和字段]
        G --> H[发送数据报]
    end

    subgraph 接收方
        I[接收数据报] --> J[添加伪首部]
        J --> K[若需要则补充字节]
        K --> L[计算二进制反码和]
        L --> M{结果是否全1?}
        M -->|是| N[接受数据报]
        M -->|否| O[丢弃数据报]
    end
  ```
- 
  ```mermaid
    flowchart TD
      subgraph Receiver
          I[Receive datagram] --> J[Add pseudo header]
          J --> K[Add padding if needed]
          K --> L[Calculate ones' complement sum]
          L --> M{Sum = all 1s?}
          M -->|Yes| N[Accept datagram]
          M -->|No| O[Discard datagram]
      end
      subgraph Sender
          A[Start] --> B[Fill checksum field<br> with zeros]
          B --> C[Add pseudo header]
          C --> D[Treat UDP datagram as <br>16-bit strings]
          D --> E[Add padding zero byte <br>if odd length]
          E --> F[Calculate ones' complement sum]
          F --> G[Write ones' complement to <br>checksum field]
          G --> H[Send datagram]
      end


  ```


> attention:  

### 注意事项
- 检验时，若UDP数据报部分的长度**不是偶数个字节**，则需填入一个全0字节，如图5.5所示
  - 但是此字节和伪首部一样，是不发送的
- 若UDP检验和检验出UDP数据报是**错误**的：
  - **丢弃**
  - **or交付**给上层，但是需要附上错误报告，即告诉上层这是错误的数据报
- 通过伪首部的作用：
  - 可以检查源端口号、目的端口号和UDP用户数据报的数据部分
  - 还可以检查IP数据报的源IP地址和目的地址

### 检验方法评价
- 这种简单的差错检验方法的校错能力并不强
- 好处是**简单**、处理速度**快** 

<span style="font-size: 45px;">  👻</span>
# <span style="color: orange;">T</span><span style="color: green;">C</span>P

## TCP协议的特点  

### TCP协议的主要特点
- TCP是在不可靠的IP层之上实现的可靠的数据传输协议，它主要解决传输的可靠、有序、无丢失和不重复问题。TCP是TCP/IP体系中非常复杂的一个协议，主要特点如下：  

#### 连接特点
- TCP是面向连接的传输层协议，TCP连接是一条逻辑连接
- 每一条TCP连接只能有两个端点，每一条TCP连接只能是一对一的

#### 可靠性
- TCP提供可靠交付的服务，保证传送的数据无差错、不丢失、不重复且有序

#### 通信方式
- TCP提供**全双工**通信，允许通信双方的应用进程在任何时候都能发送数据
  - TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双向通信的数据
    - 发送缓存用来暂时存放以下数据：
      - $\textcircled{\scriptsize{1}}$ 发送应用程序传送给发送方TCP准备发送的数据
      - $\circledcirc$ TCP已发送但尚未收到确认的数据
    - 接收缓存用来暂时存放以下数据：
      - $\textcircled{\scriptsize{1}}$ 按序到达但尚未被接收应用程序读取的数据
      - $\circledcirc$ 不按序到达的数据

#### 数据传输特点
- TCP是面向字节流的，虽然应用程序和TCP的交互是一次一个数据块（大小不等）
- 但TCP把应用程序交下来的数据仅视为一连串的无结构的字节流

#### 报文长度控制
- TCP和UDP在发送报文时所采用的方式完全不同
  - UDP报文的长度由发送应用进程决定
  - TCP报文的长度则根据接收方给出的窗口值和当前网络拥塞程度来决定
    - 若应用进程传送到TCP缓存的数据块太长，则TCP就把它划分得短一些再传送
    - 若太短，则TCP也可等到积累足够多的字节后再构成报文段发送出去
- 关于TCP报文的长度问题，后面会详细讨论

## TCP报文段

### TCP报文段的结构
- TCP传送的数据单元称为报文段
- TCP报文段既可以用来运载数据，又可以用来建立连接、释放连接和应答
- 一个TCP报文段分为首部和数据两部分
  - 整个TCP报文段作为IP数据报的数据部分封装在IP数据报中，如图5.6所示
  - 其首部的前20B是固定的
  - TCP首部最短为20B，后面有 $\bf{4N}$ 字节是根据需要而增加的选项
    - 长度为4B的整数倍

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4f25e5e7af600a926e06cfbeecdb4d247bc24f97f4e1b6d8267cb4459a094260.jpg)  
图5.6TCP报文段  

### TCP <span style="color: blue;">首部</span>字段
> pro：TCP报文段首部中各字段的分析（2012）  

#### 端口字段
- 源端口和目的端口
  - 各占2B
  - 分别表示发送方和接收方使用的端口号

> pro：TCP首部中序号、确认号的含义（2009、2016）  

#### 序号和确认号字段
- 序号
  - 占4B，范围为 $0{\sim}2^{32}\!-\!1$ ，共 $2^{32}$ 个序号
  - TCP连接中传送的字节流中的每个字节都要按顺序编号
  - 序号字段值指的是本报文段所发送的数据的第一个字节的序号
- 确认号
  - 占4B
  - 是期望收到对方下一个报文段的第一个数据字节的序号
  - 若确认号为 $N,$ 则表明到序号 $N\!-\!1$ 为止的所有数据都已正确收到

> pro：TCP首部的最小长度（2021)  

#### 控制字段
- 数据偏移
  - 占4位
  - 表示首部长度
  - "数据偏移"的单位是32位
  - TCP首部的最大长度为 $60\mathrm{B}$
- 保留
  - 占6位
  - 保留为今后使用，目前应置为0
- 控制位
  - <span style="color: purple;">URG</span>（紧急位）
  - <b><span style="color: green;">ACK</span></b>（确认位）
  - PSH（推送位）
  - RST（复位位）
  - <span style="color: orange;">SYN</span>（同步位）
  - **FIN**（终止位）

#### 其他字段
- 窗口
  - 占2B，范围为 $0{\sim}2^{16}\mathrm{-}1$
  - 窗口值告诉对方允许发送的数据量
- 检验和
  - 占2B
  - 检验范围包括首部和数据两部分
- 紧急指针
  - 占2B
  - 仅在 $\mathrm{{URG}}\!=\!1$ 时才有意义
- 选项
  - 长度可变，最长可达 $40\mathrm{B}$
  - TCP最初只规定了MSS选项
- 填充
  - 使整个首部长度是4B的整数倍

## ⚠️连接管理(3次握手、4次挥手)

### TCP连接的基本概念
- TCP是面向连接的协议
- 每个TCP连接都有三个阶段
  - 连接建立
  - 数据传送
  - 连接释放

### TCP连接建立要解决的问题
- 要使每一方能够确知对方的存在
- 要允许双方协商一些参数

### TCP连接的特点
- TCP连接的**端点**是**套接字**
- 每条TCP连接 唯一地被 **两个端点** **确定**
- 同一个IP地址可以有多个不同的TCP连接
- 同一个端口号可以出现在多个不同的TCP连接中
- TCP连接的建立采用客户/服务器模式
  - 主动发起连接建立的应用进程称为客户
  - 被动等待连接建立的应用进程称为服务器### TCP连接的建立  

### TCP连接的**建立**-“三次握手”


- ![image](https://bluejedis.github.io/picx-images-hosting/basic/image.41y3dmdsq7.webp)


- 过程：
  - **服务器**在连接建立前处于**LISTEN**（收听）状态，等待客户连接请求。

- 步骤：
   - 客户机发送连接请求：
     - 首部中的同步位 $\mathrm{{SYN}} = 1$。
     - 选择一个初始序号 ${\mathrm{seq}} = x$。
     - 进入SYN-SENT（同步已发送）状态。
  - 服务器收到连接请求并同意建立连接：
     - 发回确认报文段，$\mathrm{{SYN}} = 1$ 和 $\mathrm{{ACK}} = 1$。
     - 确认号 $\operatorname{ack} = x + 1$。
     - 选择自己的初始序号 ${\mathrm{seq}} = y$。
     - 进入SYN-RCVD（同步收到）状态。
  - 客户机收到确认后：
     - 发送确认报文段，$\mathrm{{ACK}} = 1$。
     - 确认号 $\mathsf{ack} = y + 1$。
     - 序号 ${\mathrm{seq}} = x + 1$。
     - 可以携带数据，若不携带数据则不消耗序号。
     - 进入ESTABLISHED（已建立连接）状态。

- 服务器收到客户机的确认后：
  - 也进入ESTABLISHED状态。

- 连接建立后：
  - 双方进入全双工通信状态，可以随时发送数据。
- pic
- ![image](https://bluejedis.github.io/picx-images-hosting/image.3yehbwb6vd.webp)
  ```mermaid
  sequenceDiagram
      participant Client
      participant Server
      Note over Server: LISTEN state
      
      Client->>Server: SYN=1, seq=x
      Note over Client: SYN-SENT state
      
      Server->>Client: SYN=1, ACK=1, seq=y, ack=x+1
      Note over Server: SYN-RCVD state
      
      Client->>Server: ACK=1, seq=x+1, ack=y+1
      Note over Client,Server: Both ESTABLISHED state
      
      Note over Client,Server: Full-duplex Communication

  ```

### TCP连接的**释放**-四次挥手

#### steps
##### pic
- ![image](https://bluejedis.github.io/picx-images-hosting/basic/image.7pbuse7qv.webp)
图5.8用"四次挥手"释放TCP连接  
- 


  ```PlantUML
  @startuml
  ' 设置注释背景颜色
  skinparam note {
    BackgroundColor #ffffff
  }

  ' 定义参与者
  participant Client
  participant Server

  ' 添加注释并指定背景颜色
  note over Client, Server
    Active Connection
  end note

  Client -> Server : FIN=1, seq=u
  note over Client
    FIN-WAIT-1 state
  end note

  Server -> Client : ACK=1, seq=v, ack=u+1
  note over Server
    CLOSE-WAIT state
  end note
  note over Client
    FIN-WAIT-2 state
  end note

  note over Client, Server #f96
    Half-closed state
  end note

  Server -> Client : FIN=1, seq=w, ack=u+1
  note over Server
    LAST-ACK state
  end note

  Client -> Server : ACK=1, seq=u+1, ack=w+1
  note over Client
    TIME-WAIT state (2MSL)
  end note
  note over Server
    CLOSED state
  end note

  note over Client
    CLOSED state after 2MSL
  end note
  @enduml
```

##### 第一步
- 客户机打算关闭连接时：
  - 向其TCP发送连接释放报文段，并停止发送数据
  - 主动关闭TCP连接
  - 该报文段的终止位FIN置1
  - **序号** $seq=\!u$，等于前面已传送过的数据的最后一个字节的序号加1
  - FIN报文段即使不携带数据，也要消耗掉一个序号
  - 客户机进入FIN-WAIT-1（终止等待1）状态
- TCP是**全双工**的：
  - 可以想象为一条TCP连接上有两条数据通路
  - 发送FIN的一端不能再发送数据，即关闭了其中一条数据通路
  - 但对方还可以发送数据


##### 第二步
- 服务器收到连接释放报文段后：
  - 发出确认，**确认号** $ack=\!u+1$
  - 序号 ${\mathfrak{s e q}}\!=\!v$，等于它前面已传送过的数据的最后一个字节的序号加1
  - 服务器进入CLOSE-WAIT（关闭等待）状态
- 此时：
  - C → S 方向的连接 **释放**了
  - TCP连接处于<b><span style="color: green;">半</span><span style="color: orange;">关闭</span></b>状态
  - 服务器若发送数据，客户机仍要接收
- 客户机：
  - 收到来自服务器的确认后，进入FIN-WAIT-2（终正等待2）状态
  - 等待服务器发出的连接释放报文段

> pro：TCP连接释放过程中状态的变化（2021）  

##### 第三步
- 若<span style="color: green;">sever</span>已经没有要向客户机发送的数据：
  - 通知TCP释放连接
  - 发出 $\mathrm{FIN}\!=\!1$ 的连接释放报文段
  - 报文段序号为 $w$（处于半关闭状态的服务器可能又发送了一些数据）
  - 重复发送上次已发送的确认号 $\operatorname{ack}\!=\!u\!+1$
  - 服务器进入LAST-ACK（最后确认）状态

> pro：TCP连接释放的过程及状态变化的时间分析（2016、2022）  

##### 第四步
- 客户机收到连接释放报文段后：
  - 必须发出确认
  - 进入TIME-WAIT（时间等待）状态
  - 该报文段的确认位ACK置1
  - 确认号 $\operatorname{ack}\!=\!w+1$
  - 序号 $\scriptstyle{\mathrm{seq}}\,=\,u\,+\,1$
- <span style="color: green;">sever</span>：
  - 收到该确认报文段后就进入CLOSED（连接关闭）状态
- <span style="color: blue;">client</span>：
  - 进入TIME-WAIT状态后，还要经过时间等待计 2 MSL后，才进入CLOSED状态 ← just 规定
    - 2MSL：**2倍**Maximum segments lifetime（）
  - 若服务器收到连接释放请求后不再发送数据：
    - 从客户机发出FIN报文段时刻算起，客户机释放连接的最短时间为 $1\,\mathrm{RTT}+2\,\mathrm{MSL}$
    - 服务器释放连接的==最短==时间为1.5RTT

#### 保活计时器
- TCP**设有**保活计时器：
  - 解决TCP双方建立连接后，客户主机突然故障的情况
  - **防止**服务器**一直等待**客户发来的数据

#### ⚠️TCP连接建立和释放**总结**
##### 建立连接（3步）
- SYN=1,seq=**x**
  - SYN=1,ACK=1,seq=y,ack=**x+1**
- ACK=1,seq=**x+1**,ack=y+1

##### 释放连接（4步）
- **FIN**=1,seq=**u**
  - ACK=1,seq=v,ack=**u+1** (被)
  - **FIN**=1,ACK=1,seq=*w*,ack=**u+1**(被)
- ACK=1,seq=**u+1**,ack=*w+1*

选择题喜欢考查（关于连接建立和释放的题目，<span style="color: green;">ACK</span>、<span style="color: orange;">SYN</span>、**FIN**=**1**），请牢记。
## TCP可靠传输  

- TCP提供可靠数据传输服务：
  - 在不可靠的**IP层**之上建立
  - 确保接收方读出的字节流与发送方发出的**字节流完全一致**

- TCP使用以下机制实现可靠性：
  - 检验：
    - 与UDP的检验机制相同
  - 序号：
    - 给每个字节分配序号，确保数据按序到达
  - 确认：
    - 接收方发送确认信息，告知发送方已成功接收哪些数据
  - 重传：
    - 发送方未在规定时间内收到确认，则重传数据


> pro: TCP的**确认机制**，**序号**和**确认号**的含义（2011、2012、2013）  

### 序号  
- TCP首部中的序号字段：
  - 作用是确保数据能按顺序提交给应用层。
  - TCP将数据视为一个无结构但有序的字节流。
  - 序号是针对传送的字节流而不是报文段。

- 数据流中的每个字节都有序号：
  - 序号字段值表示本报文段发送的数据的第一个字节的序号。
  - 举例说明：
    - 假设A和B建立了一条TCP连接。
    - A的发送缓存区有10个字节，序号从0开始。
    - 第一个报文段包含第0到第2个字节，则该TCP报文段的序号是0。
    - 第二个报文段的序号是3。


![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c26ac704f59eca3c51a2c5c371f1336b60b64260c34e4d2227d63e9f9712d1c8.jpg)  
图5.9A的发送缓存区中的数据划分成TCP段  

### 确认  
- TCP首部的确认号字段：
  - 表示接收方期望收到的下一个报文段的数据的第一个字节的序号。
  - 举例说明：
    - 如果接收方B已经收到了第一个报文段的数据，那么B希望下一个报文段从第3个字节开始，则B发送给A的报文段中的确认号字段应为3。

- 发送方缓存区：
  - 会继续存储已发送但未收到确认的报文段，以便在必要时重传。

- TCP默认使用累积确认：
  - 只确认数据流中至第一个丢失字节为止的字节。
  - 举例说明：
    - 如果接收方B收到了包含字节0到2和字节6到7的报文段，但未收到字节3到5，那么B仍在等待字节3及其后面的字节。
    - 在这种情况下，B发送给A的下一个报文段将确认号字段置为3，表示确认至字节2，并期待字节3。


### <span style="color: purple;">重传</span>  
  
- 有两种事件会导致TCP对报文段进行重传：超时和余ACK。  

#### <span style="color: orange;">超时</span>重传  
- TCP协议工作原理：
  - 每发送一个报文段时，TCP会设置一个超时计时器。
  - 如果在计时器到期之前没有收到报文段的确认，TCP会重传该报文段。

- 互联网环境下的挑战：
  - 由于互联网中IP数据报的路由选择变化很大，导致传输层的往返时延（RTT）也有很大的方差。

- 超时计时器的自适应算法：
  - TCP记录报文段的发送时间和收到确认的时间，这两个时间差即为往返时间（RTT）。
  - TCP维护着一个加权平均的RTT值，称为RTTS，它会根据新的RTT样本值进行调整。
  - 超时计时器设置的重传时间（RTO）应略大于RTTS，但不宜过大，以确保在报文段丢失时TCP能够迅速重传，避免过大的数据传输时延。


#### <span style="color: Violet;">冗余</span> ACK重传  
##### 超时重传的缺陷
- 超时触发重传存在的问题是超时周期通常很长

#####  <span style="color: Violet;">冗余</span> ACK机制
- 优势
  - 发送方通常可以在超时事件发生之前，通过检测冗余ACK来较好地识别丢包情况
- 定义
  - 冗余ACK是指对某个报文段进行**重复确认**的**ACK**，而发送方之前已经收到过该报文段的确认

##### 工作过程示例
- 场景设置
  - 发送方A发送了序号为1、2、3、4、5的TCP报文段，其中**2**号报文段在传输过程中**丢失**
- r方 行为
  - 由于2号报文段丢失，3、4、5号报文段对于接收方B来说是失序的
  - TCP规定，当接收方收到比期望序号大的失序报文段时
    - 会发送一个冗余ACK，指明下一个期望接收的字节序号
      - **3、4、5**号报文段到达B时，B发现它们不是期望接收的下一个报文段
      - 发送**3**个对1号报文段的**冗余ACK**
        - 表示期望接收2号报文段
- s方 响应
  - 当发送方A收到对同一个报文段的3个冗余ACK时
    - 可以判断2号报文段已经丢失，并立即对2号报文段进行重传
  - 这种技术称为 <span style="color: green;">快速</span><span style="color: purple;">重传</span>  

##### 应用范围
- 冗余ACK不仅在丢包检测中使用，还在拥塞控制中发挥作用，这将在后续内容中讨论


## TCP<span style="color: green;">流量</span>控制  

### 基本概念
- 流量控制的功能就是让发送方的发送速率不要太快，以便让接收方来得及接收，因此可以说流量控制是一个速度匹配服务（匹配发送方的发送速率与接收方的读取速率）

### 实现机制
#### TCP<span style="color: green;">滑动</span>窗口
- TCP使用滑动窗口sw 机制进行流量控制：
  - 这个机制在第3章中已经介绍过其基本原理。

- 流量控制的目的：
  - 确保发送方不会发送超过接收方处理能力的报文量。

- 实现方式：
  - 接收方维护一个**接收窗口**（rwnd），它表示接收方当前可接收的数据量。
    - 接收窗口的**大小** ← 接收方的接收缓存大小决定，并动态调整。
    - 接收方通过TCP报文段首部的"窗口"字段通知发送方其接收窗口的大小。
  - 发送方的发送窗口大小不能超过接收方提供的接收窗口值，这样可以避免发送方发送过快，导致接收方处理不过来。

- 结果：
  - 这种方式<span style="color: green;">限制</span>了**发送方**发送数据的**速率**，从而实现流量控制。


> pro：利用接收窗口实现流量控制的过程（2016、2021）  

#### 流量控制process
- 图5.10说明了如何利用滑动窗口机制进行流量控制
  - 接收方B
    - 可通过设置确认报文段首部中的窗口字段来将rwnd通知给A
      - **rwnd**即**接收方** 允许**连续接收**的**能力**
        - 单位是字节
  - 发送方A
    - 总是**根据**最新收到的**rwnd**值来限制自己发送窗口的大小
      - 保证A不会使B的接收缓存溢出
- process
  - 连接建立时，B告诉A："我的接收窗口rwnd $=4000$"
  - 接收方B进行了**三次流量控制**
    - 第一次把窗口减到rwnd $=300$
    - 第二次又减到rwnd $=100$
    - 最后减到rwnd $=\!0$

- ![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2ea4a8c799f964a7e96572594c00ed4f1536d705a7e0ede4d1ac19178b9e9412.jpg)  
图5.10利用可变窗口进行流量控制举例  



#### <span style="color: green;">持续</span>计时器机制
- TCP为每个连接设有一个持续计时器
  - 发送方 收到对方的**零窗口通知** ← **启动**持续计时器
  - 计时器**超时** → 发送零窗口**探测报文**段
    - 对方在**确认**探测报文段时 → 给出现在的窗口值
- 若窗口仍为零，发送方收到确认后重新设置持续计时器

### 与<span style="color: blue;">数据链路层</span>流量控制的区别
- 实现**范围**不同
  - 数据链路层：两个中间的相邻**结点**之间
  - 传输层：**端**到**端**，两个进程之间
- **窗口特性**不同
  - 数据链路层：**窗口大小** **不能动态变化**
  - 传输层：~ **可以**~

## TCP<span style="color: orange;">拥塞</span>控制  

### 基本概念
- 拥塞控制是指防止过多的数据注入网络，保证网络中的路由器或链路不致过载
- 出现拥塞时，端点并不了解拥塞发生的细节
- 对通信的端点来说，拥塞往往表现为通信时延的增加

### 与流量控制的区别
#### 控制范围
- 拥塞控制
  - 全局性过程
  - 涉及所有主机、路由器及相关因素
- 流量控制
  - 点对点通信量控制
  - 端到端问题

#### 相似之处
- 都通过控制发送方发送数据的速率来达到控制效果

#### 应用场景示例
- 高速链路场景
  - 链路速率：$10\mathrm{{Gb}}/s$
  - 大型机向PC传送：1Gb/s
  - 需要流量控制而非拥塞控制
- 多用户场景
  - 100万台PC同时传送：每台1Mb/s
  - 需要考虑网络负载承受能力

### 拥塞控制算法
- TCP有四种拥塞控制算法
  - 慢开始
  - 拥塞避免
  - 快重传
  - 快恢复

### 拥塞控制机制
#### 窗口控制
- 发送方需维持 **拥塞**窗口（cwnd）
- 拥塞窗口大小取决于网络拥塞程度
- 动态变化原则
  - 网络未拥塞：增大窗口
  - 网络出现拥塞：减小窗口

#### 发送窗口确定
- 发送窗口上限值计算：
  - 发送窗口的上限值 $=$ min[rwnd, cwnd]
- 影响因素说明
  - 接收窗口通过TCP报文首部窗口字段通知
  - 拥塞窗口由网络拥塞程度决定

#### 说明
- 假设条件
  - 数据为单方向传送，对方只传送确认报文
  - 接收方有足够大的缓存空间
  - 发送窗口大小由网络拥塞程度决定
- 度量单位
  - 采用 **最大报文段长度** MSS 作为拥塞窗口大小的单位

### 慢开始和拥塞避免  

#### <span style="color: orange;">慢</span>开始  
##### 基本思路与方法
- 当发送方刚开始发送数据时，因为并不清楚网络的负荷情况，若立即把大量数据注入网络，则有可能引发网络拥塞
- 具体方法是：
  - 先发送**少量**数据**探测**一下，若没有发生拥塞
    - 则适当增大拥塞窗口
  - 即由小到大逐渐增大拥塞窗口（即发送窗口）

> pro：慢开始算法的实现过程（2014、2015）  

##### 实现过程
- A向B发送数据，发送方先令cwnd $=1$ ，即一个MSS
- A发送第一个报文段，A收到B对第一个报文段的确认后，把cwnd从1增大到2
- A接着发送两个报文段，A收到B对这两个报文段的确认后，把cwnd从2增大到4，下次就可一次发送4个报文段
- 
  ```mermaid
    sequenceDiagram
      participant A
      participant B
      Note over A: cwnd = 1 MSS
      A->>B: Send 1 segment
      B->>A: ACK
      Note over A: cwnd = 2 MSS
      A->>B: Send 2 segments
      B->>A: ACK
      Note over A: cwnd = 4 MSS
      Note over A: Ready to send 4 segments
  ```
##### 特点说明
- 慢开始的"慢"并不是指拥塞窗口cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd $=1$
  - 每经过一个传输轮次（即往返时延RTT），cwnd就会加倍，即cwnd的值随传输轮次指数增长
  - 为防止cwnd增长过大而引起网络拥塞，需要设置一个慢开始门限ssthresh（网值）
    - 当慢开始一直把cwnd增大到一个规定的ssthresh时 → 拥塞避免算法

#### 拥塞<span style="color: green;">避免</span>算法  

> pro：慢开始和拥塞避免算法的实现过程/慢开始门限的作用（2017、2020、2023）  

##### 基本思路
- 让**拥塞窗口**cwnd**缓慢增大**
- 每经过一个往返时延RTT就把发送方的拥塞窗口cwnd加1，而不是加倍
- 使拥塞窗口cwnd按线性规律缓慢增长（即加法增大）

##### 算法执行规则
- 当cwnd$<$ssthresh时 → 慢开始算法
- 当cwnd $>$ ssthresh时，停止使用慢开始算法而改用拥塞避免算法
- 当cwnd $=$ ssthresh时，既可使用慢开始算法，又可使用拥塞避免算法（通常做法）

#### 网络拥塞的处理  

##### 处理方法
- 无论在慢开始阶段还是在拥塞避免阶段，只要发送方**判断** **网络**出现**拥塞**：
  - 首先把 慢开始**门限** **ssthresh**设置为
    - **出现拥塞时**的**发送方**的cwnd值的一半（但不能小于2）
  - 然后把**拥塞窗口**cwnd重新设置为1
  - 执行慢开始算法

*减小ssthresh，重新开始慢开始
> pro：慢开始和拥塞避免阶段的平均传输速率分析（2016、2023）  

##### 实现过程示例
- 初始时：
  - 拥塞窗口置为1，即cwnd $=1$
  - 慢开始门限置为16，即ssthresh $=16$

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a1450fb7a0a2a7cbc01c8a1dcf0c026c45cb4c81db6c5a4ba5ff6ac97202f4bd.jpg)  
图5.11慢开始和拥塞避免算法的实现过程  

> pro：慢开始/拥塞避免阶段拥塞窗口的变化分析（2016、2023）  

##### 窗口变化过程
- 慢开始阶段：
  - 发送方**每**收到一个对新报文段的确认**ACK**，就把拥塞窗口**cwnd+1**
    - 经过每个传输轮次（RTT），cwnd呈<span style="color: blue;">指数</span>规律增长
  - 当cwnd增长到慢开始门限ssthresh时（即当cwnd $=16$ 时），改用拥塞避免算法
    - cwnd按<span style="color: orange;">线性</span>规律增长

> pro：当网络超时时，慢开始和拥塞避免算法的实现过程（2009、2022）  

##### <span style="color: orange;">超时</span>处理
- 当cwnd $=24$ 时，网络出现超时：
  - 调整ssthresh值为12（即为超时时cwnd值的一半）
  - cwnd置为1
  - 执行慢开始算法
  - 当cwnd $=12$ 时，改为执行拥塞避免算法

> attention:  

##### 注意事项
- 在慢开始阶段：
  - 若2cwnd $>$ ssthresh，RT T cw nd s s thresh,而不等于2cwnd
  - 第16个轮次时cwnd $=8$ 、ssthresh $=12$ ，则第17个轮次时cwnd $=12$ ，而不等于16

##### 算法特点
- 使用了"乘法减小"和"加法增大"方法：
  - "**乘法减小**"：
    - 出现超时时，把ssthresh设置为当前拥塞窗口的一半
    - 网络频繁出现拥塞时，ssthresh值快速下降
  - "**加法增大**"：
    - 执行拥塞避免算法后，每个RTT后cwnd增加一个MSS大小
      - RTT（Round-Trip Time，往返时延）
    - 使拥塞窗口**缓慢增大**

##### 拥塞避免的局限性
- 拥塞避免并不能完全避免拥塞
- 拥塞避免是指在拥塞避免阶段把拥塞窗口控制为按线性规律增长

### <span style="color: green;">快<span style="color: purple;">重传</span><span style="color: gray;">和</span>快恢复  

#### 背景介绍
- 个别报文段在网络中丢失时，网络可能并未发生拥塞
  - 发送方未收到确认会产生超时，误认为网络发生拥塞
    - 错误启动慢开始算法会降低传输效率
- 快重传算法可让发送方尽早知道个别报文段的丢失

#### <span style="color: green;">快<span style="color: purple;">重传</span>  

> pro：快重传算法的原理、重传的时机（2019）  

##### 基本原理
- 使<span style="color: blue;">sender</span>尽快进行重传，不等超时计时器超时
- <span style="color: green;">receiver</span>要求：
  - **不要等待**自已发送数据时才进行捐带确认
  - **立即发送**确认
    - 收到失序报文段也要立即发出对已收到报文段的重复确认
- 发送方收到**3个**冗余**ACK** → 立即重传相应报文段

#### <span style="color: green;">快恢复  


##### 算法原理
- 发送方连续收到3个允余ACK时：
  - 执行"乘法减小"MD方法
    - 把ssthresh调整为当前cwnd的一半
      - 把cwnd值调整为当前cwnd的一半
  - 开始执行拥塞避免算法

##### 特点
- **跳过了**拥塞窗口cwnd从1起始的**慢开始**过程
- **直接**进入**拥塞避免**阶段

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/62dd33f004450128a3f441728d804d8b3a69264acb169f32cceb123861070b61.jpg)  
图5.12快恢复算法的实现过程  

#### 算法应用总结
- TCP**连接建立**和网络出现**超时**时：
  - 采用<span style="color: orange;">慢</span>开始  和拥塞<span style="color: green;">避免</span>算法
  - ssthresh = cwnd/2，cwnd $=1$
- 发送方收到3个冗余ACK时：
  - 采用<span style="color: green;">快<span style="color: purple;">重传</span><span style="color: gray;">和</span>快恢复 
  - ssthresh $=$ cwnd/2，cwnd $=$ ssthresh

#### 发送窗口swnd控制
- 流量控制：
  - <span style="color: blue;">sender</span>发送数据的量 ←  <span style="color: green;">receiver</span>决定
- 拥塞控制：
  - <span style="color: blue;">sender</span>自己通过检测网络状况来决定
- swnd大小：
  - 由流量控制和拥塞控制共同决定
  - 取决于rwnd和cwnd中**较小的值**


 
- - -
# 本章小结及疑难点  

1.MSS设置得太大或太小会有什么影响？  

- TCP规定最大报文段长度（MSS）的原因：
  - 不是由于接收方缓存可能放不下TCP报文段中的数据。
  - 实际上，MSS与接收窗口没有关系。

- MSS的考虑因素：
  - TCP报文段的数据部分至少需要加上40字节的首部（20字节的TCP首部和20字节的IP首部）才能组成一个IP数据报。
  - 若选择较小的MSS值，网络的利用率会很低。
    - 例如，当TCP报文段只含有1字节的数据时，IP层传输的数据报的开销至少有40字节。
    - 这样，网络的利用率不会超过1/41。
  - 在数据链路层还要加上一些开销，网络的利用率会进一步降低。

- MSS的最佳选择：
  - 应尽可能大，只要在IP层传输时不需要再分片。
  - 由于IP数据报所经历的路径是动态变化的，所以最佳的MSS很难确定。
  - MSS的默认值为536字节。
  - 因此，在互联网上的所有主机都应能接受的报文段长度是 $536 + 20 = 556$ 字节。


2.TCP使用的是GBN还是选择重传？  

- TCP与GBN协议的区别：
  - TCP使用累积确认，类似于GBN协议。
  - 但TCP不会丢弃正确收到但失序的报文段，而是缓存起来，并发送冗余ACK，指明期望收到的下一个报文段。这是TCP与GBN的一个显著区别。

- TCP重传机制：
  - 假设A发送了 $N$ 个报文段，其中第 $k$ 个报文段丢失，其余 $N-1$ 个报文段按序到达接收方B。
  - 在GBN协议中，A需要重传分组 $k$ 以及所有后继分组 $k+1, k+2, \cdots, N$。
  - 在TCP中，A通常只重传一个报文段，即报文段 $k$。

- TCP的选择确认（SACK）选项：
  - 提供了选择确认选项，使TCP在某种程度上类似于SR协议。
  - 因此，TCP的差错恢复机制可以看作是GBN和SR协议的混合体。

3.为什么超时事件发生时cwnd被置为1，而收到3个冗余ACK时cwnd减半？  

- 分析网络拥塞程度的两种情况：
  - 超时事件发生
  - 收到3个冗余ACK

- 超时事件发生：
  - 表明网络可能已经拥塞到连ACK报文段都无法传输。
  - 发送方只能等待超时后重传数据。
  - 因此，这种情况下的网络拥塞程度更严重。

- 收到3个冗余ACK：
  - 表明网络虽然拥塞，但至少ACK报文段还能被正确交付。
  - 发送方只需稍微抑制一下发送的数据量。

- 拥塞窗口（cwnd）的调整：
  - 超时事件发生时：
    - 网络拥塞严重，发送方应最大限度地抑制数据发送量。
    - 因此，cwnd置为1。
  - 收到3个冗余ACK时：
    - 网络拥塞程度较轻。
    - 因此，cwnd减半。


4.为什么不采用“两次握手”建立连接呢？  

- 使用“三次握手”建立TCP连接的原因：
  - 防止失效的连接请求报文段导致的错误。

- 情景模拟：
  - 客户A向服务器B发出TCP连接请求。
  - 第一个连接请求报文在网络中滞留。
  - A超时后重传连接请求。
  - B收到重传的请求后建立连接。
  - 数据传输完毕，连接断开。
  - 此时，滞留的连接请求到达B。

- 若采用“三次握手”：
  - B收到失效的连接请求后，向A发送确认报文段。
  - A不理睬，因为并未发出新的连接请求。
  - 连接建立失败，避免资源浪费。

- 若采用“两次握手”：
  - B收到失效的连接请求后，认为连接已经建立。
  - B等待A传输数据，但A并未请求连接。
  - B的资源被白白浪费。


5.为什么TCP在建立连接时不能每次都选择相同的、固定的初始序号？  

- TCP连接的建立和释放过程中可能遇到的问题：
  - 主机A和B频繁地建立连接、传送报文段、释放连接，然后重复这个过程。
  - 每次建立连接时，主机A选择相同的、固定的初始序号（例如1）。
    - 主机A发出的某些TCP报文段在网络中滞留较长时间，导致超时重传。
    - 一些滞留时间较长的TCP报文段最终到达主机B，但此时原连接已释放，而新的TCP连接已经建立。

- 可能导致的问题：
  - 新的TCP连接的主机B可能错误地接收在旧连接中传送的、已无意义的、过时的TCP报文段。
  - 这种情况可能发生是因为过时的TCP报文段的序号正好处在当前新连接所用的序号范围内。

- 解决方法：
  - 必须确保迟到的TCP报文段的序号不处在新连接所用的序号范围内。
  - TCP在建立新的连接时，选择的初始序号应与前面一些连接所用过的序号不同。
  - 不同的TCP连接不能使用相同的初始序号。
 

6.假定在一个互联网中，所有链路的传输都不出现差错，所有结点也都不会发生故障。试问在这种情况下，TCP的“可靠交付”功能是否就是多余的？  

不是多余的。
- TCP的“可靠交付”功能在互联网中至关重要，至少在以下情况下是必不可少的：
  - IP数据报独立选择路由，可能导致到达目的主机时失序。
  - 路由选择计算错误可能导致IP数据报在互联网中循环，直至TTL值降为零而被丢弃。
  - 路由器遇到大量通信时可能来不及处理所有数据报，导致部分数据报被丢弃。

- 这些问题都表明：
  - 必须依赖TCP的“可靠交付”功能来确保目的主机的目的进程能够正确接收到报文。
