 <span style="color: silver;">

#  <span style="color: silver;">above  

##  <span style="color: silver;">【考纲内容】  

（一）search的concept（二）顺序search法（三）分块search法（四）折半search法（五）树形search二叉搜索树：平衡二叉树：红黑树（六）B树及其基本操作、 $^{\mathrm{B+}}$ 树的concept（七）散列（Hash）表（八）search算法的分析及应用  

##  <span style="color: silver;">【知识框架】  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/04bba28557f8de0f60708124edff3cf56401157743f882b68284dea1f7097c04.jpg)  

##  <span style="color: silver;">【复习提示】  

- 重点掌握的知识点：

  - 折半搜索：
    - 掌握折半搜索的过程。
    - 构造判定树。
    - 分析平均搜索长度。

  - 二叉排序树、二叉平衡树和红黑树：
    - 了解它们的概念、性质和相关操作。
    - B树和B+树是本章的难点。

  - B树：
    - 掌握插入、删除和搜索的操作过程。

  - B+树：
    - 了解其concept和性质。

  - 散列搜索：
    - 掌握散列表的构造。
    - 掌握冲突处理方法及其处理过程。
    - 掌握搜索成功和搜索失败的平均搜索长度。
    - 掌握散搜索的特征和性能分析。
 

#  <span style="color: silver;">concept
##  <span style="color: silver;">基本定义
- search
  - 在数据集合中寻找满足某种条件的数据元素的过程
  - 结果分为两种：
    - 查找成功：找到满足条件的数据元素
    - search失败

- search表
  - 定义：用于search的数据集合，由同一类型的数据元素组成
  - 常见操作：
    - 查询符合条件的数据元素
    - 插入、删除数据元素

- 静态search表
  - 定义：只涉及search操作的表
  - 对应的动态search表：需要动态插入或删除的表
  - 适用方法：
    - 静态表：顺序search、折半search、散列search
    - 动态表：二叉排序树search、散列search

- 关键字
  - 定义：数据元素中唯一标识该元素的数据项值
  - 特点：基于关键字的search结果应该是唯一的

- 平均search长度
  - 定义：所有search过程中关键字比较次数的平均值
  - 数学表达式：$\mathrm{ASL}=\sum_{i=1}^{n}P_{i}C_{i}$
  - 参数说明：
    - n：search表长度
    - Pi：search第i个元素的概率(通常Pi=1/n)
    - Ci：找到第i个元素所需比较次数

#  <span style="color: silver;"><span style="color: LightSkyBlue;">顺序</span>search &  <span style="color: Gold;">折</span><span style="color: gray;">半</span>~ &  <span style="color: GreenYellow;">分块</span>~
<ul>

## <span style="color: silver;"><span style="color: LightSkyBlue;">顺序</span>~

###  <span style="color: silver;">concept
- 又称<span style="color: orange;">线性</span>search
- 适用范围：
  - <span style="color: LightSkyBlue;">顺序</span>表：通过数组下标递增扫描
  - <span style="color: RoyalBlue;">链</span>表：通过指针next扫描

### <span style="color: silver;"><span style="color: gray;">一般</span><span style="color: orange;">线性</span>表的顺序search
<ul>

#### <span style="color: silver;">基本思想
- from<span style="color: orange;">线性</span>表一<span style="color: LightSkyBlue;">端</span> 开始逐个检查 关键字
  - find <span style="color: GreenYellow;">满足</span>条件元素 → return位置
- till 表另一端 not find → return失败

#### <span style="color: LightSkyBlue;">算法

typedef struct{
    ElemType *elem;
    int TableLen;
}SSTable;

int Search_Seq(SSTable ST,ElemType key){
    ST.elem[0]=key;
    for(int i=ST.TableLen;ST.elem[i]!=key;--i);
    return i;
}


#### <span style="color: silver;"> <span style="color: Gold;">性能</span>分析
- search成功时平均长度：
  - $\operatorname{ASL}_{\mathfrak{h}(n;i)}=\sum_{i=1}^{n}P_{i}(n-i+1)$
  - 当Pi=1/n时：$\operatorname{PSL}_{n|k\rangle n|}{=}{\frac{n+1}{2}}$
- ~ 失败时：ASL=n+1

####  <span style="color: silver;"><span style="color: LightSkyBlue;">优</span><span style="color: GreenYellow;">缺</span>点
- 缺点：n较大时效率低
- 优点：
  - 存储方式灵活
  - 无序序要求
  - 适用于链表

### <span style="color: silver;"> <span style="color: GreenYellow;">有序</span><span style="color: orange;">线性</span>表的顺序search
<ul>

#### <span style="color: gray;">Feature
- 提前know 表 is <u>关键字有序</u>
- False:
  - search失败时 can <span style="color: GreenYellow;">提前</span>返回
  - 可降低search失败的 <span style="color: LightSkyBlue;">平均</span><span style="color: gray;">长度

> pro：有序线性表的顺序search的应用（2013）

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b9a556e5c788039f2fe0a08be26af8476e380c1fcd30a762adcbe9951bfa13c7.jpg)
↑ 有序顺序表上的顺序查找判定树

####  <span style="color: silver;"> <span style="color: Gold;">性能</span>分析
- search <span style="color: Gold;">成功</span>：same as <span style="color: gray;">一般</span>线性表
- search <span style="color: GreenYellow;">失败</span>：
  - 平均长度：$\operatorname{ASL}_{\mathcal{K}:n\times l}=\!\!\sum_{j=1}^{n}q_{j}(l_{j}-1)\!=\!\frac{1\!+2\!+\!\cdots\!+n\!+\!n}{n\!+\!1}\!=\!\frac{n}{2}\!+\!\frac{n}{n\!+\!1}$
  - 当n=6时：ASL=3.86

####  <span style="color: silver;">attention
- 思想 与 <span style="color: Gold;">折</span><span style="color: gray;">半</span>search不同
  - <span style="color: RoyalBlue;">链</span>式存储结构
  - 折半~ only<span style="color: LightSkyBlue;">顺序</span>存储结构
</ul>

##  <span style="color: Gold;">折</span><span style="color: gray;">半</span>~
<ul>

折半search又称二分search，它仅适用于有序的顺序表。  

> pro：分析对比给定search算法与折半search的效率（2016）  

### <span style="color: silver;">基本思想
- compare <span style="color: gray;">给</span><span style="color: GreenYellow;">定</span>值key with table中间位置的元素
  - if =
    - search成功
    - return该元素的存储位置
  - elif ≠
    - → 所需search的元素 in
      - 中间元素以外的
      - <span style="color: LightSkyBlue;">前</span>半 or <span style="color: GreenYellow;">后</span>半
<br>
  - eg
    - search表升序排列时
      - 若key大于中间元素
        - then 所search的元素only might在 <span style="color: GreenYellow;">后</span><span style="color: gray;">半</span>部分
        - 在缩小的<span style="color: gray;">范围</span>内 go on 同样的search
      - repeat the steps
        - till  <span style="color: GreenYellow;">Find</span>
        - or ensure表中no所需要search的元素
          - 则search不成功
          - return False

### <span style="color: LightSkyBlue;">算法</span>

int Binary Search(SSTable L,ElemType key){
    int low=0,high=L.TableLen-1,mid;
    while(low<=high){
        mid=(low+high)/2; //取中间位置
        if(L.elem[mid]==key) return mid; //search成功则返回所在位置
        else if(L.elem[mid]>key) high=mid-1; //从前半部分继续search
        else low=mid+1; //从后半部分继续search
    }
    return -1; //search失败，返回-1
}

<ul>

####  <span style="color: silver;">instruction
- 折半search算法 select 中间结点时
  - 向↑取整
  - ~ ↓ ~
- both can
    - but 每次search的取整方式必须相同

> pro：折半search的search路径的判断（2015）  

#### <span style="color: silver;">eg
- 已知11个元素的有序表{7,10,13,16,19,29,32,33,37,41,43}
- search值为11的过程：
  - 第一次search
    - 比较中间元素29与key
    - 11<29，在[low,mid-1]范围内继续search
  - 第二次search
    - 比较中间元素13与key
    - 11<13，在[low,mid-1]范围内继续search
  - 第三次search
    - 比较中间元素7与key
    - 11>7，在[mid+1,high]范围内继续search
  - 第四次search
    - 子表只含一个元素10
    - 10≠11，search失败

> pro：分析给定二叉树树形能否构成折半search判定树（2017）  
</ul>

###  <span style="color: silver;"> <span style="color: GreenYellow;">判定</span><span style="color: green;">树
- Feature：
  - node:
    - 每个圆形~ express 一个记录
    - 最下面的叶~为方形，表示search失败的区间
    - 每个~值均大于其左子~值
      - 且小于其右子~值
    - n个元素对应n个圆形非叶~和n+1个方形叶~
  - is 平衡二叉树

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a3c13d8b6e09e2161cf91b26befcb36e69ca849ba58fb230483c6eaa214215f5.jpg)  
↑描述折半查找过程的判定树

> pro：折半search的最多比较次数的分析（2010、2023）  

###  <span style="color: silver;"> <span style="color: Gold;">性能</span>分析
- 比较次数最多不超过树的高度
- 平均search长度：
  - $\mathrm{ASL}={\frac{1}{n}}\sum_{i=1}^{n}l_{i}={\frac{1}{n}}(1\times1+2\times2+\cdots+h\times2^{h-1})={\frac{n+1}{n}}\log_{2}(n+1)-1\approx\log_{2}(n+1)-1$
  - 时间复杂度为O(log₂n)
- 示例分析(图7.2)：
  - search成功ASL=(1×1+2×2+3×4+4×4)/11=3
  - search失败ASL=(3×4+4×8)/12=11/3

###  <span style="color: silver;"><span style="color: gray;">conditions
- only <span style="color: LightSkyBlue;">顺序</span>存储结构
- request 元素 按关键字  <span style="color: GreenYellow;">有</span><span style="color: LightSkyBlue;">序</span>排列
</ul>

##   <span style="color: silver;"><span style="color: GreenYellow;">分块</span>~  

<ul>

- also called as <span style="color: Gold;">索引</span><span style="color: LightSkyBlue;">顺序</span>search
- 顺序search和折半search各自的优点
  - 既  <span style="color: GreenYellow;">动态</span>结构
  - 又 <span style="color: RoyalBlue;">快速</span>search

### <span style="color: silver;">基本思想
- 将search表分为若干 <span style="color: gray;">子块</span>
  - 块内
    - can无序
  - 块间
    - 元素有序
      - 第一个块中
        - max关键字 ＜ 第二个块中 all recorded关键字
      - 第二个块中
        - max关键字 ＜ 第二个块中 all recorded关键字
      - ...
      - 以此类推
- 建立索引表
  - 包含各块最大关键字和各块第一个元素地址
  - 索引表按关键字有序排列

###  <span style="color: silver;"> <span style="color: Gold;">过程
- step1：在 **索引表** 中确定待查记录所在的<span style="color: gray;">块</span>
  - 可以<span style="color: LightSkyBlue;">顺序</span>~ or  <span style="color: Gold;">折</span><span style="color: gray;">半</span>~ 索引表
- step2：在<span style="color: gray;">块</span>内<span style="color: LightSkyBlue;">顺序</span>search

###  <span style="color: silver;">eg
- 关键码集合：{88,24,72,61,21,6,32,11,8,31,22,83,78,54}
- 按关键码值24,54,78,88分为4个块和索引表

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/76ded7a7f7a5d8bfa95e7e4f016ef281090b1deb3b0fa15e348952f286083f80.jpg)  

###  <span style="color: silver;"> <span style="color: Gold;">性能</span>分析
- <span style="color: LightSkyBlue;">平均</span>search长度
  - ASL = L₁ + Ls
    - L₁：索引search平均长度
    - Ls：块内search平均长度
- 均匀分块情况下
  - n长度表分为b块，每块s个记录
  - ASL = (b+1)/2 + (s+1)/2 = (s²+2s+n)/2s
  - 当s=√n时，ASL最小，为√n+1

###  <span style="color: silver;"><span style="color: LightSkyBlue;">优</span><span style="color: GreenYellow;">缺</span>点
- <span style="color: LightSkyBlue;">优</span>点：
  - 具有 <span style="color: GreenYellow;">动态</span>结构
  - <span style="color: RoyalBlue;">快速</span>search
  - 块内search范围小，效率高于<span style="color: LightSkyBlue;">顺序</span>search
-  <span style="color: GreenYellow;">缺</span>点：
   - 索引表 占用 <span style="color: gray;">额外</span>存储空间
   - 索引search 增加系统 <span style="color: gray;">开销</span>

</ul>
</ul>

#  <span style="color: silver;"><span style="color: green;">树</span>形search  
<ul>

## 二叉排序树（BST）  

- 构造一棵二叉排序树的目的并不是排序
  - 提高search、插入和删除关键字的速度
- 二叉排序树这种非线性结构也有利于插入和删除的实现


### 二叉排序树的定义  

> pro：二叉排序树的应用（2013）  

二叉排序树（也称二叉search树）或者是一棵空树，或者是具有下列特性的二叉树：  
- 若左子树非空，则左子树上所有结点的值均小于根结点的值
- 若右子树非空，则右子树上所有结点的值均大于根结点的值
- 左、右子树也分别是一棵二叉排序树

> pro：二叉排序树中结点值之间的关系（2015、2018）  

- 根据二叉排序树的定义:
  - 左子树结点值 $<$ 根结点值 $<$ 右子树结点值
  - 对二叉排序树进行中序遍历，可以得到一个递增的有序序列
  - 例如，图7.4所示二叉排序树的中序遍历序列为123468

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ce5699f8e763d0cb3b6dbd0974980ca0913f135c1e27622016155408d0e469aa.jpg)  
图7.4一棵二叉排序树  

### 二叉排序树的基本操作

#### 二叉排序树的search  

- search过程：
  - 从根结点开始，沿某个分支遂层向下比较
  - 若二义排序树非空：
    - 先将给定值与根结点的关键字比较
    - 若相等，则search成功
    - 若不等：
      - 小于根结点的关键字，则在根结点的左子树上search
      - 否则在根结点的右子树上search

- 非递归search算法：

BSTNode *BST Search(BiTree T,ElemType key)( 
  while(T!=NULL&&key  $!=$  T->data){ 
    if（key<T->data）T=T->1child；
    elseT=T->rchild; 
  }
  returnT;  


- search示例：
  - 在图7.4中search值为4的结点
    - 首先4与根结点6比较
    - 由于4小于6，在根结点6的左子树中继续search
    - 由于4大于2，在结点2的右子树中search，search成功

#### 二叉排序树的插入  

- 特点：
  - 树的结构通常不是一次生成的
  - 在search过程中，当树中不存在关键字值等于给定值的结点时再进行插入

- 插入过程：
  - 若原二义排序树为空，则直接插入
  - 否则：
    - 关键字k小于根结点值则插入到左子树
    - 关键字k大于根结点值则插入到右子树
  - 插入的结点一定是一个新添加的叶结点

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e89e6ea7f4ada4a4c481bc8b1e0ce1cafabd2e67868cbf3cc6ccf9d77c30fc9c.jpg)  
图7.5向二叉排序树中插入结点  

- 插入算法：

int BST Insert（BiTree &T，KeyType k）(
  if（T==NULL)(
    T = (BiTree)malloc（sizeof（BSTNode));
    T->data = k
    T->lchild = T->rchild = NULL;
    return1;
  else if(k=T->data)
    return 0;
  else if(k<T->data)
    return BST Insert(T->lchild,k);
  else
    return BST Insert（T->rchild,k);


#### 二叉排序树的构造  

> 命题追踪 构造二叉排序树的过程（2020）  

- 构造过程：
  - 从空树出发
  - 依次输入元素
  - 将元素插入到合适位置

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/359f08371aa754ac430fc9f29a85302372b2b4d9718c8e692c96b4d3a2472bf0.jpg)  
图7.6二叉排序树的构造过程  

- 构造算法：

void Creat BST（BiTree &T，KeyType str[],int n){
  T = NULL;
  int i = 0
  while(i < n)
    BSTInsert(T,str[i]);


#### 二叉排序树的删除  

- 删除过程：
  - 不能把以该结点为根的子树上的结点都册除
  - 必须重新链接断开的二叉链表
  - 确保二叉排序树的性质不会丢失

- 删除情况：
  1. 被删除结点是叶结点：
     - 直接删除
  2. 结点z只有一棵子树：
     - 让z的子树成为z父结点的子树
  3. 结点z有左、右两棵子树：
     - 令z的直接后继（或直接前驱）替代z
     - 从二叉排序树中删去这个直接后继（或直接前驱）

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/337a0835918349dc03e9c616897783190facdb482e06740c2ec450fd4cfe8a1b.jpg)  
图7.73种情况下的删除过程  

> pro：二叉排序树中删除并插入某结点的分析（2013）  

### 二叉排序树的search效率分析  

- 影响因素：
  - 主要取决于树的高度
  - 平衡二叉树：平均search长度为O(log₂n)
  - 单支树：平均search长度为O(n)

- 最坏情况：
  - 输入序列是有序的
  - 形成倾斜的单支树
  - 树的高度增加为元素个数n

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/54dd73fa59f89a754e5fd4e7dce8cf7124f8fa9db15eeeafeb8140073840c7bf.jpg)  
图7.8相同关键字组成的不同二叉排序树  

- 平均search长度比较：
  - 图7.8(a)：ASL = (1+2×2+3×4+4×3)/10 = 2.9
  - 图7.8(b)：ASL = (1+2+3+4+5+6+7+8+9+10)/10 = 5.5

- 与二分search比较：
  - 平均时间性能相似
  - 二分search判定树唯一
  - 二叉排序树search不唯一

- 维护表的有序性：
  - 二叉排序树：
    - 无须移动结点
    - 只需修改指针
    - 平均执行时间O(log₂n)
  - 二分search：
    - 对象是有序顺序表
    - 插入删除操作代价O(n)
  - 选择建议：
    - 静态search表：用顺序表+二分search
    - 动态search表：用二叉排序树

## 平衡二叉树  

### 平衡二叉树的定义  

#### concept
- 为了避免树的高度增长过快，降低二叉排序树的性能，规定：
  - 任意结点的左、右子树高度差的绝对值不超过1
  - 这样的二叉树称为平衡二叉树（Balanced BinaryTree）或AVL树
- 平衡因子：
  - 定义为结点左子树与右子树的高度差
  - 值只可能是-1、0或1

> pro：平衡二叉树的定义（2009）  

#### 完整定义
- 平衡二叉树可定义为：
  - 是一棵空树，或
  - 是具有以下性质的二叉树：
    - 左子树和右子树都是平衡二叉树
    - 左子树和右子树的高度差的绝对值不超过1

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/42460a711e8a2a7bcbc0a975d83fd52c42972810cdf1ff0354c8c9d9ea7aa463.jpg)  
图7.9平衡二叉树和不平衡的二叉树  

### 平衡二叉树的插入  

#### <span style="color: silver;">基本思想
- 插入（或删除）结点时：
  - 检查插入路径上的结点是否不平衡
  - 若不平衡：
    - 找到最近的平衡因子绝对值大于1的结点A
    - 调整以A为根的子树
    - 保持二叉排序树特性
    - 使之重新平衡

> pro：平衡二叉树中插入操作的特点（2015）  

>**notice:** 

每次调整的对象都是最小不平衡子树，即以插入路径上离插入结点最近的平衡因子的绝对值大于1的结点作为根的子树。图7.10中的虚线框内为最小不平衡子树。  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2209bb6cb24b8548ca118f9d5f40aa8899f7ed2e20e83c7fe0c0621ee7b842db.jpg)  
图7.10最小不平衡子树示意  

> pro：平衡二叉树的插入及调整操作的实例（2010、2019、2021）  

#### 调整规律
##### LL平衡旋转（右单旋转）
- 原因：在结点A的左孩子(L)的左子树(L)上插入新结点
- 过程：
  - A的平衡因子由1增至2
  - B向右上旋转代替A成为根结点
  - A向右下旋转成为B的右孩子
  - B的原右子树作为A的左子树

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0b95eff2c046b43bb6a18bc9a41beacc9de133dbf00206769ee68eb40f6d13e7.jpg)  
图7.11LL平衡旋转  

##### RR平衡旋转（左单旋转）
- 原因：在结点A的右孩子(R)的右子树(R)上插入新结点
- 过程：
  - A的平衡因子由-1减至-2
  - B向左上旋转代替A成为根结点
  - A向左下旋转成为B的左孩子
  - B的原左子树作为A的右子树

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5619c6d8436c1be38b63d259dcc65e0d4dfdd684c7e61b46edda1f39de83300f.jpg)  
图7.12RR平衡旋转  

##### LR平衡旋转（先左后右双旋转）
- 原因：在A的左孩子(L)的右子树(R)上插入新结点
- 过程：
  - A的平衡因子由1增至2
  - 先将C向左上旋转提升到B的位置
  - 再将C向右上旋转提升到A的位置

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e7462a89cd7274f34abe2309c0d8eedb6ed3d046096c03916695558689e50a9f.jpg)  
图7.13LR平衡旋转  

##### RL平衡旋转（先右后左双旋转）
- 原因：在A的右孩子(R)的左子树(L)上插入新结点
- 过程：
  - A的平衡因子由-1减至-2
  - 先将C向右上旋转提升到B的位置
  - 再将C向左上旋转提升到A的位置

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/044e9dac3e9118af06383caa4ab6770b19e9168a05e12eabac22b4702037505f.jpg)  
图7.14RL平衡旋转  

>**notice:** 

LR和RL旋转时，新结点究竟是插入C的左子树还是插入C的右子树不影响旋转过程，而图7.13和图7.14中以插入C的左子树中为例。  

> pro：构造平衡二叉树的过程（2013）  

#### 构造示例
- 关键字序列：15，3，7，10，9，8
- 过程：
  - 插入7后：
    - 最小不平衡子树根为15
    - 执行LR旋转
  - 插入9后：
    - 最小不平衡子树根为15
    - 执行LL旋转
  - 插入8后：
    - 最小不平衡子树根为7
    - 执行RL旋转

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/093f0bfc9d39ea0cacad9cfef59f6edf59790e2ed7a6692f2ea8792f99c3b8bf.jpg)  
图7.15平衡二叉树的生成过程  

### 平衡二叉树的删除  

#### 删除步骤
- 步骤1：用二叉排序树方法删除结点w
- 步骤2：若不平衡：
  - 从w向上回溯找第一个不平衡结点z
  - y为z的最高孩子结点
  - x为y的最高孩子结点
- 步骤3：对以z为根的子树进行平衡调整：
  - LL情况：y是z左孩子，x是y左孩子
  - LR情况：y是z左孩子，x是y右孩子
  - RR情况：y是z右孩子，x是y右孩子
  - RL情况：y是z右孩子，x是y左孩子

#### 与插入操作的区别
- 插入操作：
  - 仅需对z为根的子树调整
- 删除操作：
  - 调整z为根的子树后
  - 若高度减1，可能需要继续向上调整
  - 可能一直调整到根结点

#### 删除示例
- 以删除结点32为例：
  - 32为叶结点直接删除
  - 找到第一个不平衡结点44(z)
  - 78为y，50为x
  - 满足RL情况，执行先右后左双旋转

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7583531b4059bdd4839026ef84e33d80a0e80d188229f9a181a9205146f44d1b.jpg)  
图7.16平衡二叉树的删除  

### 平衡二叉树的search  

命题追踪指定条件下平衡二叉树的结点数的分析（2012）  

#### search过程
- 与二叉排序树相同
- 比较次数不超过树的深度

#### 结点数分析
- 深度为h的最少结点数nh：
  - n0=0, n1=1, n2=2
  - nh=nh-2+nh-1+1
  - 推导：n3=4, n4=7, n5=12,...
- 含n个结点的平衡二叉树：
  - 最大深度为O(log2n)
  - 平均search效率为O(log2n)

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/05527187cb555c4a8c169a1c9bb747cea9d526708b08d8e44da08c7188104059.jpg)  
图7.17结点个数n最少的平衡二叉树  

>**notice:** 

该sum可用于求解给定结点数的平衡二叉树的search所需的最多比较次数（或树的最大高度）。如在含有12个结点的平衡二叉树中search某个结点的最多比较次数？  

#### 最多结点数
- 深度为h的平衡二叉树中含有的最多结点数是满二叉树的情况
## 红黑树  

### 定义  

- 为了保持AVL树的平衡性，在插入和删除操作后，会非常频繁地调整全树整体拓扑结构代价较大
- 为此在AVL树的平衡标准上进一步放宽条件，引入了红黑树的结构

#### 红黑性质
- 每个结点或是红色，或是黑色的
- 根结点是黑色的
- 叶结点（虚构的外部结点、NULL结点）都是黑色的
- 不存在两个相邻的红结点（即红结点的父结点和孩子结点均是黑色的）
- 对每个结点，从该结点到任意一个叶结点的简单路径上，所含黑结点的数量相同
- 与折半search树和B树类似，为了便于对红黑树的实现和理解：
  - 引入了n+1个外部叶结点
  - 以保证红黑树中每个结点（内部结点）的左、右孩子均非空

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6302ead6b67560702595dc181ea237d148fcc79e5f41102d878fe7c0d83723be.jpg)  
图7.18一棵红黑树  

#### 黑高概念
- 从某结点出发（不含该结点）到达一个叶结点的任意一个简单路径上的黑结点总数称为该结点的黑高（记为bh）
- 黑高的概念是由性质⑤确定的
- 根结点的黑高称为红黑树的黑高

#### sum1：从根到叶结点的最长路径不大于最短路径的2倍
- 最短路径：全由黑结点构成
- 最长路径：由黑结点和红结点相间构成，红黑结点数量相同
- 例如图7.18中的6-2和6-15-18-20就是这样的两条路径

#### sum2：有n个内部结点的红黑树的高度h≤2log2(n+1)
- 证明过程：
  - 从根到叶结点的任何路径至少一半是黑结点
  - 根的黑高至少为h/2
  - 因此n≥2^(h/2)-1
  - 可得sum2结论

#### 红黑树vs AVL树
- 平衡程度比较：
  - 红黑树："适度平衡"
  - AVL树："高度平衡"
  - 红黑树降低到"任意结点左右子树高度相差不超过2倍"
- 应用场景：
  - 插入删除少，search多：适合AVL树
  - 其他情况：适合红黑树
- 实际应用：
  - 红黑树应用更广泛
  - C++的map和set用红黑树实现
  - Java的TreeMap和TreeSet用红黑树实现

### 红黑树的插入

#### 基本过程
- 与二叉search树插入类似
- 区别：插入后需要调整以满足红黑树性质
  - 通过重新着色
  - 或旋转操作

#### sum3：新插入结点初始着为红色
- 原因分析：
  - 若着为黑色：
    - 会导致路径多出一个黑结点
    - 破坏性质⑤
    - 调整麻烦
  - 着为红色：
    - 所有路径黑结点数量不变
    - 仅在出现连续红结点时需调整
    - 调整较简单

#### 插入过程详述
1. 基本插入：
   - 用二叉search树插入法
   - 将结点z着为红色
   - 若父结点黑色无需调整

2. 特殊情况处理：
   - 若z是根结点：
     - 将z着为黑色
     - 树的黑高增1
   
3. 需要调整的情况：
   - 前提条件：
     - z不是根结点
     - z的父结点z.p是红色
   - 分为三种情况：
     
     ##### 情况1：叔结点黑色且z是右孩子(LR)
     - 先左旋转换为情况2
     - z和父结点交换位置
     - 不影响黑高和性质④
     
     ##### 情况2：叔结点黑色且z是左孩子(LL)
     - 做一次右旋
     - 交换z原父结点和原爷结点颜色
     - 保持性质⑤
     - 消除连续红结点

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6141fe894e84b2ccf481ee1228f8dde35deaefe9f7c1b34e6857aad4fded5586.jpg)  
图7.19情况1和情况2的调整方式  

     ##### 情况3：叔结点是红色
     - 调整方式：
       - 父结点和叔结点着为黑色
       - 爷结点着为红色
       - 保持性质④和⑤
     - 循环处理：
       - 将爷结点作为新z继续
       - 指针z上移两层

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f5ccc56ed08320a072e5b4dc2d9a90053800244c9efa93005dfc054cd43073d8.jpg)  
图7.20情况3的调整方式  

#### 插入示例
- 以图7.21为例，展示插入5、4、12的过程：
  - 插入5：情况3处理
  - 插入4：RL到RR处理
  - 插入12：父结点黑色，无需调整

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/866a8fdbeb20f4f9f1017d2842fcadd4a0308566f5ba94047bdd131149297787.jpg)  
图7.21红黑树的插入过程  

### 红黑树的删除

#### 删除操作的影响
- 插入操作易导致连续红结点，破坏性质④
- 删除操作易造成黑高变化，破坏性质⑤

#### 基本删除过程
- 先执行二叉search树的删除方法
- 两个孩子的情况：
  - 找中序后继（或前驱）填补
  - 转换为删除后继结点
  - 后继结点至多一个孩子

#### 删除情况分类
##### 情况A：待删结点只有一个子树
- 两种可能：
  - 如图7.22所示
  - 子树必为红色结点

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/cab26f5079edd0a6447893d1eae634ce7de3b9df2de6eabbb5a6359254c2e364.jpg)  
图7.22只有右子树或左子树的删除情况  

##### 情况B：待删结点无孩子
- 红色结点：直接删除
- 黑色结点：
  - 设待删结点为y
  - x是替换结点
  - 删除后路径黑结点减1
  - 将x视为双黑结点处理

#### 双黑结点的处理
##### 情况1：兄弟结点w为红色
- 特点：
  - w有黑色左右孩子和父结点
- 处理：
  - 交换w和父结点颜色
  - 对父结点左旋
  - 转为情况2、3或4

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/60760335c4d8bc8941e363634d6e9120ff151d6b6f52818aa54fe7a239bac7ed.jpg)  
图7.23情况1的调整方式  

##### 情况2：w黑色且右孩子红色(RR)
- 处理：
  - 交换w和父结点颜色
  - w右孩子着黑
  - 父结点左旋
  - x变单重黑色

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0acf8e79a22ee8cdebb7c67323a375bbd51c9a6a9a72ff5305d1ec8bf75d6c37.jpg)  
图7.24情况2的调整方式  

##### 情况3：w黑色，左红右黑(RL)
- 处理：
  - 交换w和左孩子颜色
  - 对w右旋
  - 转为情况2

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/21ad3f76de9b3e1effcce1f8a03e3fcbb06283ab2c8c5ded905ca2ecfa56abc7.jpg)  
图7.25情况3的调整方式  

##### 情况4：w及其孩子都是黑色
- 处理：
  - 去掉x和w各一重黑色
  - x变普通黑色，w变红色
  - 父结点增加一重黑色
  - x上升一层继续循环

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9f77f4733c0cffc561dc2e545e593ce2eb429d88b4703d725d26d24d9778e963.jpg)  
图7.26情况4的调整方式  

#### 删除示例
- 以图7.27为例，展示删除5和15的过程：
  - 删除5：情况1到情况4
  - 删除15：LR到LL处理

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/16b040213c28dc879ebf6aede317568cd287ae396fdf09e05e9949dcf6c67b0e.jpg)  
图7.27红黑树的删除过程  

### B树和  $\mathbf{B}+$  树  

考研大纲对B树和 $^{\mathrm{B+}}$ 树的要求各不相同，重点在于考查B树，不仅要求理解B树的基本特点，还要求掌握B树的建立、插入和删除操作，而对 $^{\mathrm{B+}}$ 树则只考查concept。  

### B树及其基本操作  

所谓 $m$ 阶B树是所有结点的平衡因子均等于0的 $m$ 路平衡search树。  

> pro：B树的定义和特点（2009）  

#### B树的定义特性
- 一棵 $m$ 阶B树或为空树，或为满足如下特性的 $m$ 叉树：
  - 树中每个结点至多有 $m$ 棵子树，即至多有 $m-1$ 个关键字
  - 若根结点不是叶结点，则至少有2棵子树，即至少有1个关键字
  - 除根结点外的所有非叶结点至少有 $\lceil m/2\rceil$ 棵子树，即至少有 $\lceil m/2\rceil_{-1}$ 个关键字
  - 所有非叶结点的结构如下：

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/641123898fc54d168c81307aaa0f46a0aeb4dc3c39dc6bc0add67a795683e706.jpg)  

  - 其中：
    - $K_{i}$  $(i=1,2,\cdots,n)$ 为结点的关键字，且满足 $K_{1}<K_{2}<\cdots<K_{n}$
    - $P_{i}\,\,(i=0,\,1,\cdots,n)$ 为指向子树根结点的指针
    - 指针 $P_{i+1}$ 所指子树中所有结点的关键字均小于 $K_{i}$
    - $P_{i}$ 所指子树中所有结点的关键字均大于 $K_{i}$
    - $n~(\lceil m/2\rceil\!-\!1\!\leqslant\!n\!\leqslant\!m-1)$ 为结点中关键字的个数
  - 所有的叶结点都出现在同一层次上，并且不带信息

> pro：B树中关键字数和结点数的分析（2013、2014、2018、2021）  

#### B树的性质分析
- 以图7.28所示5阶B树为例：

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3296559c5d2d7110e03f8b45bfcbf4ee8b8931f234697bbe0eba579683969db7.jpg)  

- 主要性质：
  - 结点的孩子个数等于该结点中关键字个数加1
  - 根结点特性：
    - 无关键字时无子树(空树)
    - 有关键字时子树个数≥2
  - 非根非叶结点特性：
    - 至少有 $\scriptstyle{m/2}\,=\,\left\lceil5/2\right\rceil=3$ 棵子树
    - 至少有2个关键字
    - 至多有5棵子树和4个关键字
  - 关键字排序特性：
    - 从左到右递增有序
    - 左侧子树关键字小于当前关键字
    - 右侧子树关键字大于当前关键字
  - 叶结点特性：
    - 均在第4层
    - 代表查找失败位置

#### B树的查找
- 基本特点：
  - 与二叉排序树相似
  - 每个结点包含多个关键字
  - 进行多路分支决定

##### 查找操作的两个基本步骤
- 在B树中找结点(磁盘操作)
- 在结点内找关键字(内存操作)
  - 可用顺序查找或折半查找
  - 查找效率取决于目标结点层次数

##### 查找过程
- 从根结点开始
- 在当前结点有序表中查找
- 根据比较结果选择子树继续查找
- 直到找到目标或达到叶结点

#### B树的高度分析
##### 高度定义
- 不包括最后不带信息的叶结点层

##### 高度范围分析
- 最小高度情况：
  - 每个结点关键字数最多
  - 满足：$n\!\leqslant\!(m-1)(1+m+m^{2}+\cdots+m^{h-1})=m^{h}-1$
  - 得到：$h\geqslant\log_{m}\left(n+1\right)$

- 最大高度情况：
  - 每个结点关键字数最少
  - 层次结点数分析：
    - 第一层：至少1个结点
    - 第二层：至少2个结点
    - 第三层：至少 $2\left\lceil m/2\right\rceil$ 个结点
    - 第 $h+1$ 层：至少 $2(\lceil m/2\rceil)^{h-1}$ 个结点
  - 满足：$n+1\!\geqslant\!2(\lceil m/2\rceil)^{h-1}$
  - 得到：$h{\leqslant}\log_{\lceil m/2\rceil}((n+1)/2)+1$

#### B树的插入操作
> pro：通过插入操作构造一棵初始为空的B树（2020）  

##### 插入过程
- 定位阶段：
  - 使用B树查找算法
  - 找到插入的终端结点位置

- 插入阶段：
  - 关键字数限制：$[\lceil m/2\rceil\!-\!1,\,m\!-\!1]$
  - 两种情况：
    - 插入后关键字数 < m：直接插入
    - 插入后关键字数 > m-1：需要分裂

##### 结点分裂方法
- 基本步骤：
  - 创建新结点
  - 从中间位置分割关键字
  - 左部分保留在原结点
  - 右部分移至新结点
  - 中间关键字上移至父结点
- 特殊情况：
  - 父结点可能需要继续分裂
  - 分裂可能传播至根结点
  - 可能导致树高度增1

- 示例(m=3的B树)：

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/80d65ed644ea63d8e94f85979f930603e6eb9b46bb9c910cd6cf03ad6c8bf748.jpg)  

### B树的删除  

#### 删除操作概述
- B树的删除操作与插入操作类似，但更复杂
- 需确保删除后结点关键字个数≥m/2-1
- 可能涉及结点的"合并"问题

> pro：B树的删除操作的实例（2012、2022）  

#### 非终端结点的删除处理
- 当被删关键字k不在终端结点时：
  - 可用k的前驱(k')或后继替代
    - 前驱：k左侧子树中"最右下"元素
    - 后继：k右侧子树中"最左下"元素
  - 然后删除k'
  - k'必定在终端结点中

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7238b2b80bcf193f427d7371143169091e88dc7e89de6a71f0c30816046d808c.jpg)  

#### 终端结点的删除情况
##### 情况一：直接删除
- 条件：删除前关键字个数 ≥ ⌈m/2⌉
- 操作：直接删去该关键字

##### 情况二：借助兄弟结点
- 条件：
  - 删除前关键字个数 = ⌈m/2⌉-1
  - 相邻兄弟结点关键字个数 ≥ ⌈m/2⌉
- 操作：调整该结点、兄弟结点及父结点

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/215b6baf0ac411ac31105377425b16f9f12f9828b89f9a64b2c180cfee010990.jpg)  

##### 情况三：结点合并
- 条件：
  - 删除前关键字个数 = ⌈m/2⌉-1
  - 相邻兄弟结点关键字个数 ≤ ⌈m/2⌉-1
- 操作：与兄弟结点及父结点关键字合并

> pro：非空B树的search、插入、删除操作的特点（2023）  

#### 合并后的处理
- 双亲结点为根结点时：
  - 若关键字减至0，删除根结点
  - 合并后新结点成为根
- 双亲结点非根结点时：
  - 若关键字数减至⌈m/2⌉-2
  - 需与兄弟结点调整或合并
  - 重复直至符合B树要求

### B+树的concept  

> pro：B+树的应用场合（2017）  

#### B+树的定义条件
- m阶B+树需满足：
  1. 分支结点最多m棵子树
  2. 结点最小子树要求：
     - 非叶根结点至少两棵
     - 其他分支结点至少⌈m/2⌉棵
  3. 子树个数等于关键字个数
  4. 叶结点特性：
     - 包含全部关键字
     - 包含记录指针
     - 按大小顺序排列
     - 相邻叶结点相互链接
  5. 分支结点特性：
     - 仅包含子结点最大关键字
     - 包含指向子结点的指针

> pro：B树和B+树的差异的分析（2016）  

#### B+树与B树的主要差异
##### 结构差异
- 关键字与子树关系：
  - B+树：n个关键字对应n棵子树
  - B树：n个关键字对应n+1棵子树

##### 结点特性差异
- 关键字数量范围：
  - B+树：⌈m/2⌉≤n≤m
  - B树：⌈m/2⌉-1≤n≤m-1
- 关键字分布：
  - B+树：叶结点包含全部关键字
  - B树：关键字不重复出现

##### 功能特性差异
- 结点作用：
  - B+树：非叶结点仅做索引
  - B树：所有结点既存储又索引
- 链接结构：
  - B+树：叶结点形成链表
  - B树：结点间独立

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/db9dc115f173d19c088aab329b4f42f2125e735f6d5222eacbec4640c3e2ffab.jpg)  

#### B+树的操作特点
- 基本类似B树
- search特点：
  - 总是遍历到叶结点
  - 路径：根结点到叶结点
  - 支持两种search方式：
    - 顺序search
    - 多路search
 
</ul>

# 散列（Hash）表  
<ul>

## concept

### 关键概念
- 散列函数(哈希函数)
  - 定义：把search表中的关键字映射成对应地址的函数
  - 表示：$\operatorname{Hash}(\ker)=$ Addr
  - 地址类型：数组下标、索引或内存地址等

- 冲突
  - 定义：不同关键字映射到同一地址
  - 同义词：发生冲突的不同关键字
  - 处理：
    - 需设计良好的散列函数减少冲突
    - 设计冲突处理方法

- 散列表(哈希表)
  - 定义：根据关键字直接进行访问的数据结构
  - 特点：建立关键字和存储地址的直接映射
  - 性能：理想情况下search时间复杂度为O(1)

### 构造方法

#### 构造原则
- 定义域必须包含全部关键字
- 地址分布应尽可能均匀
- 计算过程应尽量简单

#### 直接定址法
- 方法：取关键字的线性函数值为散列地址
- 优点：计算简单，无冲突
- 适用：关键字分布基本连续的情况
- 缺点：关键字不连续时浪费空间

#### 除留余数法
- 方法：$H(\mathrm{kcy})=\mathrm{kcy}\,\%\,p$
- 要点：选择合适的p值
  - p不大于表长m
  - p最接近或等于m的质数
- 目标：使关键字等概率映射到任意地址

#### 数字分析法
- 适用：已知关键字集合
- 原理：
  - 分析r进制数各位上数码出现频率
  - 选取分布均匀的位作为散列地址
- 局限：更换关键字需重构散列函数

#### 平方取中法
- 方法：取关键字平方值的中间几位
- 特点：
  - 散列地址与关键字每位都相关
  - 地址分布较均匀
- 适用：关键字各位取值不均匀或位数较小

#### 方法选择
- 没有最优的通用方法
- 需根据具体关键字集合情况选择

## 处理冲突的方法

应该注意到，任何设计出来的散列函数都不可能绝对地避免冲突。为此，必须考虑在发生冲突时应该如何处理，即为产生冲突的关键字寻找下一个"空"的Hash地址。用 $H_{i}$ 表示处理冲突中第 $i$ 次探测得到的散列地址，假设得到的另一个散列地址 $H_{1}$ 仍然发生冲突，只得继续求下一个地址 $H_{2}$ ，以此类推，直到 $H_{k}$ 不发生冲突为止，则 $H_{k}$ 为关键字在表中的地址。

### 开放定址法

所谓开放定址法，是指表中可存放新表项的空闲地址既向它的同义词表项开放，又向它的非同义词表项开放。

#### 数学公式
- 递推公式：$H_{i}\,{=}\,(H(\mathrm{kcy})+d_{i})\,\%\,m$
  - H(key)为散列函数
  - $i=1,2,\cdots,k$ $(k{\leqslant}m-1)$
  - $m$ 表示散列表表长
  - $d_{i}$ 为增量序列

> pro：堆积现象导致的结果（2014）

#### 增量序列的四种取法
##### 1. 线性探测法
- 又称线性探测再散列法
- $d_{i}=1,2,\cdots,m-1$
- 特点：
  - 冲突发生时顺序查看下一个单元
  - 探测到表尾转到表首
  - 未填满时一定能找到空闲单元
- 缺点：
  - 可能造成元素堆积
  - 降低search效率

##### 2. 平方探测法
- 又称二次探测法
- $d_{i}=1^{2},-1^{2},2^{2},-2^{2},\cdots,k^{2},-k^{2}$
- 条件：
  - $k{\leqslant}m/2$
  - 表长m必须是4k+3的素数
- 优缺点：
  - 避免堆积问题
  - 不能探测所有单元，至少能探测一半

##### 3. 双散列法
- $d_{i}=i{\times}\mathrm{Hash}_{2}(\mathrm{ker})$
- 散列函数：
  - $H_{i}\,{=}\,(H(\mathrm{kcy})+i{\times}\mathrm{Hash}_{2}(\mathrm{kcy}))\:\%\:m$
  - 初始探测位置：$H_{0}\,{=}\,H(\mathrm{kcy})\;\%\,m$
  - i为冲突次数，初始为0

##### 4. 伪随机序列法
- $d_{i}\!=$ 伪随机数序列

> pro：散列表中删除部分元素后的search效率分析（2023）

>**notice:** 
采用开放定址法时，不能随便物理删除表中已有元素，否则会截断其他同义词元素的search路径。因此，要删除一个元素时，可以做一个删除标记，进行逻辑删除。但这样做的副作用是：执行多次删除后，表面上看起来散列表很满，实际上有许多位置未利用。

### 拉链法
- 又称链接法、chaining
- 原理：
  - 同义词存储在线性链表中
  - 链表由散列地址唯一标识
  - 头指针存放在散列表对应单元
- 适用：经常进行插入和删除的情况

例如，关键字序列为{19,14,23,01,68,20,84,27,55,11,10,79}，散列函数 $H(\mathrm{kcy})=\mathrm{kcy}\%13$ 用拉链法处理冲突，建立的表如图7.33所示（学完下节内容后，可以尝试计算本例的平均search长度ASL)。

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d1940764bbe5838b67ac8609d78335783a585aa5c7fc0cb6560c6e81692cd7da.jpg)

### 散列search及性能分析

> pro：散列表的构造及search效率的分析（2010、2018、2019）

#### search过程
- 初始化：Addr $\smile$ Hash (key)
- 步骤：
  1. 检测地址Addr位置
     - 无记录：返回失败
     - 有记录：比较key值
       - 相等：返回成功
       - 不等：执行步骤2
  2. 计算下一散列地址
     - 更新Addr
     - 返回步骤1

#### 实例分析
##### 示例数据
- 关键字序列：{19,14,23,01,68,20,84,27,55,11,10,79}
- 散列函数：H(key) = key%13
- 处理方法：线性探测

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/37af350f00080c15707906e376408f9d353587a88dd2c9322a9a8e4bad9e594b.jpg)

##### search过程示例
###### 值84的search
1. 初始地址：H(84)=6
2. 第一次冲突：H₁=(6+1)%16=7
3. 第二次冲突：H₂=(6+2)%16=8
4. 结果：成功，位置8

###### 值38的search
1. 初始地址：H(38)=12
2. 第一次冲突：H₁=(12+1)%16=13
3. 结果：失败，L[13]为空

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/becdbede030512e5e2ac3b81b756cc81d076a78bca8c20dbff207903db34e92a.jpg)

#### 性能分析
##### 平均search长度
- ASL计算：(1×6+2+3×3+4+9)/12=2.5

##### 影响因素
> 影响散列表search效率的因素（2011、2022）

1. 散列函数
2. 处理冲突的方法
3. 装填因子
   - 定义：$\alpha\!=\frac{表中记录数n}{散列表长度m}$
   - 特点：
     - ASL依赖于α而非n或m
     - α越大，冲突可能性越大
     - α越小，冲突可能性越小


#### 归纳总结  

##### 平均查找长度（ASL）计算
- 核心考查点：求平均查找长度（ASL）
  - 用于度量各种查找算法的性能
  - 基于查找结构
    - 由相同数据类型的记录或结点构成

###### 计算公式
- 查找成功的ASL：AS $\mathrm{~L~}_{n\in i}=\sum_{i=1}^{n}p_{i}c_{i}$
- 查找失败的ASL：A $\backslash\mathrm{SL}_{\mathbb{F}^{n\mathbb{W}}}=\sum_{j=0}^{n}q_{j}c_{j}$

###### 参数说明
- 已有数据元素：n个
- 查找成功情况
  - 每个元素查找概率：$p_{i}$
  - 数据比较次数：$c_{i}\ (i=1,2,\cdots,n)$
- 查找失败情况
  - 子集合元素查找概率：$q_{j}$
  - 数据比较次数：$c_{j}\ (j=0,\,1,\cdots,\,n)$

###### ASL考虑方式
- 综合考虑
  - 条件：$\sum_{i=1}^{n}p_{i}+\sum_{j=0}^{n}q_{j}=1$
  - 元素查找概率相等时：$p_{i}=q_{j}=\frac{1}{2n+1}$
- 分开考虑
  - 条件：$\sum_{i=1}^{n}p_{i}=1\;,\;\;\sum_{j=0}^{n}q_{j}=1$
  - 元素查找概率相等时：$p_{i}={\frac{1}{n}}\,,\;\;q_{j}={\frac{1}{n+1}}\,.$
- 实际应用
  - 多采用分开考虑
  - 原因：查找失败情况常被忽略
  - 注意：两种考虑方式计算结果不同，考试需仔细阅题
</ul></span>