# 树与二叉树above  

## 【考纲内容】  

（一）树的基本概念  

（二）二叉树  

二叉树的定义及其主要特征：二叉树的顺序存储结构和链式存储结构：二叉树的遍历：线索二叉树的基本概念和构造  

（三）树、森林树的存储结构：森林与二叉树的转换；树和森林的遍历  

（四）树与二叉树的应用哈夫曼（Huffman）树和哈夫曼编码：并查集及其应用  

## 【知识框架】  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d54ca676f546045fcd23c9d722b45ed4375e969ecfffd2829a916600c7dcb654.jpg)  

## 【复习提示】  

本章考查重点：
- 考试形式：
  - 选择题
  - 综合题
  - 树遍历相关的算法题

- 选择题必考内容：
  - 树和二叉树的基础知识：
    - 性质
    - 遍历操作
    - 转换
    - 存储结构
    - 操作特性
  - 特殊二叉树的定义和性质：
    - 满二叉树
    - 完全二叉树
    - 线索二叉树
    - 哈夫曼树
# 基本概念  

## 树的定义

### 基本定义
- 树是 $n$  $（n{\geqslant}0$ ）个**结点**的**有限集**
  - 当 $n=0$ 时，称为空树
  - 在任意一棵非空树中应满足:
    - 有且仅有一个特定的称为根的结点
    - 当 $n>1$ 时，其余结点可分为 $m$  $m\!>\!0$ ）个互不相交的有限集 $T_{1},T_{2},\cdots,T_{m}$ 
      - 其中每个集合本身又是一棵树，并且称为根的子树

### 特点
- 树是一种递归的数据结构
- 树是一种分层结构，具有以下特点：
  - 树的根结点没有前驱，除根结点外的所有结点有且只有一个前驱
  - 树中所有结点都可以有零个或多个后继
- 树的应用特征：
  - 适用于表示具有层次结构的数据
  - 某个结点最多只和上一层的一个结点有直接关系
  - 在 $n$ 个结点的树中有 $n\!-\!1$ 条边

## 基本术语

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/19c3d1765bb49ccc50656074b4b2909d9ab012f0a47d45e72e85165ba4b81d5f.jpg)  
图5.1树的树形表示  

### 结点关系术语
- 祖先、子孙、双亲、孩子、兄弟和堂兄弟
  - 祖先：从根到某结点路径上的所有其他结点
  - 子孙：某结点到叶子结点路径上的所有结点
  - 双亲：路径上最接近该结点的上层结点
  - **孩子**：某结点的**直接下层**结点
  - 兄弟：有相同双亲的结点
  - 堂兄弟：双亲在同一层的结点

### 结点特性术语
- 结点的度和树的度degree
  - 结点的度：该结点的孩子个数
  - 树的度：树中结点的最大度数
- 分支结点和叶结点
  - 分支结点：度大于0的结点
  - 叶结点：度为0的结点

### 结点位置术语
- 结点的深度、高度和层次
  - 层次：从根开始定义，根为第1层
  - 深度：结点所在的层次
  - 高度：以该结点为根的子树的高度

### 树的类型术语
- 有序树和无序树
  - 有序树：结点的各子树从左到右有次序
  - 无序树：结点的各子树位置可互换

### 路径相关术语
- 路径和路径长度
  - 路径：两结点间所经过的结点序列
  - 路径长度：路径上所经过的边的个数

> attention: 
因为树中的分支是有向的，即从双亲指向孩子，所以树中的路径是从上向下的，同一双亲的两个孩子之间不存在路径。  

### 森林术语
- 森林定义：$m$ ( $m{\gtrsim}0$ ）棵互不相交的树的集合
  - 树转森林：删去根结点
  - 森林转树：加上一个根结点

> pro：森林中树的数量、边数和结点数的关系（2016）

> attention: 
> 
上述概念无须刻意记忆，根据实例理解即可。考研时不大可能直接考查概念，而都是结合具体的题目考查。做题时，遇到不熟悉的概念可以翻书，练习得多自然就记住了。  

## 树的性质

### 结点数与度数关系
- 树的结点数 $n$ 等于所有结点的度数之和加1
  - 每个结点与其孩子由唯一边相连
  - 结点数等于边数之和加1

> pro：树中结点数和度数的关系的应用（2010、2016）

### 层次与结点数关系
- 度为 $m$ 的树中第 $i$ 层结点数
  - 至多有 $m^{i-1}$ 个结点（$i\!\geqslant\!1$）
  - 第1层至多1个结点
  - 第2层至多 $m$ 个结点
  - 第3层至多 $m^2$ 个结点

### 高度与结点数关系
- 高度为 $h$ 的 $m$ 叉树
  - 至多有 $(m^{h}\!-\!1)/(m\!-\!1)$ 个结点
  - 最小高度 $h$ 为 $\lceil\log_{m}(n(m-1)+1)\rceil$
  - 最大高度 $h$ 为 $n\!-\!m+1$

### 常用公式总结
> attention: 
综合以上几题，常用于求解树结点与度之间关系的有：  

-  总结点数 $=n_{0}+n_{1}+n_{2}+\ldots+n_{m}.$  

-  总分支数 $=1n_{1}+2n_{2}+\ldots+m n_{m}$ （度为 $m$ 的结点引出 $m$ 条分支）  

-  总结点数 $=$ 总分支数 $+1$  

这类题目常在选择题中出现，读者对以上关系应当熟练掌握并灵活应用。
# 二叉树的概念  

## 二叉树的定义及其主要特性  

### 二叉树的定义  

#### 基本定义
- 二叉树是一种特殊的树形结构
  - 每个结点至多只有两棵子树
  - 二叉树的子树有左右之分，其次序不能任意颠倒

#### 递归定义
- 二叉树是 $n$ ($n{\geqslant}0$) 个结点的有限集合：
  - 或者为空二叉树，即 $n=0$
  - 或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成
    - 左子树和右子树又分别是一棵二叉树

#### 基本特征
- 二叉树是有序树
  - 左、右子树颠倒会成为不同的二叉树
  - 即使只有一棵子树，也要区分左右

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a9c401a0608c49b1b443c3b48c43f6a1ee4376c25cae2385958287b1cf7a89d5.jpg)  
图5.2二叉树的5种基本形态  

#### 与度为2的有序树的区别
- 结点数量要求不同
  - 度为2的树至少有3个结点
  - 二叉树可以为空
- 孩子次序区分方式不同
  - 度为2的有序树：孩子左右次序相对于另一个孩子而言
  - 二叉树：孩子次序是确定的，需明确左右次序

### 几种特殊的二叉树  

#### 满二叉树
- 定义：高度为 $h$，且有 $2^h\!-\!1$ 个结点的二叉树
- 特点：
  - 每层都含有最多的结点
  - 叶结点都在最下层
  - 除叶结点外每个结点度数为2
- 编号规则：
  - 从根结点(编号为1)开始
  - 自上而下，自左向右
  - 编号为 $i$ 的结点关系：
    - 双亲：i/2
    - 左孩子：2i
    - 右孩子：2i+1

#### 完全二叉树
- 定义：高度为 $h$、有 $n$ 个结点的二叉树，其结点与高度为 $h$ 的满二叉树中编号1~n的结点一一对应

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/bdec3149d9bd6e25b24dc7017ddcb7cbf0abc9f5ff55b78c04ee30a8463a64aa.jpg)  
图5.3两种特殊形态的二叉树  

- 特点：
  - 结点性质：$i{\leqslant}\lfloor n/2\rfloor$ 为分支结点，否则为叶结点
  - 叶结点分布：只可能在最大的两层上出现
  - 度为1的结点：最多一个，且只有左孩子
  - 编号规律：编号i后的叶结点性质
  - 分支结点特征：
    - n为奇数：每个分支结点都有左右孩子
    - n为偶数：最大编号分支结点只有左孩子

#### 二叉排序树
- 特点：
  - 左子树结点关键字小于根结点
  - 右子树结点关键字大于根结点
  - 左右子树各自也是二叉排序树

#### 平衡二叉树
- 定义：任意结点的左右子树高度差绝对值不超过1

> pro：正则 $\pmb{k}$ 叉树树高和结点数的关系的应用（2016）  

#### 正则二叉树
- 定义：每个分支结点都有2个孩子
- 特点：只有度为0或2的结点

### 二叉树的<span style="color: orange;">性质  

#### 性质1：叶结点数与度为2的结点数关系
- 公式：$n_0\!=\!n_2+1$
- 证明过程：
  - 设度为0,1,2的结点数分别为 $n_0,n_1,n_2$
  - 总结点数 $n\!=\!n_0+n_1+n_2$
  - 分支数 $B\!=\!n_1+2n_2$
  - 结点与分支关系：$n\,{=}\,B+1$
  - 推导得：$n_0\!=\!n_2+1$

> attention: 
该性质经常在选择题中涉及，希望读者牢记并灵活应用。  

#### 性质2：层次结点数关系
- 第 $k$ 层最多有 $2^{k-1}$ 个结点（$k\!\geqslant\!1$）
- 具体分布：
  - 第1层：最多1个结点
  - 第2层：最多2个结点
  - 规律：形成公比为2的等比数列

#### 性质3：高度与结点数关系
- 高度为 $h$ 的二叉树最多有 $2^h\!-\!1$ 个结点（$h{\geqslant}1$）

> attention: 
性质2和性质3还可以拓展到 $m$ 叉树的情况，即 $m$ 叉树的第 $k$ 层最多有 $m^{k-1}$ 个结点，高度为 $h$ 的 $m$ 叉树至多有 $(2^h\!-\!1)/(m\!-\!1)$ 个结点。  

#### 性质4：完全二叉树的编号特性
- 分支结点判定：$i{\leqslant}\lfloor n/2\rfloor$
- 叶结点分布：最大两层
- 度为1结点特性：最多一个且只有左孩子
- 编号规律：结点i后的叶结点性质
- 分支结点特征：
  - n为奇数：都有左右孩子
  - n为偶数：最大编号分支结点只有左孩子
- 结点关系：
  - 双亲编号：$\lfloor i/2\rfloor$（i>1）
  - 左孩子：2i
  - 右孩子：2i+1
- 层次计算：$\lfloor\log_2i\rfloor+1$

#### 性质5：完全二叉树的高度
- 公式：$\lceil\log_2(n+1)\rceil$ 或 $\lfloor\log_2\!n\rfloor+1$
- 证明：
  - 设高度为 $h$
  - $2^{h-1}<n+1\leqslant2^h$
  - 得出：$h=\lceil\log_2(n+1)\rceil$ 或 $h\!=\!\lfloor\log_2\!n\rfloor\!+1$

## 二叉树的存储结构  

### 二叉树的存储结构

#### 顺序存储结构

- 基本概念
  - 用连续存储单元依次存储完全二叉树结点元素
  - 按自上而下、自左至右的顺序存储
  - 编号为i的结点存储在一维数组下标i-1的分量中

- 适用情况
  - 完全二叉树和满二叉树最为适合
  - 优点：
    - 节省存储空间
    - 可通过下标确定结点位置和关系

> pro：特定条件下二叉树树形及占用存储空间的分析（2020）  

- 一般二叉树的存储
  - 需要添加空结点以对应完全二叉树
  - 存在问题：
    - 最坏情况下存储效率低
    - 单支树高度h需要近2^h-1个存储单元

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/1f9ce9f8887f82c175b169c3e33e125a549ecefdeb97d371167ce7f968695b4a.jpg)  
图5.4二叉树的顺序存储结构  

> attention: 
建议从数组下标1开始存储树中的结点，保证数组下标和结点编号一致。  

#### 链式存储结构

- 基本特点
  - 采用链表结点存储
  - 空间利用率高于顺序存储

- 结点结构
  - 包含至少3个域：
    - 数据域(data)
    - 左指针域(lchild)
    - 右指针域(rchild)

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ee0d9ff6fcf5b36a43fcb3916082d9458841fc02d0057838e76bb0fbd67621ad.jpg)  
图5.5二叉树链式存储的结点结构  

- 存储形式
  - 可以是二叉链表
  - 可扩展为三叉链表（增加父结点指针）

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/cc755ffdb13a30c0f9b94e9364d417701c44e786b9f5aaa944f9db48ce9145e5.jpg)  
图5.6二叉链表的存储结构  

- 代码实现

typedef struct BiTNode{
    ElemType data;    //数据域
    struct BiTNode *lchild, *rchild;    //左、右孩子指针
}BiTNode, *BiTree;


- 重要特性
  - 选择考虑因素：
    - 二叉树的形态
    - 需要进行的运算
  - n个结点的二叉链表含有n+1个空链域

#  二叉树的遍历和线索二叉树  

## 二叉树的遍历

三义树的遍历是指按某条搜索路径访问树中每个结点，使得每个结点均被访问一次，而且仅被访问一次。由于二叉树是一种非线性结构，每个结点都可能有两棵子树，因此需要寻找一种规律，以便使二叉树上的结点能排列在一个线性队列上，进而便于遍历。

pro：二叉树遍历方式的分析（2009、2011、2012）pro：（算法题）二叉树遍历的相关应用（2014、2017、2022）

由二叉树的递归定义可知，遍历一棵二叉树便要决定对根结点N、左子树L和右子树R的访问顺序。按照先遍历左子树再遍历右子树的原则，常见的遍历次序有先序（NLR）、中序（LNR）和后序（LRN）三种遍历算法，其中"序"指的是根结点在何时被访问。

### 遍历方式
#### 先序遍历（PreOrder）
- 遍历规则：若二叉树为空，则什么也不做；否则
  - 1）访问根结点
  - 2）先序遍历左子树
  - 3）先序遍历右子树

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/bb476333d53f3ddbbf63ed5dee671597c8d51d49b039178da94fd12e16d3cb6c.jpg)

##### 递归算法实现

void PreOrder（BiTree T){
    if（T!=NULL){
        visit(T);  //访问根结点
        PreOrder(T->lchild);  //递归遍历左子树
        PreOrder（T->rchild);  //递归遍历右子树


#### 中序遍历（InOrder）
- 遍历规则：若二叉树为空，则什么也不做；否则
  - 1）中序遍历左子树
  - 2）访问根结点
  - 3）中序遍历右子树

pro：中序序列中结点关系的分析（2017）

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5a7a1e8979699afa63f476d125c173136bfd388f5b6d78a36bb8bedfd9462925.jpg)

##### 递归算法实现

void InOrder（BiTree T）{
    if（T!=NULL){
        InOrder（T->lchild);  //递归遍历左子树
        visit(T);  //访问根结点
        InOrder(T->rchild);  //递归遍历右子树


#### 后序遍历（PostOrder）
- 遍历规则：若二叉树为空，则什么也不做；否则
  - 1）后序遍历左子树
  - 2）后序遍历右子树
  - 3）访问根结点

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/83d65a43ce1d35fa50d330ff9b10a6426b21fdcc73aff5dc92b3166bd085a05b.jpg)

##### 递归算法实现

void PostOrder（BiTree T){
    if（T!=NULL){
        PostOrder(T->lchild);  //递归遍历左子树
        PostOrder(T->rchild);  //递归遍历右子树
        visit(T);  //访问根结点


### 算法性能分析
- 时间复杂度
  - 每个结点都访问一次且仅访问一次，所以时间复杂度都是O(n)
- 空间复杂度
  - 递归工作栈的栈深恰好为树的深度
  - 最坏情况：二叉树是有n个结点且深度为n的单支树，空间复杂度为O(n)
### 递归算法和非递归算法的转换  

> attention: 

非递归遍历算法的难度较大，统考对非递归遍历算法的要求通常不高。  

#### 递归执行过程分析
- 三种遍历算法的递归执行过程相同（抹去visit()语句）
- 递归执行过程说明：
  - 向下箭头：更深层递归调用
  - 向上箭头：递归调用返回
  - 标记符号：
    - 三角形：先序访问输出
    - 圆形：中序访问输出
    - 方形：后序访问输出

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7a51d5bf37d72f50eb146aea747131d612db4759b8ba5278104c5bcb2f119547.jpg)  

#### 非递归实现分析
##### 中序遍历非递归实现
- 借助栈的实现思路：
  - 沿左孩子依次入栈直到为空
  - 栈顶元素出栈并访问
  - 处理右子树

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/bea97dfd359f4fa23e37774cbc37c392186c7ec83025a3781c4431d1c371b0ee.jpg)  

##### 先序遍历非递归实现
- 基本思想与中序类似
- 区别：访问结点操作在入栈前进行

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/551c0911a426ccd11fb7cd94140b7a15d86c77102cd7c3edad266c7d8f1fd06c.jpg)  

##### 后序遍历非递归实现
- 实现难度最大
- 访问条件：
  - 左右子树都已访问
  - 左子树在右子树前访问
- 实现思路：
  - 从根结点开始入栈
  - 沿左子树搜索直到无左孩子
  - 出栈条件：
    - 右子树为空
    - 右子树刚访问完

### 层次遍历  

#### 层次遍历基本概念
- 遍历顺序：
  - 自上而下
  - 从左至右
  - 按层次顺序访问结点

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/fcc01cff756f99920e69dd2b2480873979105c906664f3b0bf11376b861896dd.jpg)  

#### 层次遍历算法实现
- 借助队列实现
- 基本步骤：
  - 根结点入队
  - 队列非空时：
    - 队头结点出队并访问
    - 左孩子存在则入队
    - 右孩子存在则入队
- 算法代码：
  
  void LevelOrder（BiTree T) 
  InitQueue（Q);
  BiTree p; 
  EnQueue（Q,T）;
  while(!IsEmpty(Q)){ 
      DeQueue（Q,p）;
      visit(p);
      if(p->lchild！=NULL) 
          EnQueue(Q,p->lchild);
      if(p->rchild!=NULL) 
          EnQueue(Q,p->rchild);
  }
  

> attention: 

遍历是二叉树各种操作的基础，例如对于一棵给定二叉树求结点的双亲、求结点的孩子、求二叉树的深度、求叶结点个数、判断两棵二叉树是否相同等。所有这些操作都是在遍历的过程中进行的，因此必须掌握二叉树的各种遍历过程，并能灵活运用以解决各种问题。
### 由遍历序列构造二叉树  

> pro：先序序列对应的不同二叉树的分析（2015）  

#### 基本概念
- 对于给定二叉树：
  - 四种遍历序列都是确定的
  - 单一遍历序列无法唯一确定二叉树
  - 中序序列配合其他任一序列可唯一确定二叉树

#### 构造方法
##### 由先序序列和中序序列构造
- pro：：
  - 先序序列和中序序列相同时确定的二叉树（2017）
  - 由先序序列和中序序列构造一棵二叉树（2020、2021）
- 构造原理：
  - 先序序列第一个结点为根结点
  - 根结点将中序序列分为左右子树
  - 子序列长度相等原则
  - 递归分解确定树结构

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/f95f56d393b614bbe625168363fd791b2fa3b99d431538422cdb0c9dfce8aee8.jpg)  

- 构造示例：
  - 序列：
    - 先序：ABCDEFGHI
    - 中序：BCAEDGHFI
  - 分析过程：
    - A为根结点
    - BC为左子树中序序列
    - EDGHFI为右子树中序序列
    - 递归分解其余结点

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/1bdfc32800eb0bdcdf69f66b04372af5f987fca29874a7edb3170bdcc7281785.jpg)  

##### 由后序序列和中序序列构造
- pro：：由后序序列和树形构造一棵二叉树（2017、2023）
- 构造原理：
  - 后序序列最后一个结点为根结点
  - 根结点分割中序序列
  - 递归分解确定结构

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/b7ff525d65d5eecf2e799de58498c82c5cc855212f4dedd5b861b42917822ce2.jpg)  

##### 由层序序列和中序序列构造
- 构造原理：
  - 层序第一个结点为根结点
  - 分割中序序列
  - 左子树根在层序第二位
  - 右子树根紧随其后
  - 递归划分确定结构

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/bfeb791360f3d1b1e847316927966170a32c8f5faecc10370d6de9816a2ae6c1.jpg)  

#### 注意事项
- 无法唯一确定二叉树的组合：
  - 先序序列+后序序列
  - 先序序列+层序序列
  - 后序序列+层序序列
- 示例：
  - 两棵不同二叉树可能有相同的：
    - 先序序列：AB
    - 后序序列：BA
    - 层序序列：AB

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8a85e2de2af6b7d96b93dbde3997116acee9adafbb64aa34b17139eaf5456102.jpg)  
图5.16两棵不同的二叉树  

## 线索二叉树  

### 线索二叉树的基本概念  

- 遍历二叉树的特点：
  - 按规则将结点排列成线性序列
  - 每个结点(除首尾)有直接前驱和后继

> pro：后序线索二叉树的定义（2010）  

- 传统二叉链表的局限：
  - 仅能体现父子关系
  - 无法直接获取遍历前驱后继

- 空指针利用：
  - n个结点中有n+1个空指针
  - 原因：
    - 叶结点有2个空指针
    - 度为1的结点有1个空指针
    - 空指针总数 = 2n₀+n₁
    - n₀=n₂+1
    - 总数 = n₀+n₁+n₂+1 = n+1

- 线索化规则：
  - 无左子树：lchild指向前驱
  - 无右子树：rchild指向后继
  - 需增加标志域标识指针类型

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a9348224b92a82715ff985f8c31844579514448dbf87208d26fb3b1653501d4d.jpg)  

- 存储结构：
  - 数据元素
  - 左右孩子指针
  - 左右线索标志
  - 构成线索链表

### 中序线索二叉树的构造  

- 线索化过程：
  - 本质是遍历二叉树
  - 将空指针改为前驱后继线索

> pro：中序线索二叉树中线索的指向（2014）  

- 构造步骤：
  - 使用pre指针指向访问过的结点
  - 使用p指针指向当前结点
  - 检查并建立线索

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/76585adca20c3587f88d89587e71edca8e1fc50e3353660a5d0938cbebc7c9fa.jpg)  

- 递归算法实现
- 主过程算法
- 头结点的处理：
  - lchild指向根结点
  - rchild指向最后访问结点
  - 首尾结点指向头结点

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3b88560b15260cda3cfd0b4e2229bfad1694c1d19f2b50c0d4c2b47f5c35b88e.jpg)  

### 中序线索二叉树的遍历  

- 遍历原理：
  - 利用线索找前驱后继
  - 从第一个结点开始依次找后继

- 后继查找规则：
  - 右标志为1：直接获取后继
  - 右标志为0：找右子树最左下结点

#### 基本算法实现
##### 1. 查找第一个结点
##### 2. 查找后继结点
##### 3. 遍历算法

### 先序线索二叉树和后序线索二叉树  

- 构造方法：
  - 类似中序线索化
  - 调整代码段位置
  - 改变递归顺序

- 示例说明：
  - 先序线索化过程
  - 后序线索化过程

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0fd60e6474663a6b6e5925b13b2ab71bcb51d855371fd982a306b9a0b94e3169.jpg)  

#### 后继查找方法
##### 先序线索二叉树
- 有左孩子：左孩子为后继
- 无左有右：右孩子为后继
- 叶结点：右链域指示后继

> pro：后序线索二叉树中线索的指向（2013）  

##### 后序线索二叉树
- 三种情况：
  - 根结点：后继为空
  - 右孩子或无右子树左孩子：后继为双亲
  - 有右子树左孩子：后继为右子树首个后序结点
- 特点：
  - 需知道结点双亲
  - 需用三叉链表存储
# 树、森林  

## 树的存储结构  

### 树的存储方式概述
- 可采用多种存储方式
  - 顺序存储结构
  - 链式存储结构
- 基本要求
  - 能唯一反映树中各结点之间的逻辑关系
- 常用存储结构
  - 介绍3种常用结构

### 双亲表示法
#### 基本概念
- 采用连续空间存储每个结点
- 每个结点增设伪指针指示双亲位置
- 根结点下标为0，伪指针域为-1

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a2e6b516fbf68e36a6730aff3150c9226473ea4cf4cbe0b6ac46cd04bc5e31e9.jpg)  
图5.21树的双亲表示法  

#### 存储结构描述
- 基本定义
  - #define MAX TREE SIZE 100
  - typedef struct
    - ElemType data
    - intparent
  - PTNode
  - PTree

#### 特点分析
- 优点
  - 可快速获取双亲结点
- 缺点
  - 查找孩子需遍历整个结构

> attention: 

区别树的顺序存储结构与二叉树的顺序存储结构。在树的顺序存储结构中，数组下标代表结点的编号，下标中所存的内容指示了结点之间的关系。而在二叉树的顺序存储结构中，数组下标既代表了结点的编号，又指示了二叉树中各结点之间的关系。当然，二叉树属于树，因此二叉树也可用树的存储结构来存储，但树却不都能用二叉树的存储结构来存储。  

### 孩子表示法
#### 基本原理
- 每个结点的孩子结点视为线性表
- 采用单链表作为存储结构
- n个结点对应n个孩子链表
- n个头指针组成线性表，采用顺序存储

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/60e641d5bf1b6a3367c0a715896ea6200c65d1d47f135dad05b2de7cc643bbac.jpg)  
图5.22树的孩子表示法和孩子兄弟表示法  

#### 特点分析
- 优点
  - 寻找孩子操作方便
- 缺点
  - 寻找双亲需遍历所有孩子链表

### 孩子兄弟表示法
#### 基本概念
- 又称三叉树表示法
- 采用二叉链表作为存储结构

#### 结点组成
- 结点值
- 指向第一个孩子结点的指针
- 指向下一个兄弟结点的指针

#### 存储结构描述
- typedef struct CsNode
  - ElemType data
  - struct CsNode *firstchild
  - struct CsNode *nextsibling
- CSNode, *CSTree

#### 特点分析
- 优点
  - 灵活性高
  - 易于树转二叉树
  - 方便查找孩子
- 缺点
  - 查找双亲结点较麻烦
  - 可通过增设parent域改进
## 树、森林与二叉树的转换  

### 基本概念
- 二义树和树都可以用二义链表作为存储结构
- 从物理结构上看，树的孩子兄第表示法与二义树的二叉链表表示法是相同的
- 可以用同一存储结构的不同解释将一棵树转换为二叉树

### 转换方法
#### 树转换为二叉树  

> pro：树和二叉树的转换及相关性质的推理（2009、2011）  

##### 转换规则
- 每个结点的左指针指向它的第一个孩子
- 右指针指向它在树中的相邻右兄弟
- 这个规则又称"左孩子右兄弟"
- 由于根结点没有兄弟，因此树转换得到的二叉树没有右子树

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6c83cdc39d25f3e1591f8d9edaa5c910296cb1e468eeeba38ac072864a44455f.jpg)  

##### 转换步骤
- 在兄弟结点之间加一连线
- 对每个结点，只保留它与第一个孩子的连线，而与其他孩子的连线全部抹掉
- 以树根为轴心，顺时针旋转45°

#### 森林转换为二叉树  

> pro：森林和二叉树的转换及相关性质的推理（2014）  

##### 转换规则
- 先将森林中的每棵树转换为二叉树
- 将第二棵树根视为第一棵树根的右兄弟
- 将第二棵树对应的二叉树当作第一棵二叉树根的右子树
- 将第三棵树对应的二叉树当作第二棵二叉树根的右子树，以此类推

##### 转换步骤
- 将森林中的每棵树转换成相应的二叉树
- 每棵树的根也可视为兄弟关系，在每棵树的根之间加一根连线
- 以第一棵树的根为轴心顺时针旋转45°

#### 二叉树转换为森林  

> pro：由遍历序列构造一棵二叉树并转换为对应的森林（2020、2021）  

##### 转换规则
- 若二叉树非空：
  - 二叉树的根及其左子树为第一棵树的二叉树形式
  - 将根的右链断开
  - 二叉树根的右子树视为剩余森林转换后的二叉树
  - 重复以上步骤直到最后只剩一棵没有右子树的二叉树
- 最后将每棵二叉树依次转换成树得到原森林
- 二叉树转换为树或森林是唯一的

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/247436d1c407e375d4ea4ae286dd335ae4bf8469ec4ad1b3014b562aced6dfaa.jpg)  

### 遍历方法
#### 树的遍历  

> pro：树与二叉树遍历方法的对应关系（2019）  

##### 基本概念
- 树的遍历是指用某种方式访问树中的每个结点，且仅访问一次
- 主要有两种方式：先根遍历和后根遍历

##### 先根遍历
- 若树非空，遵循以下规则：
  - 先访问根结点
  - 再依次遍历根结点的每棵子树
  - 遍历子树时仍遵循先根后子树的规则
- 其遍历序列与这棵树相应二叉树的先序序列相同

##### 后根遍历
- 若树非空，遵循以下规则：
  - 先依次遍历根结点的每棵子树
  - 遍历子树时仍遵循先子树后根的规则
  - 再访问根结点
- 其遍历序列与这棵树相应二叉树的中序序列相同

##### 示例
- 图5.23的树的遍历序列：
  - 先根遍历序列：ABEFCDG
  - 后根遍历序列：EFBCGDA
- 树也有层次遍历，与二叉树的层次遍历思想基本相同

#### 森林的遍历  

##### 先序遍历森林
- 若森林为非空，遵循以下规则：
  - 访问森林中第一棵树的根结点
  - 先序遍历第一棵树中根结点的子树森林
  - 先序遍历除去第一棵树之后剩余的树构成的森林

##### 中序遍历森林
- 若森林为非空，遵循以下规则：
  - 中序遍历森林中第一棵树的根结点的子树森林
  - 访问第一棵树的根结点
  - 中序遍历除去第一棵树之后剩余的树构成的森林

##### 示例与对应关系
- 图5.24的森林的遍历序列：
  - 先序遍历序列：ABCDEFGHI
  - 中序遍历序列：BCDAFEHIG

> pro：森林与二叉树遍历方法的对应关系（2020）  

- 森林转换成二叉树时：
  - 第一棵树的子树森林转换成左子树
  - 剩余树的森林转换成右子树
  - 森林的先序和中序遍历即为其对应二叉树的先序和中序遍历

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2e09d57af01729d539d610a7b2227fbf31fc318099d9e73cd036ab8262b4e34b.jpg)  

> attention: 

部分教材也将森林的中序遍历称为后序遍历，称中序遍历是相对其二叉树而言的，称后序遍历是因为根确实是最后才访问的，若遇到这两种称谓，则可理解为同一种遍历方法。  



# 树与二叉树的<span style="color: orange;">应用  

## 哈夫曼树和哈夫曼编码  

### 哈夫曼树
#### 相关概念
- P与PL
  - P：
    - 由 从树中一个结点 → 另一个结点之间的分支 构成
  - P**L**：
    - 路径上的**分支数目**

- 结点权值NW 与 带权路径长度**W**eighted **P**ath **L**ength
  - NW：
    - 树中结点**被赋予**的表示某种意义的**数值**
  - WPL：
    - 从树的根 → 该结点的 L*W
- **树**的WPL：
  - 所有叶结点的带权路径长度之<span style="color: green;">**和**</span>
    - $WPL=\sum_{i=1}^{n}w_{i}l_{i}$
      - $w_{i}$：第i个叶结点的权值
      - $l_{i}$：该叶结点到根结点的路径长度

#### 定义
- 哈夫曼树(**最优**二叉树)：
  - 在含有n个带权叶结点的二叉树中
  - WPL最小的二叉树

- 示例说明：
  ![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a2d32313c261c37c12b5a28af99468dcb1c7b5e3580b6b57a99efff0cd38d3e9.jpg)  
  - (a) WPL = 7×2+5×2+2×2+4×2=36
  - (b) WPL = 4×2+7×3+5×3+2×1=46
  - (c) WPL = 7×1+5×2+2×3+4×3=35（最小，为哈夫曼树）

#### 构造方法
> pro：分析哈夫曼树的路径上权值序列的合法性（2010）  

- 构造步骤：
  1. 将n个结点作为n棵单结点二叉树，构成森林F
  2. 构造新结点：
     - 选取F中权值最小的两棵树作为左右子树
     - 新结点权值为两子树根结点权值之和
  3. 更新森林F：
     - 删除选出的两棵树
     - 加入新构造的树
  4. 重复步骤2、3直至F中只剩一棵树

> pro：哈夫曼树的性质（2010、2019）  

- 特点：
  1. 初始结点最终都成为叶结点，权值越小路径越长
  2. 新建n-1个结点，总结点数为2n-1
  3. 不存在度为1的结点

- 构造示例：
  ![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/de9a695e33dd97c1c5ed46237ca55e6881724f902b983ec04e5940d6658f255e.jpg)

### 哈夫曼编码
#### 编码基础
- 编码类型：
  - 固定长度编码：每个字符用相等长度的二进制位表示
  - 可变长度编码：
    - 不同字符用不等长的二进制位表示
    - 特点：频率高的字符短编码，频率低的字符长编码
    - 优势：可减短平均编码长度，压缩数据

> pro：根据哈夫曼编码对编码序列进行译码（2017）  

#### 前缀编码
- 定义：没有一个编码是另一个编码的前缀
- 示例：
  - 合法前缀编码：A(0), B(10), C(110)
  - 解码特点：可唯一识别，如0010110可唯一解码为A,A,B,C
  - 反例：若D编码为11，则与C(110)产生歧义

> pro：哈夫曼树的构造及相关的分析（2012、2018、2021、2023）  
> pro：前缀编码的分析及应用（2014、2020）  

- 二叉树表示：
  ![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/530f7170ceac82b45e179b32785be7d95fda0363a9e6cd3d08e5994f85b9d240.jpg)

#### 哈夫曼编码实现
> pro：哈夫曼编码和定长编码的差异（2022）  

- 构造步骤：
  1. 将字符作为独立结点，权值为出现频度
  2. 构造哈夫曼树
  3. 根到叶结点路径的分支标记作为编码

- 编码示例：
  ![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/72a3cdbcb2f74e6a103772e7474ffec4f31c43dfd93f72e47a7066a5d3c31e44.jpg)
  - WPL计算：1×45+3×(13+12+16)+4×(5+9)=224
  - 压缩效果：比3位定长编码(300位)节省25%

> attention: 
左分支和右分支究竞是表示0还是表示1没有明确规定，因此构造出的哈夫曼树并不唯一，但各哈夫曼树的带权路径长度WPL相同且为最优。此外，如有若干权值相同的结点，则构造出的哈夫曼树更可能不同，但WPL必然相同且为最优。
# 并查集Disjoint Set Union  

### 概念
- 并查集(DSU - Disjoint Set Union)
  - 是一种树型的数据结构
  - 主要用途：
    - 处理不相交集合的合并问题
    - 处理不相交集合的查询问题
  - 表示方式：
    - 以森林形式表示
    - 每个集合用一棵树表示
    - 树的根节点代表该集合## 并查集
  
- 支持3种操作：
  - Initial(S)：将集合s中的每个元素都初始化为只有一个单元素的子集合
  - Union(S,Root1,Root2)：要求Root1和Root2互不相交，否则不执行合并
  - Find(S,x)：查找集合S中单元素x所在的子集合，并返回该子集合的根结点

### 存储结构
- 存储特点：
  - 使用树的双亲表示作为存储结构
  - 每个子集合以一棵树表示
  - 所有子集合树构成森林，存放在双亲表示数组内
  - 数组元素下标代表元素名
  - 根结点下标代表子集合名
  - 根结点双亲域为负数

- 示例说明：
  - 全集合S={0,1,2,3,4,5,6,7,8,9}
  - 初始化状态：每个元素自成一个单元素子集合，数组值为-1
  $
  s(\odot\odot\odot)\odot(\odot)\odot(\odot)\odot(\odot)\odot(\odot)
  $  
  $
  \begin{array}{c c c c c c}{{0}}&{{1}}&{{2}}&{{3}}&{{4}}&{{5}}&{{6}}&{{7}}&{{8}}&{{9}}\\ {{\mid-1\mid-1\mid-1\mid-1\mid-1\mid-1\mid-1\mid-1\mid-1\mid-1\mid-1\mid-1\mid-1\mid-1\mid-1\mid-1\mid-1\mid}}\end{array}
  $  
  - 合并后状态：
    - S₁={0,6,7,8}
    - S₂={1,4,9}
    - S₃={2,3,5}
    ![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/976fcd63eca493385976fd301e1a61e3edcd3c536650dac7f9a30aab44ed41e1.jpg)
    ![](https://cdn-mineru.openxlab.org/model-mineru/prod/5aac5c13895f1d4c8124a715052fb3f5ae623c11d1fa4e7e3de6ae02a965ce4c.jpg)

### 基本实现
#### 初始化操作

void Initial(int S[]) {
    for(int i=0; i<SIZE; i++)
        S[i]=-1;
}


#### Find操作

int Find(int S[], int x) {
    while(S[x]>=0)
        x=S[x];
    return x;
}


#### Union操作

void Union(int S[], int Root1, int Root2) {
    if(Root1==Root2) return;
    S[Root2]=Root1;
}


- 时间复杂度：
  - Find操作：O(d)，d为树的深度
  - Union操作：O(1)

### 并查集实现的优化
#### 优化策略
- Union操作优化：
  - 判别子集成员数量
  - 将小树合并到大树
  - 根结点绝对值保存集合树成员数量


- ```C 
  void Union(int S[], int Root1, int Root2) {
    if(Root1==Root2) return;
    if(S[Root2]>S[Root1]) {
        S[Root1]+=S[Root2];
        S[Root2]=Root1;
    } else {
        S[Root2]+=S[Root1];
        S[Root1]=Root2;
    }
  }
  ```

- Find操作优化：
  - 增加"压缩路径"功能
  - 将根到元素x路径上所有元素变成根的孩子


int Find(int S[], int x) {
    int root=x;
    while(S[root]>=0)
        root=S[root];
    while(x!=root) {
        int t=S[x];
        S[x]=root;
        x=t;
    }
    return root;
}


- 优化效果：
  - 集合树深度不超过O(α(n))
  - α(n)增长极其缓慢
  - 对常见正整数n，通常α(n)≤4

# 归纳总结

## 二叉树的重要性
- 二叉树是极其重要的**考查点**
- 2014年统考首次出现线性表以外的算法设计题

## 遍历操作
### 遍历的基础性
- 是二叉树各种操作的基础
- 统考常考查遍历过程中对结点的其他操作
- 结合递归算法和非递归算法（使用栈或队列）

### 学习要点
- 掌握各种遍历方法的代码书写
- 学会在遍历基础上进行其他相关操作
- 重点掌握**递归算法**
  - 特点：短小精悍，出现概率大
  - 要求：对遍历程序模板烂熟于心
  - 建议：结合习题练习，以便快速写出代码

### 遍历算法的递归程序模板

- ```C
  void Track（BiTree *p）{ 
      if(p! = NULL)
      I (1) 
      Track(p->lchild); 
      1/(2）
      Track(p->rchild); 
      1(3)  
  ```

- 访问函数visit()位置说明：
  - 位置(1)：先序遍历
  - 位置(2)：中序遍历
  - 位置(3)：后序遍历

## 实例练习
### 二叉链表存储结构的递归算法题目
1. 统计二叉树中度为1的结点个数
2. 统计二叉树中度为2的结点个数
3. 统计二叉树中度为0的结点个数
4. 统计二叉树的高度
5. 统计二叉树的宽度
6. 从二叉树中删去所有叶结点
7. 计算指定结点 ${}^{\star}\mathtt{P}$ 所在的层次
8. 计算二叉树中各结点中的最大元素的值
9. 交换二叉树中每个结点的两个子女
10. 以先序次序输出一颗二叉树中所有结点的数据值及结点所在的层次
# 思维拓展  

输入一个整数data和一棵二元树。从树的根结点开始往下访问一直到叶结点，所经过的所有结点形成一条路径。打印出路径及与data相等的所有路径。例如，输入整数22和下图所示的二元树，则打印出两条路径1012和10，5，7。  
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/941f06790d07c3ba3849267e4edafa0ff0976cce9578e4bd627251e1fa3c5cf8.jpg)  

提示：使用数组或栈保存访问的路径，并记录当前路径上所有元素的和Sum。若当前结点为叶结点，且当前结点值与sum的和等于data，则满足条件，打印当前路径。然后递归返回到父结点，注意在递归返回之前要先减去当前结点元素的值。使用前序遍历操作的递归算法模板可以简化程序。  