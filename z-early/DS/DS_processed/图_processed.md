以下是按照要求处理后的 Markdown 内容，增加了 `<ul></ul>` 标签以实现标题段落间的缩进，保持了原有的 Markdown 格式（如图片链接等）不变：

```markdown
# 图above  

<ul>

## 【考纲内容】  

<ul>

（一）图的基本概念  

（二）图的存储及基本操作邻接矩阵：邻接表：邻接多重表；十字链表  

（三）图的遍历：深度优先搜索：广度优先搜索

（四）图的基本应用最小（代价）生成树：最短路径；拓扑排序：关键路径  

</ul>

## 【知识框架】  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/1736cc1858562584a3b9c75bce02bd73a9deed0a76bcc241d437fa01e41ebb56.jpg)  

## 【复习提示】  

图算法的难度较大，主要掌握深度优先搜索与广度优先搜索。

掌握图的基木概念及基本性质、图的存储结构（邻接矩阵、邻接表、邻接多重表和十字链表）及特性、存储结构之间的转化、基于存储结构上的各种遍历操作和各种应用（拓扑排序、最小生成树、最短路径和关键路径）等。

图的相关算法较多，通常只需掌握其<u>基本思想</u>和<u>实现步骤</u>，而实现代码不是重点。  

### 基本概念  

<ul>

#### 定义  

- 图 $G$ 由顶点集 $V$ 和边集 $E$ 组成，记为 $G=(V,\,E)$
  - $V(G)$ 表示图 $G$ 中顶点的有限非空集
  - $E(G)$ 表示图 $G$ 中顶点之间的关系（边）集合
  - 若 $V=\{v_{1},\,v_{2},\cdots,\,v_{n}\}$，则用IV表示图 $G$ 中顶点的个数
  - $E=\{(u,v)\mid u{\in}V,v{\in}V\}$，用 $|E|$ 表示图 $G$ 中边的条数

> attention 

线性表可以是空表，树可以是空树，但图不可以是空图。也就是说，图中不能一个顶点也没有，图的顶点集 $V$ 一定非空，但边集 $E$ 可以为空，此时图中只有顶点而没有边。  

#### 图的基本类型

<ul>

##### 有向图
- 若 $E$ 是有向边（也称弧）的有限集合，则图 $G$ 为有向图
  - 弧是顶点的有序对，记为y，$w^{>}$
  - $v$ 称为弧尾，$w$ 称为弧头
  - <v,W>称为从v到 $w$ 的弧，也称v邻接到 $w$

图6.1（a）所示的有向图 $G_{1}$ 可表示为：
$G_{1}\!=\!(V_{1},E_{1})$
$E_{1}=\{<\!1,2\!>,<\!2,1\!>,<\!2,3\!>\}$

##### 无向图
- 若 $E$ 是无向边（简称边）的有限集合，则图 $G$ 为无向图
  - 边是顶点的无序对，记为 $(v,\,w)$ 或 $(w,v)$
  - $w$ 和 $\nu$ 互为邻接点
  - 边 $(v,w)$ 依附于 $w$ 和 $v$，或称边 $(v,w)$ 和 $v,w$ 相关联

图6.1（b）所示的无向图 $G_{2}$ 可表示为：
$\begin{array}{c}{G_{2}=\left(V_{2},E_{2}\right)}\\ {V_{2}=\left\{1,2,3,4\right\}}\end{array}$
$E_{2}=\{(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)\}$

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/5151560dfc0c00af5239183bc6f467e3c9e73df7d8ee3886d9de445058a96358.jpg)

##### 简单图、多重图
- 简单图的条件：
  - 不存在重复边
  - 不存在顶点到自身的边
- 多重图的特点：
  - 某两个顶点之间的边数大于1条
  - 允许顶点通过一条边和自身关联

##### 完全图
- 无向完全图：
  - $|E|$ 的取值范围为0到 $n(n-1)/2$
  - 任意两个顶点之间都存在边
- 有向完全图：
  - $|E|$ 的取值范围为0到 $n(n-1)$
  - 任意两个顶点之间都存在方向相反的两条弧

##### 子图
- 设有两个图 $G=(V,E)$ 和 $G^{\prime}=(V,E^{\prime})$
  - 若 $V$ 是 $V$ 的子集，且 $E^{\prime}$ 是 $E$ 的子集，则称 $G^{\prime}$ 是 $G$ 的子图
  - 若有满足 $V(G^{\prime})=V(G)$ 的子图 $G^{\prime}$，则称其为 $G$ 的生成子图

> attention 

并非 $V$ 和 $E$ 的任何子集都能构成 $G$ 的子图，因为这样的子集可能不是图，即 $E$ 的子集中的某些边关联的顶点可能不在这个 $V$ 的子集中。  

##### 连通、连通图和连通分量

>pro：图的连通性与边和顶点的关系(2010、2022)

- 连通的定义：
  - 在无向图中，若从顶点 $\nu$ 到顶点 $w$ 有路径存在，则称 $v$ 和 $w$ 是连通的
- 连通图：
  - 若图 $G$ 中任意两个顶点都是连通的，则称图 $G$ 为连通图
- 连通分量：
  - 无向图中的极大连通子图称为连通分量

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8d9d6a37be3c6ce09a5a0aa15355ead14bf7a5a3e352c73cf8d0cb852ebd9b30.jpg)

##### 强连通图、强连通分量
- 强连通的定义：
  - 在有向图中，若有一对顶点 $v$ 和 $w$，从 $v$ 到 $w$ 和从 $w$ 到 $v$ 之间都有路径
- 强连通图：
  - 若图中任意一对顶点都是强连通的
- 强连通分量：
  - 有向图中的极大强连通子图

> attention 

在无向图中讨论连通性，在有向图中讨论强连通性。  

##### 生成树、生成森林
- 生成树的特点：
  - 连通图的生成树是包含图中全部顶点的一个极小连通子图
  - 若图中顶点数为 $n$，则它的生成树含有 $n\!-\!1$ 条边
- 生成森林：
  - 在非连通图中，连通分量的生成树构成了非连通图的生成森林

![image](https://bluejedis.github.io/picx-images-hosting/test/image.8l03vtq220.webp)

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/bfa9e01aeec1a2c5a3b7b4d36a675036ff24683fc2cf93f63569eaa97879224d.jpg)

> attention 

区分极大连通子图和极小连通子图。极大连通子图要求子图必须连通，而且包含尽可能多的顶点和边；极小连通子图是既要保持子图连通又要使得边数最少的子图。  

##### 顶点的度、入度和出度

>pro：无向图中顶点和边的关系（2009、2017）  

- 无向图中的度：
  - 顶点 $v$ 的度是指依附于顶点 $v$ 的边的条数，记为 $\operatorname{TD}(\nu)$
  - 无向图的全部顶点的度之和等于边数的2倍
- 有向图中的度：
  - 入度：以顶点 $v$ 为终点的有向边的数目，记为ID(v)
  - 出度：以顶点 $v$ 为起点的有向边的数目，记为 $\mathrm{{OD}}(v)$
  - 顶点 $v$ 的度等于其入度与出度之和：$\mathrm{TD}(\nu)=\mathrm{ID}(\nu)+\mathrm{OD}(\nu)$

##### 边的权和网
- 边的权值：每条边都可以标上具有某种含义的数值
- 网：边上带有权值的图

##### 稠密图、稀疏图
- 稀疏图：边数很少的图
- 稠密图：边数较多的图
- 判断标准：
  - 当图 $G$ 满足 $|E|<|V|\mathrm{log}|V|$ 时，可以将 $G$ 视为稀疏图

##### 路径相关概念
###### 路径、路径长度和回路
- 路径：顶点序列 $v_{p},v_{i_{1}},v_{i_{2}},\cdots,v_{i_{m}},v_{q}$
- 路径长度：路径上的边的数目
- 回路或环：第一个顶点和最后一个顶点相同的路径

###### 简单路径、简单回路

>pro：路径、回路、简单路径、简单回路的定义（2011）  

- 简单路径：在路径序列中，顶点不重复出现的路径
- 简单回路：除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路

###### 距离
- 定义：从顶点 $u$ 出发到顶点 $v$ 的最短路径的长度
- 特殊情况：若从 $u$ 到根本不存在路径，则记该距离为无穷（）

##### 有向树
- 定义：一个顶点的入度为0、其余顶点的入度均为1的有向图

</ul>

</ul>

### 存储及基本操作  

图的存储必须要完整、准确地反映顶点集和边集的信息。根据不同图的结构和算法，采用不同的存储方式将对程序的效率产生相当大的影响，因此所选的存储结构应适合于待求解的问题。  

<ul>

#### 邻接矩阵法  

<ul>

##### 基本概念
- 邻接矩阵存储的组成：
  - 用一维数组存储图中顶点的信息
  - 用二维数组存储图中边的信息（即各顶点之间的邻接关系）
  - 存储顶点之间邻接关系的二维数组称为邻接矩阵

##### 矩阵表示
- 顶点数为 $n$ 的图 $G\!=\!(V,E)$ 的邻接矩阵 $_A$ 是 $_{n\times n}$ 的
- 将 $G$ 的顶点编号为 $v_{1},v_{2},\cdots,v_{n}$

> pro：图的邻接矩阵存储及相互转换（2011、2015、2018）  

##### 权值表示
- 对带权图：
  - 若顶点 $v_{i}$ 和 $\nu_{j}$ 之间有边相连，则存放该边对应的权值
  - 若顶点 $V_{i}$ 和 $V_{j}$ 不相连，则通常用0或 $\infty$ 表示

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/452c3b970dbd32b4453acaa0973977edccafa0e6e194da0812a21b6fe6148c9b.jpg)  
图6.5有向图、无向图及网的邻接矩阵  

> pro：（算法题）邻接矩阵的遍历及顶点的度的计算（2021、2023）  

##### 存储结构定义

#define Max Vertex Num l00typedef char VertexType;  
typedef int EdgeType;//边对应的数据类型typedef struct{ Vertex Type vex[Max Vertex Num];/顶点表Edge Type edge[Max Vertex Num][Max Vertex Num]；//邻接矩阵，边表int vexnum,arcnum;/图的当前顶点数和边数)MGraph;  


> attention 

##### 注意事项
- 简单应用可直接用二维数组作为邻接矩阵
- EdgeType可用值为0和1的枚举类型
- 无向图的邻接矩阵是对称矩阵
- 空间复杂度为 $O(n^{2})$

> pro：邻接矩阵的遍历的时间复杂度（2021）  

##### 特点
- 无向图特性：
  - 邻接矩阵一定是对称矩阵（并且唯一）
  - 只需存储上（或下）三角矩阵元素

> pro：基于邻接矩阵的顶点的度的计算（2013、2021、2023）  

- 度的计算：
  - 无向图：第i行（或列）非零元素个数为顶点i的度
  - 有向图：
    - 第i行非零元素个数为出度
    - 第i列非零元素个数为入度

- 其他特性：
  - 容易确定任意两顶点间是否有边
  - 确定边数需要遍历所有元素
  - 适合存储稠密图

> pro：计算 $A^{2}$ 并说明A"[][/]的含义（2015）  

- 路径计算：
  - $A^{n}$ 的元素表示长度为n的路径数目

</ul>

#### 邻接表法  

<ul>

##### 基本概念
- 适用于稀疏图
- 结合顺序存储和链式存储方法
- 组成结构：
  - 对每个顶点建立单链表
  - 单链表结点表示依附于该顶点的边

##### 存储结构
- 两种结点类型：
  - 顶点表结点
  - 边表结点

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2ad0c70c97181ad46888d00bf7d1e1937cfcb142dda79077f20ff660fa09fa94.jpg)  
图6.6顶点表和边表结点结构  

###### 结点组成
- 顶点表结点：
  - 顶点域（data）：存储顶点信息
  - 边表头指针域（firstarc）：指向第一条边
- 边表结点：
  - 邻接点域（adjvex）：存储邻接顶点编号
  - 指针域（nextarc）：指向下一条边

> pro：图的邻接表存储的应用（2014）  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3503c0ddc86c46b037cc84f917b3f4f690516b2cbec074113c67d50a2be472cf.jpg)  
图6.7无向图邻接表表示法实例  

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/99831cb9adda79d80ce0087a8c64203ed478c2696ff7c44eddc97b0e34c61786.jpg)  
图6.8有向图邻接表表示法实例  

##### 代码实现

#define Max Vertex Num 100/图中顶点数目的最大值typedef struct ArcNode{/边表结点int adjvex;/该弧所指向的顶点的位置struct ArcNode \*nextarc;/指向下一条弧的指针l/InfoType info; //网的边权值  

)ArcNode;  

typedef struct VNode{//顶点表结点Vertex Type data;//顶点信息ArcNode \*firstarc;/指向第一条依附该顶点的弧的指针  

)VNode,AdjList[Max Vertex Num];  

AdiList vertices;川/邻接表int vexnum,arcnum;/图的顶点数和弧数)ALGraph;I/ALGraph是以邻接表存储的图类型  


##### 存储特点
- 空间复杂度：
  - 无向图：$O(|V|+2|E|)$
  - 有向图：$O(|V|+|E|)$

> pro：邻接矩阵法和邻接表法的适用性差异（2011）  

- 适用性：
  - 适合稀疏图
  - 容易找出顶点的所有邻边
  - 确定两顶点间是否有边效率较低

- 度的计算：
  - 无向图：计算边表结点个数
  - 有向图：
    - 出度：计算边表结点个数
    - 入度：需遍历全部邻接表

- 表示特性：
  - 不唯一性：取决于边的输入次序

</ul>

</ul>

### 图的存储结构
<ul>

#### 十字链表  

<ul>

- 定义：十字链表是有向图的一种链式存储结构
- 结点类型：
  - 弧结点：表示每条弧
  - 顶点结点：表示每个顶点

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/74266ee7e563c116de5fb9a491b7ab8fe3ff5c963390bb5cd61fc774107b00af.jpg)  

- 弧结点结构：
  - 五个域组成：
    - tailvex：弧尾顶点编号
    - headvex：弧头顶点编号
    - hlink：指向弧头相同的下一个弧结点
    - tlink：指向弧尾相同的下一个弧结点
    - info：该弧的相关信息

- 顶点结点结构：
  - 三个域组成：
    - data：顶点数据信息
    - firstin：指向以该顶点为弧头的第一个弧结点
    - firstout：指向以该顶点为弧尾的第一个弧结点

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/22cd3b3c3edea93d459339c492f17aca8da4b3af583a22feddb788230535e18b.jpg)  
图6.9有向图的十字链表表示（弧结点省略info域）  

- 特点：
  - 顶点结点间采用顺序存储
  - 易于找到以Vi为尾或头的弧
  - 便于求顶点的出度和入度
  - 表示不唯一，但一个表示唯一确定一个图

</ul>

#### 邻接多重表  

<ul>

- 定义：邻接多重表是无向图的一种链式存储结构
- 优势：相比邻接表，更易于处理边的操作

- 边结点结构：
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/ca384d2315602e299aa8d39ceb099e8698afb0d7699ccc8d0753379c1c14fd9d.jpg)  
  - 组成域：
    - ivex、jvex：依附的两个顶点编号
    - ilink：指向下一条依附于ivex的边
    - jlink：指向下一条依附于jvex的边
    - info：边的相关信息

- 顶点结点结构：
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/6d2235b1c5b4ab153bc8da98b8ef339ac5118bd7a377aa55aa99addf45c45911.jpg)  
  - 组成域：
    - data：顶点相关信息
    - firstedge：指向第一条依附的边

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/00d0a1988e38e61fac9ff788e80b20481d9c5be4523450b723ae3a32fba6dab2.jpg)  
图6.10无向图的邻接多重表表示（边结点省略info域）  

- 存储特点：
  - 依附同一顶点的边在同一链表中
  - 每个边结点同时链接在两个链表中
  - 比邻接表更节省空间（一个边结点表示一条边）

</ul>

表6.1图的四种存储方式的总结
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/4c4a4bbdb4cf810f3765a867f779a8771cbd4a4349fecb05e02ba697baa3b451.jpg)  

</ul>

### 图的基本操作

<ul>

- 特点：
  - 独立于存储结构
  - 不同存储方式性能不同
  - 需考虑存储方式对算法效率的影响

- 主要操作：
  - Adjacent(G,x,y)：判断边是否存在
  - Neighbors(G,x)：列出邻接边
  - Insert_Vertex(G,x)：插入顶点
  - Delete_Vertex(G,x)：删除顶点
  - AddEdge(G,x,y)：添加边
  - RemoveEdge(G,x,y)：删除边
  - First_Neighbor(G,x)：求第一个邻接点
  - Next_Neighbor(G,x,y)：求下一个邻接点
  - Get_edge_value(G,x,y)：获取边权值
  - Set_edge_value(G,x,y,v)：设置边权值

- 遍历算法：
  - 目的：访问每个顶点一次
  - 类型：
    - 深度优先遍历
    - 广度优先遍历

</ul>

</ul>

# 图的遍历

<ul>

## 基本概念
<ul>

- 定义：从图中某一顶点出发，按照特定搜索方法沿边访问所有顶点各一次
- 特点：
  - 树的遍历是特殊的图遍历
  - 是解决连通性、拓扑排序、关键路径等问题的基础
  - 比树遍历复杂，需避免重复访问
    - 使用visited[]数组标记已访问顶点
- 主要方法：
  - 广度优先搜索
  - 深度优先搜索

</ul>

## 广度优先搜索
<ul>

### 基本原理
<ul>

- 类似二叉树层序遍历
- 基本思想：
  - 先访问起始顶点v
  - 依次访问v的未访问邻接点
  - 再访问这些邻接点的未访问邻接点
  - 重复直至所有顶点访问完毕
- 特点：
  - 由近至远分层访问
  - 需要辅助队列记录下一层顶点
  - 非递归算法

</ul>

### 算法实现
<ul>

#### 主框架

bool visited[MAX VERTEX NUM];
void BF S Traverse（Graph G){
    for(i=0;i<G.vexnum;++i)
        visited[i]=FALSE;
    InitQueue(Q);
    for(i=0;i<G.vexnum;++i)
        if(!visited[i])
            BFS(G,i);


#### 邻接表实现

void BFS（ALGraph G,int i){
    visit（i);
    visited[i]=TRUE;
    EnQueue（Q,i);
    while(!IsEmpty(Q)){
        DeQueue(Q,v);
        w=p->adjvex;
        if(visited[w]==FALSE){
            visit（w);
            visited[w]=TRUE;
            EnQueue(Q,w);


#### 邻接矩阵实现

void BFS（MGraph G,int i){
    visit（i);
    visited[i]=TRUE;
    EnQueue（Q,i);
    while(!IsEmpty(Q)){
        DeQueue(Q,v);
        for(w=0;w<G.vexnum;w++)
            if(visited[w]==FALSE&&G.edge[v][w]==1){
                visit(w);
                visited[w]=TRUE;
                EnQueue(Q,w);


</ul>

### 遍历示例
<ul>

> pro：广度优先遍历的过程（2013）

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/42543e3cbbf650ee51abdafe55648cf488f5a427608b8a1e32178060c28985aa.jpg)
图6.11一个无向图G

- 遍历过程：
  - 从顶点a开始：
    1. a入队
    2. 访问a的邻接点b,c并入队
    3. 访问b的邻接点d,e并入队
    4. 访问c的邻接点f,g并入队
    5. 检查d无未访问邻接点
    6. 访问e的邻接点h并入队
    7. 检查h，队列为空，结束
  - 最终遍历序列：abcdefgh
- 结论：与二叉树层序遍历一致，是其扩展
</ul>

### BFS算法的性能分析  
<ul>

#### 空间复杂度
- 无论是邻接表还是邻接矩阵的存储方式：
  - BFS算法都需要借助一个辅助队列 $\mathcal{Q}$
  - $n$ 个顶点均需入队一次
  - 在最坏的情况下，空间复杂度为 $O(|V|)$

#### 时间复杂度
> pro：基于邻接表存储的BFS的效率（2012）  

- 遍历图的过程实质上是对每个顶点查找其邻接点的过程
- 耗费的时间取决于所采用的存储结构
  - 采用邻接表存储时：
    - 每个顶点均需搜索（或入队）一次，时间复杂度为 $O(|V|)$
    - 在搜索每个顶点的邻接点时，每条边至少访问一次，时间复杂度为 $O(|E|)$
    - 总的时间复杂度为 $O(|V|+|E|)$
  - 采用邻接矩阵存储时：
    - 查找每个顶点的邻接点所需的时间为 $O(|V|)$
    - 总时间复杂度为 $O(|V|^{2})$

</ul>

### BFS算法求解单源最短路径问题  
<ul>

#### 问题定义
- 若图 $G=(V,\,E)$ 为非带权图：
  - 定义从顶点 $u$ 到顶点 $v$ 的最短路径 $d(u,\,v)$ 为从 $u$ 到 $\nu$ 的任何路径中最少的边数
  - 若从 $u$ 到 $\nu$ 没有通路，则 $d(u,v)=\infty$ 6

#### 算法原理
- 使用BFS可以求解非带权图的单源最短路径问题
- 这是由广度优先搜索总是按照距离由近到远来遍历图中每个顶点的性质决定的

#### 算法实现

void BFS MIN Distance（Graph G,int u){ /ld[i]表示从u到i结点的最短路径 
    for(  $\scriptstyle{\dot{\mathbf{z}}}=0$  ;i<G.vexnum;  ${++i}$   ${\sf d}\left[\dot{\Sigma}\right]\!=\!\infty$ //初始化路径长度
    visited[u]  $=$  TRUE;d[u]  $=\!0$  
    EnQueue（Q,u）;
    while(!isEmpty(Q)){/BFS算法主过程
        DeQueue(Q,u);/队头元素u出队
        for  $w=$  First Neighbor(G,u);  $w\!>\!=\!0$   $w=$  Next Neighbor（G,u,w)) 
            if(!visited[w]){//为u的尚未访问的邻接顶点
                visited[w]  $=$  TRUE; //设已访问标记 
                d[w]  $\scriptstyle=\operatorname{d}$  [u]  $^{+1}$  /路径长度加1 
                EnQueue(Q,w);/顶点w入队


</ul>

### 广度优先生成树  
<ul>

#### 生成树特点
- 在广度遍历的过程中，可以得到一棵遍历树，称为广度优先生成树
- 存储方式对生成树的影响：
  - 邻接矩阵存储表示是唯一的，所以其广度优先生成树也是唯一的
  - 邻接表存储表示不唯一，所以其广度优先生成树也是不唯一的

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/a558e1e1aab5256ec092199096715091d9fd2bed801b23092ca6ae4ea150bdf2.jpg)  
图6.12图的广度优先生成树
</ul>

</ul>

## 深度优先搜索  
<ul>

### 基本概念
<ul>

- 深度优先搜索（Depth-First-Search，DFS）类似于树的先序遍历
- 搜索策略是尽可能"深"地搜索一个图

</ul>

### 基本思想
<ul>

- 搜索过程：
  - 访问起始顶点v
  - 由v出发，访问未访问的邻接顶点w1
  - 访问与w1邻接且未访问的顶点w2
  - 重复上述过程
- 回溯机制：
  - 当无法继续向下访问时，退回到最近访问的顶点
  - 若存在未访问的邻接顶点，继续搜索
  - 直至所有顶点均被访问

</ul>

### 算法实现
<ul>

#### 主遍历函数

bool visited[MAX VERTEX NUM];/访问标记数组
void DF S Traverse(Graph G){I/对图G进行深度优先遍历
for  $\scriptstyle{\dot{\mathbf{1}}}\,=\,0$   $\scriptstyle{\dot{\mathbf{z}}}<G$  .vexnum;  $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \$  visited[i] $=$ FALSE;//初始化已访问标记数组
for $\scriptstyle{\dot{\mathbf{1}}}=0$  $\scriptstyle{\mathrm{~i}}<G$ .vexnum; $\dot{\mathbf{x}}_{++}$ 川本代码中是从 $v_{0}$ 开始遍历
if(!visited[i])/对尚未访问的顶点调用DFS（）
DFS(G,i);


#### 邻接表实现

void DFS（ALGraph G,int i）{
visit(i);/访问初始顶点i
visited[i]  $=$  TRUE; /对1做已访问标记 
for $\scriptstyle{\mathfrak{p}}=G$ .vertices[i].firstarc;p; $\scriptstyle{\mathbb{P}}^{=}\mathbb{P}$ ->nextarc）（/检测i的所有邻接点
j=p->adjvex; 
if（visited[j]  $==$  FALSE) 
DES(G,j）;为i的尚未访问的邻接点，递归访问


#### 邻接矩阵实现

void DFS（MGraph G,int i）{
visit（i);//访问初始顶点i
visited[i]  $=$  TRUE; /对1做已访问标记 
for $(\stackrel{.}{\mathrm{j}}=\stackrel{0}{0}$ j<G.vexnum; $\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\$ //检测i的所有邻接点
if(visited[j]  $==$  FALSE&&G.edge[i][j]  $==1$  
DFS(G,j);j为i的尚未访问的邻接点，递归访问


</ul>

### 遍历示例
<ul>

> pro：深度优先遍历的过程（2015、2016）  

- 以图6.11的无向图为例，遍历过程：
  - 访问a并置访问标记
  - 访问与a邻接的未访问顶点b，置访问标记
  - 访问与b邻接的未访问顶点d，置访问标记
  - d无未访问邻接点，返回b
  - 访问与b邻接的未访问顶点e，置访问标记
  - 继续此过程直至所有顶点被访问
- 最终遍历结果：abdehcfg

</ul>

### 注意事项
<ul>

> attention 

- 图的表示方式对遍历结果的影响：
  - 邻接矩阵表示是唯一的：
    - DFS序列唯一
    - BFS序列唯一
  - 邻接表表示不唯一（取决于边的输入次序）：
    - DFS序列不唯一
    - BFS序列不唯一
</ul>

### DFS算法的性能分析  
<ul>

#### 空间复杂度
- DFS算法是一个递归算法
  - 需要借助一个递归工作栈
  - 空间复杂度为 $O(|V|)$

#### 时间复杂度
- 遍历图的过程实质是通过边查找邻接点的过程
- 两种遍历方式的时间复杂度相同
  - 采用邻接矩阵存储时：$O(|V|^{2})$
  - 采用邻接表存储时：$O(|V|+|E|)$

</ul>

### 深度优先的生成树和生成森林  
<ul>

#### 生成树的产生条件
- 对连通图调用DFS才能产生深度优先生成树
- 否则产生深度优先生成森林

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/80ef10fc4c40d90faf1f0f3f8503446a41b03c6ef2278ea05623bcbf8a932ea2.jpg)  
图6.13图的深度优先生成森林  

</ul>

### 图的遍历与图的连通性  
<ul>

#### 无向图的连通性判断
- 连通图
  - 从任意结点出发，一次遍历可访问所有顶点
- 非连通图
  - 一次遍历只能访问该顶点所在连通分量的顶点
  - 其他连通分量的顶点无法通过这次遍历访问

#### 有向图的连通性判断
- 从初始顶点到每个顶点都有路径时
  - 能够访问所有顶点
- 否则不能访问到所有顶点

#### 遍历函数的实现
- BFSTraverse()或DFSTraverse()中添加第二个for循环
- 再选取初始点继续遍历
- 对于无向图
  - 调用BFS(G,i)或DFS(G,i)的次数等于连通分量数
- 对于有向图
  - 连通的有向图分为强连通和非强连通
  - 连通子图分为强连通分量和非强连通分量
  - 非强连通分量一次调用无法访问所有顶点

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/823fee21850cd372fbc2f6401fff35ce59784df00323e94b4176edf7aeec0711.jpg)  
图6.14有向图的非强连通分量

</ul>

</ul>

</ul>

# 图的应用

<ul>

本节是历年考查的重点。图的应用主要包括：最小生成（代价）树、最短路径、拓扑排序和关键路径。一般而言，这部分内容直接以算法设计题形式考查的可能性极小，而更多的是结合图的实例来考查算法的具体操作过程，读者必须学会手工模拟给定图的各个算法的执行过程。此外，还需掌握对给定模型建立相应的图去解决问题的方法。

## 最小生成树

<ul>

### 基本概念
<ul>

- 生成树的定义
  - 包含图的所有顶点
  - 只含尽可能少的边
  - 砍去一条边会使其变成非连通图
  - 增加一条边会形成回路

</ul>

### 最小生成树定义
<ul>

- 带权连通无向图G中
  - 不同生成树权值可能不同
  - 权值之和最小的生成树称为最小生成树(MST)

</ul>

### 最小生成树性质
<ul>

> pro：最小生成树的性质（2012、2017）

#### 唯一性
- 权值相同时可能不唯一(树形不唯一)
- 权值互不相等时唯一
- 边数比顶点数少1时，G本身就是最小生成树

#### 权值特性
- 权值之和唯一且最小
- 边数为顶点数减1

#### 路径特性
> pro：最小生成树中某顶点到其他顶点是否具有最短路径的分析（2023）

> attention 

- 不能保证任意两点间路径最短
  - 如下图所示例子

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/02e492777fdd70471f99a72a7ca8d6237b0cbdc152f003539de53616c1664f55.jpg)

</ul>

### 构造算法基础
<ul>

#### 基本性质
- G=(V,E)为带权连通无向图
- U是V的非空子集
- (u,v)是最小权值边，其中u∈U，v∈V-U
- 必存在包含边(u,v)的最小生成树

#### 主要算法
- 基于贪心策略
  - Prim算法
  - Kruskal算法

</ul>

### 通用最小生成树算法
<ul>

GENERICMST(G)(
T = NULL;
while T未形成一棵生成树
    do找到一条最小代价边(u,v)并且加入T后不会产生回路
    T = T∪(u,v)

- 算法特点
  - 每次加入一条边
  - 逐渐形成生成树

</ul>

### Prim算法
<ul>

#### 算法思想
- 执行非常类似于寻找图的最短路径的Dijkstra算法（见下一节）

>pro：Prim算法构造最小生成树的实例（2015、2017、2018）  

#### 构造过程
- 初始阶段
  - 从图中任取一顶点（如顶点1）加入树T
  - 此时树中只含有一个顶点
- 生长阶段
  - 选择一个与当前T中顶点集合距离最近的顶点
  - 将该顶点和相应的边加入T
  - 每次操作后T中的顶点数和边数都增1
- 终止条件
  - 直至图中所有的顶点都并入T
  - 得到的T就是最小生成树
  - T中必然有n-1条边

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/413704bf3253c2671855c3395ee5f1027e23761bf8da66bca7df35e4ef0ebc82.jpg)  
图6.15Prim算法构造最小生成树的过程  

#### 算法步骤
##### 前提条件
- G={V,E}是连通图
- 其最小生成树T=(U,ET)
- ET是最小生成树中边的集合

##### 具体步骤
- 初始化
  - 向空树T=(U,ET)中添加图G=(V,E)的任意一个顶点u0
  - 使U={u0}
  - ET=∅
- 循环（重复下列操作直至U=V)
  - 从图G中选择满足{(u,v)|u∈U,v∈V-U}且具有最小权值的边(u,v)
  - 加入树T
  - 置U=U∪{v}, ET=ET∪{(u,v)}

#### 代码实现

void Prim（G,T）
T=∅  //初始化空树
U={w} //添加任意一个顶点w
while((V-U)!=∅) //若树中不含全部顶点
    设(u,v)是使u∈U与v∈(V-U)，且权值最小的边；
    T=T∪{(u,v)} //边归入树
    U=U∪{v} //顶点归入树


#### 算法复杂度
- 时间复杂度为O(|V|²)
- 不依赖于|E|
- 适用于求解边稠密的图的最小生成树
- 其他改进
  - 采用其他方法能改进Prim算法的时间复杂度
  - 但增加了实现的复杂性
</ul>

### Kruskal算法  
<ul>

#### 基本概念
- 与Prim算法不同的特点
  - Prim从顶点开始扩展最小生成树
  - Kruskal按权值递增次序选择合适的边来构造

> pro：Kruskal算法构造最小生成树的实例（2015、2018、2020）  

#### 构造过程
- 初始状态
  - 只有n个顶点而无边的非连通图T={V,{}}
  - 每个顶点自成一个连通分量
- 选边过程
  - 按边的权值由小到大顺序选取
  - 选择当前未被选取且权值最小的边
  - 判断条件
    - 若边的顶点落在T中不同连通分量上，则将此边加入T
    - 否则舍弃此边，选择下一条权值最小的边
- 终止条件
  - 直至T中所有顶点都在一个连通分量上

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/dfb9edf9b314446b65731e53e39a987ef76f3a653992a0d176bd51f77fe01337.jpg)  
图6.16Kruskal算法构造最小生成树的过程  

#### 算法步骤
##### 前提条件
- G=(V,E)是连通图
- 其最小生成树T=(U,ET)

##### 具体步骤
- 初始化
  - U=V,ET=∅
  - 每个顶点构成独立的树
  - T此时是仅含|V|个顶点的森林
- 循环（重复直至T是一棵树）
  - 按G的边的权值递增顺序从E-ET中选择边
  - 若加入T后不构成回路，则将其加入ET
  - 否则舍弃
  - 直到ET中含有n-1条边

#### 代码实现
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/2b5891ebe5b470c06be5813e03e210a476a10eb80e5ae811e0df366ecf210561.jpg)  

#### 算法原理
- 边的连接特性
  - 若一条边连接两棵不同树中的顶点
  - 对这两棵树来说必定是连通的
  - 将边加入森林中完成两棵树的合并
  - 直到整个森林合并成一棵树

#### 算法复杂度
- 时间复杂度分析
  - 最坏情况需要对|E|条边各扫描一次
  - 采用堆存放边集合
    - 选择最小权值边需要O(log₂|E|)时间
  - 使用并查集判断顶点集合
    - 所需时间为O(α(|V|))
    - α(V)增长极其缓慢，可视为常数
- 总时间复杂度
  - O(|E|log₂|E|)
  - 不依赖于|V|
  - 适合于边稀疏而顶点较多的图
</ul>

</ul>

## 最短路径  
<ul>

> pro：最短路径的分析与举例以及相关的算法（2009、2023）  

### 最短路径概述
<ul>

- 广度优先搜索查找最短路径只适用于无权图
- 带权图中的最短路径定义：
  - 从顶点v₀到vi的路径上边权值之和为带权路径长度
  - 带权路径长度最短的路径称为最短路径
- 最短路径的基本性质：
  - 两点间最短路径包含了路径上其他顶点间的最短路径
- 带权有向图最短路径问题分类：
  - 单源最短路径：求某一顶点到其他各顶点的最短路径(Dijkstra算法)
  - 每对顶点间最短路径：求任意两顶点间的最短路径(Floyd算法)

</ul>

### Dijkstra算法求单源最短路径问题
<ul>

#### 算法基本思想
- 使用集合S记录已求得最短路径的顶点
- 初始时将源点v₀放入S
- 每并入新顶点vi都要修改源点到V-S中顶点的最短路径长度

#### 辅助数组
- final[]：标记顶点是否已找到最短路径
- dist[]：记录从源点到各顶点当前最短路径长度
  - 初始值：
    - 有弧时为弧上权值
    - 无弧时置为∞
- path[]：记录最短路径的前驱结点

#### 算法步骤
1. 初始化
   - S初始为{0}
   - dist[i] = arcs[0][i], i=1,2,...,n-1

2. 选择新顶点
   - 从V-S中选出vj，满足dist[j] = Min{dist[i]|vi∈V-S}
   - 将vj加入S

3. 更新最短路径
   - 修改v₀到V-S中顶点vk的最短路径长度
   - 若dist[j]+arcs[j][k] < dist[k]
   - 则更新dist[k] = dist[j] + arcs[j][k]

4. 重复步骤2-3
   - 执行n-1次
   - 直到所有顶点都在S中

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/d8cd3f126d0f9f02af5404cbc8a5301d32f89543ad84684ca594dafd871d7647.jpg)  

> 思考：Dijkstra和Prim算法有何异同之处？

> pro：Dijkstra算法求解最短路径的实例（2012、2014、2016、2021）  

#### 算法实例
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/c7090950bb73763feef7e1ea4c3e3ea318d642815621a4657605a0e98585dbdc.jpg)  
图6.17应用Dijkstra算法图  

表6.2从v₁到各终点的dist值和最短路径的求解过程
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9f8939ca7029cd3a8d7e5c73314b7488664116e02a550898bfbcd99d295b6878.jpg)  

##### 求解过程
- 初始化
  - S = {v₁}
  - dist[2] = 10
  - dist[3] = ∞
  - dist[4] = ∞
  - dist[5] = 5

- 第1轮
  - 选择v₅(dist[5]最小)
  - 更新dist数组：
    - dist[2] = 8 (v₁→v₅→v₂)
    - dist[3] = 14 (v₁→v₅→v₃)
    - dist[4] = 7 (v₁→v₅→v₄)

- 第2轮
  - 选择v₄(dist[4]最小)
  - 更新dist数组：
    - dist[3] = 13 (v₁→v₅→v₄→v₃)

- 第3轮
  - 选择v₂(dist[2]最小)
  - 更新dist数组：
    - dist[3] = 9 (v₁→v₅→v₂→v₃)

- 第4轮
  - 选择v₃(dist[3]最小)
  - 算法结束

#### 算法特性
- 基于贪心策略
- 时间复杂度
  - 邻接矩阵表示：O(|V|²)
  - 带权邻接表表示：O(|V|²)
- 局限性
  - 不适用于负权值的图
  - 原因说明：
    - 负边可能导致已确定的最短路径需要更新
    - 算法无法处理这种更新

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/354061dd6653c1cf7d28647835680430baf780d8a8c6da4925a50828c972315d.jpg)  
图6.18边上带有负权值的有向带权图  
</ul>

### Floyd算法求各顶点之间最短路径问题  
<ul>

#### 问题描述
- 已知一个各边权值均大于0的带权有向图
- 对任意两个顶点 $v_{i}\not=v_{j}$ ，要求求出 $\nu_{i}$ 与 $v_{j}$ 之间的:
  - 最短路径
  - 最短路径长度

#### 算法基本思想
- 递推产生一个 $n$ 阶方阵序列 $A^{(-1)}$  $A^{(0)},\cdots,\,A^{(k)},\cdots,\,A^{(n-1)}$
  - $A^{(k)}[i][j]$ 表示从顶点 $v_{i}$ 到顶点 $v_{j}$ 的路径长度
  - $k$ 表示绕行第 $k$ 个顶点的运算步骤

##### 初始化过程
- 对任意两个顶点 $v_{j}$ 和 $v_{j}$ :
  - 存在边：以此边上的权值作为最短路径长度
  - 不存在边：以∞作为最短路径长度

##### 迭代过程
- 逐步尝试在原路径中加入顶点 $k$  $\textit{k}(k=0,\,1,\cdots,n-1\,)$ 作为中间顶点
- 若新路径更短：则替换原路径

#### 算法数学描述
- 定义 $n$ 阶方阵序列 $A^{(-1)},A^{(0)},\cdots,A^{(n-1)}$
- 初始条件：$A^{(-1)}[i][j]=\arcsin[i][j]$
- 递推公式：$\begin{array}{r}{A^{(k)}[i][j]=\operatorname{Min}\{A^{(k-1)}[i][j],\quad A^{(k-1)}[i][k]+A^{(k-1)}[k][j]\},\ k=0,1,\cdots,n-1}\end{array}$

#### 算法实例
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/9563eb9adc4d1c1bbd123557953338f0013fcf037d3a58a2bb15403ac38ae2a2.jpg)  

##### 求解过程
- 初始化：方阵 $A^{(-1)}[i][j]=$ arcs[][]
- 第1轮：
  - 将 $v_{0}$ 作为中间顶点
  - 对所有顶点对 $\{i,j\}$ 进行更新
  - $\begin{array}{r}{\boldsymbol{A}^{-1}[2][1]>\boldsymbol{A}^{-1}[2][0]+\boldsymbol{A}^{-1}[0][1]=11}\end{array}$
  - 更新 $A^{-1}[2][1]=11$
- 第2轮：
  - 将 $\nu_{1}$ 作为中间顶点
  - $A^{0}[0][2]>A^{0}[0][1]+A^{0}[1][2]=10$
  - 更新 $A^{0}[0][2]=10$
- 第3轮：
  - 将 $\nu_{2}$ 作为中间顶点
  - $\begin{array}{r}{\boldsymbol{A}^{1}[1][0]>\boldsymbol{A}^{1}[1][2]+\boldsymbol{A}^{1}[2][0]=\boldsymbol{9}}\end{array}$
  - 更新 $A^{1}[1][0]=9$

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/91b9d670ed390741ce41fa7fada27f7a43fe887b80c64666880ba9353d11e80f.jpg)  

#### 算法特性
- 时间复杂度：$O(|V|^{3})$
- 优点：
  - 代码紧凑
  - 不包含复杂数据结构
  - 常数系数小
- 适用范围：
  - 允许负权值边
  - 不允许负权值边组成回路
  - 适用于带权无向图

#### 算法比较
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7c367d52e0336cc1a989ce844941cf5beff18d63452f540edc3163d0104266fc.jpg)  

</ul>

### 有向无环图描述表达式  
<ul>

#### 基本概念
- 有向无环图(DAG图)：不存在环的有向图

> pro：构建表达式的有向无环图（2019）  

#### 应用实例
- 表达式：$((a+b)^{*}(b^{*}(c+d))+(c+d)^{*}e)^{*}((c+d)^{*}e)$
- 表示方法比较：
  - 二叉树表示：
    ![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/7e1ae982871a34fb5119dda6581088409768da4bd88e8d177af012108a5f7ae4.jpg)  
  - 有向无环图表示：
    ![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/e4c2332ba4acd478e43e4a2865dff8a8e7911989ffb9daa949ca81a074232194.jpg)  

> attention 

在表达式的有向无环图表示中，不可能出现重复的操作数顶点。

</ul>

</ul>

## 拓扑排序
<ul>

### AOV网的基本概念
<ul>

- AOV网定义：
  - 用有向无环图表示一个工程
  - 顶点表示活动
  - 有向边<Vi,Vj>表示活动Vi必须先于活动Vj进行

- 活动关系：
  - Vi是Vj的直接前驱
  - Vj是Vi的直接后继
  - 前驱和后继关系具有传递性
  - 活动不能以自己作为自己的前驱或后继

</ul>

### 拓扑排序的定义
<ul>

#### 基本定义
- 由有向无环图顶点组成的序列，满足：
  - 每个顶点出现且只出现一次
  - 若顶点A在序列中排在顶点B前面，则图中不存在从B到A的路径

#### 替代定义
- 对有向无环图顶点的一种排序：
  - 若存在从顶点A到顶点B的路径，则B在排序中出现在A后面
  - 每个AOV网都有一个或多个拓扑排序序列

> pro：拓扑排序和回路的关系（2011）

</ul>

### 拓扑排序算法
<ul>

#### 基本步骤
- 从AOV网中选择一个没有前驱（入度为0）的顶点并输出
- 从网中删除该顶点和所有以它为起点的有向边
- 重复上述步骤直到：
  - AOV网为空 或
  - 不存在无前驱的顶点（说明存在环）

> pro：拓扑排序的实例（2010、2014、2018、2021）

![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/8810ace9ff20c9670d0e1272ddf371bd248455d387e1a48022dfcfc7f025d42a.jpg)

#### 算法实现

TopologicalSort(Graph G){
    InitStack(S);
    int i;
    for(i=0;i<G.vexnum;i++)
        if(indegree[i]==0)
            Push(S,i);
    int count=0;
    while(!IsEmpty(S)){
        Pop(S,i);
        print[count++]=i;
        for(p=G.vertices[i].firstarc;p;p=p->nextarc){
            v=p->adjvex;
            if(!(--indegree[v]))
                Push(S,v);
        }
    }
    if(count<G.vexnum)
        return false;
    else
        return true;
}


> pro：不同存储方式下的拓扑排序的效率（2016）

#### 时间复杂度
- 邻接表存储：O(|V|+|E|)
- 邻接矩阵存储：O(|V|²)

> pro：DFS实现拓扑排序的思想（2020）

#### DFS实现方法
- 结点关系分类：
  - u是v的祖先：v的DFS结束时间先于u
  - u是v的子孙：v的结束时间大于u
  - u和v无路径关系：拓扑序列关系任意

</ul>

### 逆拓扑排序
<ul>

#### 步骤
- 选择没有后继（出度为0）的顶点并输出
- 删除该顶点和所有以它为终点的有向边
- 重复直到AOV网为空

</ul>

### 注意事项
<ul>

#### 关键问题
- 入度为零的顶点：
  - 没有前驱活动
  - 前驱活动都已完成
  - 可以开始或继续的活动

> pro：分析给定图的拓扑序列的存在性和唯一性（2011）

#### 排序结果特性
- 非唯一性：
  - 顶点有多个直接后继时，结果通常不唯一
  - 顶点在线性序列中有唯一前驱后继关系时，结果唯一

#### 邻接矩阵特性
- 可按拓扑排序结果重新编号
- 生成新的邻接存储矩阵（可能是三角矩阵）
- 三角矩阵特性：
  - 若邻接矩阵是三角矩阵，则存在拓扑序列
  - 反之不一定成立

</ul>

</ul>

## 关键路径
<ul>

### AOE网定义与特点
<ul>

- 基本概念
  - 带权有向图中以顶点表示事件
  - 有向边表示活动
  - 边上权值表示完成活动的开销
  - 简称AOE网

- 与AOV网的区别
  - 共同点：都是有向无环图
  - 不同点：
    - AOE网边有权值
    - AOV网边无权值，仅表示顶点前后关系

- 网络特性
  - 顶点特点：
    - 只有一个入度为0的开始顶点（源点）
    - 只有一个出度为0的结束顶点（汇点）
  - 活动规则：
    - 顶点事件发生后才能开始出发边的活动
    - 进入顶点的所有边活动结束后才能发生该顶点事件

</ul>

### 关键路径概念
<ul>

- 基本特征
  - 活动可并行进行
  - 源点到汇点可能有多条路径
  - 路径长度可能不同
  - 所有路径活动完成才算工程结束

- 关键定义
  - 关键路径：源点到汇点最大路径长度的路径
  - 关键活动：关键路径上的活动
  - 工程最短完成时间：关键路径长度

> pro：关键路径的性质（2020）

</ul>

### 关键参量定义
<ul>

#### 事件最早发生时间ve(k)
- 定义：源点到顶点vk的最长路径长度
- 计算公式：
  - ve(源点) = 0
  - ve(k) = Max{ve(j) + Weight(vj,vk)}

> attention 

- 计算步骤：
  - 初始：ve[1...n] = 0
  - 按拓扑顺序处理
  - 更新后继顶点的最早发生时间

#### 事件最迟发生时间vl(k)
- 定义：不推迟工程完成的前提下事件最迟必须发生时间
- 计算公式：
  - vl(汇点) = ve(汇点)
  - vl(k) = Min{vl(j) - Weight(vk,vj)}

> attention 

- 计算步骤：
  - 初始：vl[1...n] = ve[n]
  - 按逆拓扑顺序处理
  - 使用栈记录拓扑序列

#### 活动时间参数
##### 最早开始时间e(i)
- 定义：活动弧起点事件的最早发生时间
- 计算：e(i) = ve(k)

##### 最迟开始时间l(i)
- 定义：终点事件最迟发生时间减活动所需时间
- 计算：l(i) = vl(j) - Weight(vk,vj)

##### 时间余量d(i)
- 定义：l(i) - e(i)
- 特点：
  - 表示活动可拖延时间
  - d(i) = 0表示关键活动

</ul>

### 求解关键路径
<ul>

> pro：求关键路径的实例（2019、2022）

#### 算法步骤
1. 计算ve值
2. 计算vl值
3. 计算e值
4. 计算l值
5. 计算d值找出关键活动

#### 实例说明
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/3c83283a75649b4d8c5c2d0548388cadf2a7ab0f11784d1e7fa5d35976e5c5b2.jpg)
图6.23求解关键路径的过程

</ul>

### 工期优化分析
<ul>

> pro：缩短工期的相关分析（2013）

#### 关键路径注意事项
- 关键活动特点
  - 都在关键路径上
  - 可通过加快关键活动缩短工期
  - 缩短程度有限制

- 多关键路径情况
  - 关键路径可能不唯一
  - 需同时加快所有关键路径上的活动
  - 仅提高单条路径无法缩短总工期

</ul>

</ul>

### 算法复杂度对比
<ul>

表6.5采用不同存储结构时各种图算法的时间复杂度
![](https://cdn-mineru.openxlab.org.cn/model-mineru/prod/0cd28f07c2726861bd6847070ff8c2ca1109e478a5a69b4406f36d63f04ed47e.jpg)

</ul>

</ul>
```

### 处理说明
1. **标题与 `<ul>` 的层级关系**：根据标题级别（`#`, `##`, `###` 等），在每个标题后的内容段落添加了对应的 `<ul></ul>` 标签，并确保上下有空行。
2. **图片链接保留**：所有 Markdown 格式的图片链接（如 `![](url)`）均未更改，保持原样。
3. **嵌套缩进**：对于子标题（如 `####`），在上一级 `<ul>` 内继续嵌套 `<ul>`，符合期望格式。
4. **空行处理**：确保 `<ul>` 和 `</ul>` 上下均有空行，与非 `<ul>` 内容分隔开。

如果还有其他需求，请随时告知！